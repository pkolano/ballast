#!/usr/bin/perl -T
#
# Copyright (C) 2010-2016 United States Government as represented by the
# Administrator of the National Aeronautics and Space Administration
# (NASA).  All Rights Reserved.
#
# This software is distributed under the NASA Open Source Agreement
# (NOSA), version 1.3.  The NOSA has been approved by the Open Source
# Initiative.  See http://www.opensource.org/licenses/nasa1.3.php
# for the complete NOSA document.
#
# THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY WARRANTY OF ANY
# KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT
# LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL CONFORM TO
# SPECIFICATIONS, ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
# A PARTICULAR PURPOSE, OR FREEDOM FROM INFRINGEMENT, ANY WARRANTY THAT
# THE SUBJECT SOFTWARE WILL BE ERROR FREE, OR ANY WARRANTY THAT
# DOCUMENTATION, IF PROVIDED, WILL CONFORM TO THE SUBJECT SOFTWARE. THIS
# AGREEMENT DOES NOT, IN ANY MANNER, CONSTITUTE AN ENDORSEMENT BY
# GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT OF ANY RESULTS, RESULTING
# DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER APPLICATIONS RESULTING
# FROM USE OF THE SUBJECT SOFTWARE.  FURTHER, GOVERNMENT AGENCY DISCLAIMS
# ALL WARRANTIES AND LIABILITIES REGARDING THIRD-PARTY SOFTWARE, IF
# PRESENT IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT "AS IS".
#
# RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS AGAINST THE UNITED STATES
# GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY PRIOR
# RECIPIENT.  IF RECIPIENT'S USE OF THE SUBJECT SOFTWARE RESULTS IN ANY
# LIABILITIES, DEMANDS, DAMAGES, EXPENSES OR LOSSES ARISING FROM SUCH USE,
# INCLUDING ANY DAMAGES FROM PRODUCTS BASED ON, OR RESULTING FROM,
# RECIPIENT'S USE OF THE SUBJECT SOFTWARE, RECIPIENT SHALL INDEMNIFY AND
# HOLD HARMLESS THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
# SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT, TO THE EXTENT PERMITTED
# BY LAW.  RECIPIENT'S SOLE REMEDY FOR ANY SUCH MATTER SHALL BE THE
# IMMEDIATE, UNILATERAL TERMINATION OF THIS AGREEMENT.
#

package Ballast;

require Net::Server::MultiType;
push(@Ballast::ISA, 'Net::Server::MultiType');

use strict;
require Crypt::CBC;
require Date::Parse;
use Fcntl;
use Getopt::Long qw(:config bundling no_ignore_case require_order);
use MIME::Base64;
require MLDBM;
require MLDBM::Sync;
use Socket;
use Storable qw(thaw);
require Text::FormatTable;

our $VERSION = 0.20;

# default configuration
my %conf = (
    alias_last => "-last",
    conf_file => "/etc/ballastrc",
    data_cipher => "XXTEA_PP",
    data_port => 4411,
    data_timeout => 2,
    host_timeout => 180,
    key_file => "/etc/ballast.key",
    run_setsid => 1,
    syslog_facility => "syslog",
    syslog_ident => "ballast",
    syslog_logopt => "ndelay,pid",
    user_sum => "cpu mem ram io_bytes io_ops io_reads io_read_bytes io_writes io_write_bytes",
);

# parse parameters (preserve @ARGV for Net::Server)
my @save_argv = @ARGV;
GetOptions(\%conf, "conf_file|c=s", "dump", "stats") or die "Invalid options\n";

# parse configuration
my $paren_re;
$paren_re = qr{\((?:(?>[^()]+)|(??{$paren_re}))*\)}x;
open(FILE, $conf{conf_file}) or die "Unable to load config file: $!\n";
my $mline;
while (my $line = <FILE>) {
    # strip whitespace and comments
    $line =~ s/^\s+|\s+$|\s*#.*//g;
    next if (!$line);
    # support line continuation operator
    $mline .= $line;
    next if ($mline =~ s/\s*\\$/ /);
    if ($mline =~ /^(\S+)\s+(.*)/) {
        my ($key, $val) = ($1, $2);
        if ($key =~ /^policy_/) {
            $val =~ s/(?!(?:cmp|eq|le|lt|ge|gt|ne)\W)(?<!\w)((?:abs|product|q|qr|sum)\s*$paren_re|[a-zA-Z]\w*)/load(q{$1})/g;
        }
        $conf{$key} = $val;
    }
    $mline = undef;
}
close FILE;

$MLDBM::UseDB = 'DB_File';

dump_db() if ($conf{dump});
stats() if ($conf{stats});

# @ARGV must not be restored until after dump
@ARGV = @save_argv;

# set up encryption if configured
if (-e $conf{key_file}) {
    open(FILE, $conf{key_file}) or die "Unable to load key file: $!\n";
    my $key = <FILE>;
    close FILE;

    # untaint key
    $key = $1 if ($key =~ /(.*)/);

    my %cbc = (
        -key => $key,
        -cipher => $conf{data_cipher},
    );
    $cbc{-keysize} = 16 if ($conf{data_cipher} eq 'XXTEA_PP');
    $conf{-cbc} = Crypt::CBC->new(%cbc);
}

# tie persistent load database to hash
my %load;
my $sync = tie(%load, 'MLDBM::Sync', $conf{data_db}, O_RDWR | O_CREAT, 0600) or
    die "Unable to tie load database: $!\n";

#################
#### dump_db ####
#################
sub dump_db {
    # tie persistent load database to hash
    my %load;
    my $sync = tie(%load, 'MLDBM::Sync', $conf{data_db}, O_RDONLY, 0600) or
        die "Unable to tie load database: $!\n";

    # dump all keys
    $sync->ReadLock;
    foreach my $key (sort(keys(%load))) {
        if ($ARGV[0]) {
            # dump only values matched by regex
            next if ($key !~ qr/$ARGV[0]/);
        }
        print "$key = $load{$key}\n";
    }
    $sync->UnLock;
    exit;
}

##############
#### load ####
##############
# function to handle evaluation of policy expressions
my %load_vars;
sub load {
    my $expr = shift;
    $expr =~ s/^\s+|\s+$//g;
    my $return;
    if ($expr =~ /q\s*\((.*)\)/) {
        # quote operator
        return $1;
    } elsif ($expr =~ /qr\s*\((.*)\)/) {
        # regex quote operator
        return qr($1);
    } elsif ($expr =~ /abs\s*\((.*)\)/) {
        # absolute value
        return abs(eval $1);
    } elsif ($expr =~ /(sum|product)\s*\((.*)\)/) {
        my ($op, $arg0) = ($1, $2);
        my $result = $op eq 'sum' ? 0 : 1;
        foreach my $sid (grep(/^$load_vars{host}:sid_/, keys(%load))) {
            my $uid = $load{$sid};
            if ($uid =~ /(?:^|\s)uid:(\d+)/) {
                $uid = $1;
                my $arg = $arg0;
                $arg =~ s/user_i_/uid_$uid\_/g;
                $arg =~ s/((?:sum|product)\s*$paren_re|[a-zA-Z]\w*)/load(q{$1})/g;
                my $val = eval $arg;
                $result = $op eq 'sum' ? $result + $val : $result * $val;
            }
        }
        $return = $result;
    } elsif ($expr eq 'user_uid') {
        $return = $load_vars{uid};
    } elsif ($expr =~ /(uid_\d+|user)_(\w+)/) {
        my ($uid, $metric) = ($1, $2);
        if ($uid eq 'user') {
            $uid = $load_vars{uid};
        } else {
            $uid =~ s/\D*//g;
        }
        my $rank = $metric =~ s/_rank$//;

        my $uval = $load{"uid_$uid"};
        if ($uval =~ /(?:^|\s)$metric:(\S+)/) {
            $uval = $1;
            if ($rank) {
                # higher rank indicates higher usage
                foreach my $uid (grep(/^uid_/, keys(%load))) {
                    # increase rank for any users with higher value of given metric
                    $rank++ if ($load{$uid} =~ /(?:^|\s)$metric:(\S+)/ && $1 < $uval);
                }
                $return = $rank;
            } else {
                $return = $uval;
            }
        }
    } elsif ($expr eq 'users') {
        $return = $load{users};
    } elsif ($expr eq 'random') {
        $return = int(rand(100)) + 1;
    } elsif ($expr =~ /^arg(\d+)$/) {
        $return = $load_vars{args}->[$1];
    } elsif ($expr eq 'client_ip') {
        $return = $load_vars{client_ip};
    } else {
        $return = $load{"$load_vars{host}:$expr"};
    }
    # return default value of 1 if return not defined
    return defined $return ? $return : 1;
}

###################
#### mux_input ####
###################
# called by Net::Server on accepted connection when multiplexed
sub mux_input {
    my ($self, $mux, $fh, $data) = @_;
    while ($$data =~ s/^(.*?)\r?\n//) {
        process_common($self->{net_server}, $1);
    }
}

#########################
#### process_request ####
#########################
# called by Net::Server on accepted connection when forked
sub process_request {
    my $self = shift;
    eval {
        local $SIG{ALRM} = sub {die "alarm\n"};
        alarm $conf{data_timeout};
 
        while (<STDIN>) {
            s/\r?\n$//;
            process_common($self, $_);
        }
        alarm 0;
    }
    # do nothing on timeout
}

########################
#### process_common ####
########################
# common processing for both multiplexed and forked
sub process_common {
    my ($self, $text) = @_;
    if ($text =~ /^#/) {
        substr($text, 0, 1) = "";
        update_load($self, $text);
    } elsif ($text =~ /^([\w-]+)\s+(\d+)(.*)$/) {
        select_host($self, $1, $2, $3);
    }
}

#####################
#### select_host ####
#####################
# select host for client
sub select_host {
    my ($self, $alias, $uid, $args) = @_;
    # set client_ip for logging and load function
    $load_vars{client_ip} = $self->{server}->{peeraddr};
    my $last = $alias =~ s/$conf{alias_last}$// ? $conf{alias_last} : "";
    my $return = "";
    if ($last && exists $load{"last_$alias\_$uid"}) {
        # return last host selected
        $return = $load{"last_$alias\_$uid"};
    } else {
        # find hosts that map to given alias
        my @hosts = grep(/:alias$/, keys(%load));
        my @min_hosts;
        my $min;
        my $time = time;
        # set uid for load function
        $load_vars{uid} = $uid;
        # set args for load function
        $args =~ s/^\s+|\s+$//g;
        $load_vars{args} = [split(/\s+/, $args)];
        # set data alias
        my $data_alias = $conf{"data_alias_$alias"};
        $data_alias = $alias if (!$data_alias);
        $sync->ReadLock;
        foreach my $host (grep(/:alias$/, keys(%load))) {
            next if ($data_alias !~ qr/(?:^|\s)$load{$host}(?:$|\s)/);
            $host =~ s/:alias//;
            if ($time > $load{"$host:time"} + $conf{host_timeout}) {
                # assume host down if host_timeout elapsed
                $self->log(4, "ignoring stale data for host $host");
                next;
            }
            # set host for load function
            $load_vars{host} = $host;
            my $val = eval($conf{"policy_$alias"});
            $self->log(4,
                "host $host evaluates to $val for $alias/$uid from $load_vars{client_ip}");
            if (0 <= $val && (!defined $min || $val < $min)) {
                @min_hosts = ($host);
                $min = $val;
            } elsif (defined $min && $val == $min) {
                push(@min_hosts, $host);
            }
        }
        $sync->UnLock;
        $return = $min_hosts[int(rand(scalar(@min_hosts)))]
            if (scalar(@min_hosts) > 0);
    }
    $load{"last_$alias\_$uid"} = $return if ($return);
    $self->log(2,
        "$alias$last/$uid returns \"$return\" to $load_vars{client_ip}");
    print "$return\n";
}

####################
#### session_id ####
####################
# find ssh session pid from any currently running pid
sub session_id {
    my ($load_ref, $pid) = @_;
    my $proc = $load_ref->{$pid};
    if ($proc =~ /(?:^|\s)cmd:(?:sshd|dropbear)/) {
        # process is ssh server fork so return pid
        $pid =~ s/^p/s/;
        return $pid;
    } elsif ($proc =~ /(?:^|\s)ppid:(\d+)/) {
        # recursively compute session from parent pid
        return session_id($load_ref, "pid_$1");
    } else {
        # session unknown if no parent pid
        return "sid_unknown";
    }
}

###############
#### stats ####
###############
sub stats {
    my %all;
    my @row;
    my $t;
    my $now = time;
    my $week = 60 * 60 * 24 * 7;

    while (<STDIN>) {
        if (/(.*)\s+\S+\s+$conf{syslog_ident}.*\s+([-\w]+)\/(\d+)\s+returns\s+"([^"]*)"\s+to\s+(\S+)/) {
            my ($time, $alias, $uid, $hosts, $src) = ($1, $2, $3, $4, $5);
            my $secs = Date::Parse::str2time($time);
            next if ($now - $secs > $week);
            my @date = localtime($secs);
            my $day = sprintf("%02d", $date[4] + 1) . "/" .
                sprintf("%02d", $date[3]) . "/" .
                sprintf("%02d", $date[5] % 100);
            my $tmp = gethostbyaddr(inet_aton($src), AF_INET);
            $src = $tmp if ($tmp);
            $all{"day:$day src:$src uid:$uid"}++;
            $all{"day:$day uid:$uid"}++;
            $all{"src:$src uid:$uid"}++;
            $all{"uid:$uid"}++;
            $all{"day:$day"} = 1;
            $all{"src:$src"} = 1;
            $hosts = "none" if (!$hosts);
            foreach my $dst (split(/\s+/, $hosts)) {
                $all{"dst:$dst"} = 1;
                $all{"day:$day dst:$dst"}++;
            }
        }
    }

    # set up common header
    my $align = "l";
    my @head = (undef);
    foreach my $day (sort(map {s/day://; $_} grep(/^day:\S+$/, keys(%all)))) {
        $align .= " | r";
        push(@head, $day);
    }
    $align .= " | r";
    push(@head, "all");
    my $t;

    #### selections per system ####
    $head[0] = "system";
    $t = Text::FormatTable->new($align);
    $t->head(@head);

    $t->rule;
    foreach my $dst (sort(map {s/dst://; $_} grep(/^dst:\S+$/, keys(%all)))) {
        @row = ($dst);
        my $total;
        foreach my $day (sort(grep(/^day:\S+$/, keys(%all)))) {
            my $dsts;
            $dsts += $all{$_} foreach (grep(/$day dst:$dst/, keys(%all)));
            push(@row, defined $dsts ? $dsts : "");
            $total += $dsts;
        }
        push(@row, defined $total ? $total : "");
        $t->row(@row);
    }

    $t->rule;
    @row = ("\nall (" . scalar(grep(/^dst:\S+$/, keys(%all))). ")");
    my $total;
    foreach my $day (sort(grep(/^day:\S+$/, keys(%all)))) {
        my $dsts;
        $dsts += $all{$_} foreach (grep(/$day dst:/, keys(%all)));
        push(@row, defined $dsts ? "\n$dsts" : "\n");
        $total += $dsts;
    }
    push(@row, defined $total ? "\n$total" : "\n");
    $t->row(@row);
    print "Selections per System\n\n", $t->render, "\n\n";

    #### calls per user ####
    $head[0] = "user";
    $t = Text::FormatTable->new($align);
    $t->head(@head);

    $t->rule;
    foreach my $user (sort(map
            {s/uid://; my $u = getpwuid($_); $_ = defined $u ? $u : $_}
            grep(/^uid:\S+$/, keys(%all)))) {
        my $uid = getpwnam($user);
        $uid = $user if (!defined $uid);
        @row = ($user);
        my $total;
        foreach my $day (sort(grep(/^day:\S+$/, keys(%all)))) {
            my $calls;
            $calls += $all{$_} foreach (grep(/$day uid:$uid/, keys(%all)));
            push(@row, defined $calls ? $calls : "");
            $total += $calls;
        }
        push(@row, defined $total ? $total : "");
        $t->row(@row);
    }

    $t->rule;
    @row = ("\nall (" . scalar(grep(/^uid:\S+$/, keys(%all))). ")");
    foreach my $day (sort(grep(/^day:\S+$/, keys(%all)))) {
        my $calls;
        $calls += $all{$_} foreach (grep(/$day uid:/, keys(%all)));
        push(@row, defined $calls ? "\n$calls" : "\n");
    }
    my $calls;
    $calls += $all{$_} foreach (grep(/^uid:/, keys(%all)));
    push(@row, defined $calls ? "\n$calls" : "\n");
    $t->row(@row);
    print "Calls per User\n\n", $t->render, "\n\n";

    #### calls per source ####
    $head[0] = "source";
    $t = Text::FormatTable->new($align);
    $t->head(@head);

    $t->rule;
    foreach my $src (sort(map {s/src://; $_} grep(/^src:\S+$/, keys(%all)))) {
        @row = ($src);
        my $total;
        foreach my $day (sort(grep(/^day:\S+$/, keys(%all)))) {
            my $calls;
            $calls += $all{$_} foreach (grep(/$day src:$src/, keys(%all)));
            push(@row, defined $calls ? $calls : "");
            $total += $calls;
        }
        push(@row, defined $total ? $total : "");
        $t->row(@row);
    }

    $t->rule;
    @row = ("\nall (" . scalar(grep(/^src:\S+$/, keys(%all))). ")");
    my $total;
    foreach my $day (sort(grep(/^day:\S+$/, keys(%all)))) {
        my $calls;
        $calls += $all{$_} foreach (grep(/$day uid:/, keys(%all)));
        push(@row, defined $calls ? "\n$calls" : "\n");
        $total += $calls;
    }
    push(@row, defined $total ? "\n$total" : "\n");
    $t->row(@row);
    print "Calls per Source\n\n", $t->render, "\n\n";
    exit;
}

#####################
#### update_load ####
#####################
# update load data from agent
sub update_load {
    my ($self, $text) = @_;
    if (defined $conf{-cbc}) {
        # decrypt data if specified
        $text = $conf{-cbc}->decrypt_hex($text);
    } else {
        # decode data when not encrypted
        $text = decode_base64($text);
    }
    return if ($text !~ s/^#ballast#//);
    my %load_new = %{thaw($text)};
    my $host = $load_new{host};
    return if (!$host);

    # gather previous load for host
    my $colon = length($host) + 1;
    my %load_old;
    $sync->ReadLock;
    foreach my $key (grep(/^$host:/, keys %load)) {
        $load_old{substr($key, $colon)} = $load{$key};
    }
    $sync->UnLock;

    # update differential loads
    foreach my $abs (grep(/^d_/, keys %load_new)) {
        my $diff = substr($abs, 2);
        $load_new{$diff} = $load_new{$abs} - $load_old{$abs};
        # scale difference based on 60 second interval
        my $scale = $load_new{time} - $load_old{time};
        $load_new{$diff} *= 60.0 / $scale if ($scale > 0);
    }

    # update session totals for dead processes
    foreach my $pid (grep(/^pid_/, keys %load_old)) {
        next if (exists $load_new{$pid});
        my $sid = session_id(\%load_old, $pid);
        next if ($sid eq 'sid_unknown');
        my %sess = map {split(/:/, $_)} split(/\s+/, $load_old{$sid});
        my %proc = map {split(/:/, $_)} split(/\s+/, $load_old{$pid});
        foreach my $key (split(/\s+/, $conf{user_sum})) {
            $sess{"dead_$key"} += $proc{$key};
        }
        # store updated session
        $load_old{$sid} = join(" ", map {"$_:$sess{$_}"} keys(%sess));
    }

    # update session totals
    foreach my $pid (grep(/^pid_/, keys %load_new)) {
        my $sid = session_id(\%load_new, $pid);
        next if ($sid eq 'sid_unknown');
        my $load_ref = exists $load_new{$sid} ? \%load_new : \%load_old;
        my %sess = map {split(/:/, $_)} split(/\s+/, $load_ref->{$sid});
        my %proc = map {split(/:/, $_)} split(/\s+/, $load_new{$pid});
        if ($sess{last} != $load_new{time}) {
            $sess{last} = $load_new{time};
            # clear session totals
            foreach my $key (split(/\s+/, $conf{user_sum})) {
                $sess{$key} = 0;
            }
        }
        foreach my $key (split(/\s+/, $conf{user_sum})) {
            $sess{$key} += $proc{$key};
        }
        $sess{time} = $proc{time} if ($sess{time} < $proc{time});
        $sess{uid} = $proc{uid} if ($proc{uid} != 0);
        # store updated session
        $load_new{$sid} = join(" ", map {"$_:$sess{$_}"} keys(%sess));
    }

    # update sessions
    $load_new{sessions} = 0;
    foreach my $sid (grep(/^sid_/, keys %load_new)) {
        my %sess = map {split(/:/, $_)} split(/\s+/, $load_new{$sid});
        if (!$sess{uid}) {
            # ignore sessions with root or undefined uid
            delete $load_new{$sid};
            next;
        }
        $load_new{sessions}++;

        # add in totals from dead processes
        foreach my $key (split(/\s+/, $conf{user_sum})) {
            $sess{$key} += $sess{"dead_$key"};
        }
        $load_new{$sid} = join(" ", map {"$_:$sess{$_}"} keys(%sess));
    }

    # update user totals
    my %uids;
    foreach my $sid (grep(/^sid_/, keys %load_old)) {
        next if (exists $load_new{$sid});
        my %sess = map {split(/:/, $_)} split(/\s+/, $load_old{$sid});
        # ignore sessions with root or undefined uid
        next if (!$sess{uid});
        my $uid = "uid_$sess{uid}";
        my %user = map {split(/:/, $_)} split(/\s+/, $uids{$uid});
        $user{sessions}++;
        foreach my $key (split(/\s+/, "time $conf{user_sum}")) {
            $user{$key} += ($sess{$key} - $user{$key}) / $user{sessions};
        }
        # store updated user
        $uids{$uid} = join(" ", map {"$_:$user{$_}"} keys(%user));
    }

    $sync->Lock;
    # update stored load data
    while (my ($key, $val) = each %load_new) {
        $load{"$host:$key"} = $val;
    }
    # update user running averages
    while (my ($uid, $user_new) = each %uids) {
        my $user_old = $load{$uid};
        if ($user_old) {
            # update running average of each field
            my %user_old = map {split(/:/, $_)} split(/\s+/, $user_old);
            my %user_new = map {split(/:/, $_)} split(/\s+/, $user_new);
            $user_new{sessions} += $user_old{sessions};
            foreach my $key (split(/\s+/, "time $conf{user_sum}")) {
                $user_new{$key} += ($user_old{$key} - $user_new{$key}) *
                    ($user_old{sessions} / $user_new{sessions});
            }
            # store updated user
            $load{$uid} = join(" ", map {"$_:$user_new{$_}"} keys(%user_new));
        } else {
            $load{$uid} = $user_new;
            $load{users}++;
        }
    }
    # delete stale data that has not been updated
    foreach my $key (keys %load_old) {
        delete $load{"$host:$key"} if (!exists $load_new{$key});
    }
    $sync->UnLock;
}

# convert relevant config to Net::Server namespace
my %net_server;
$net_server{allow} = $conf{tcp_allow} if ($conf{tcp_allow});
$net_server{deny} = $conf{tcp_deny} if ($conf{tcp_deny});
$net_server{group} = $conf{run_group} if ($conf{run_group});
$net_server{log_file} = $conf{log_file} if ($conf{log_file});
$net_server{log_level} = $conf{log_level} if ($conf{log_level});
$net_server{pid_file} = $conf{pid_file} if ($conf{pid_file});
$net_server{port} = $conf{data_port} if ($conf{data_port});
$net_server{setsid} = $conf{run_setsid} if ($conf{run_setsid});
$net_server{syslog_facility} = $conf{syslog_facility}
    if ($conf{syslog_facility});
$net_server{syslog_ident} = $conf{syslog_ident} if ($conf{syslog_ident});
$net_server{syslog_logopt} = $conf{syslog_logopt} if ($conf{syslog_logopt});
$net_server{user} = $conf{run_user} if ($conf{run_user});

# set server type
if ($conf{run_fork_max} == 1) {
    $net_server{server_type} = 'Multiplex';
} elsif ($conf{run_fork_min} > 0 && $conf{run_fork_max} > $conf{run_fork_min}) {
    $net_server{min_servers} = $conf{run_fork_min};
    $net_server{max_servers} = $conf{run_fork_max};
    $net_server{server_type} = 'PreFork';
} elsif ($conf{run_fork_min} > 0) {
    $net_server{max_servers} = $conf{run_fork_min};
    $net_server{server_type} = 'PreForkSimple';
} else {
    $net_server{server_type} = 'Fork';
    $net_server{max_servers} = $conf{run_fork_max} if ($conf{run_fork_max} > 0);
}

# start server
Ballast->run(%net_server);

1;

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Crypt/CBC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CRYPT_CBC';
  package Crypt::CBC;use Digest::MD5 'md5';use Carp;use strict;use bytes;use vars qw($VERSION);$VERSION='2.33';use constant RANDOM_DEVICE=>'/dev/urandom';sub new {my$class=shift;my$options={};if (ref $_[0]eq 'HASH'){$options=shift}elsif ($_[0]=~ /^-[a-zA-Z_]{1,20}$/){my%tmp=@_;while (my($key,$value)=each%tmp){$key =~ s/^-//;$options->{lc$key}=$value}}else {$options->{key}=shift;$options->{cipher}=shift}my$cipher_object_provided=$options->{cipher}&& ref$options->{cipher};my$pass=$options->{key};if ($cipher_object_provided){carp "Both a key and a pre-initialized Crypt::* object were passed. The key will be ignored" if defined$pass;$pass ||=''}elsif (!defined$pass){croak "Please provide an encryption/decryption passphrase or key using -key"}my%valid_modes=map {$_=>1}qw(none salt randomiv);my$header_mode=$options->{header};$header_mode ||='none' if exists$options->{prepend_iv}&&!$options->{prepend_iv};$header_mode ||='none' if exists$options->{add_header}&&!$options->{add_header};$header_mode ||='salt';croak "Invalid -header mode '$header_mode'" unless$valid_modes{$header_mode};croak "The -salt argument is incompatible with a -header mode of $header_mode" if exists$options->{salt}&& $header_mode ne 'salt';my$cipher=$options->{cipher};$cipher='Crypt::DES' unless$cipher;my$cipherclass=ref$cipher || $cipher;unless (ref$cipher){$cipher=$cipher=~/^Crypt::/ ? $cipher : "Crypt::$cipher";$cipher->can('encrypt')or eval "require $cipher; 1" or croak "Couldn't load $cipher: $@";$cipher =~ s/^Crypt::// unless$cipher->can('keysize')}my$ks=$options->{keysize};my$bs=$options->{blocksize};$ks ||=eval {$cipher->keysize};$bs ||=eval {$cipher->blocksize};$ks ||=$cipherclass =~ /blowfish/i ? 56 : 8;$bs ||=$ks;my$pcbc=$options->{'pcbc'};croak "The options -literal_key and -regenerate_key are incompatible with each other" if exists$options->{literal_key}&& exists$options->{regenerate_key};my$key;$key=$pass if$options->{literal_key};$key=$pass if exists$options->{regenerate_key}&&!$options->{regenerate_key};my$salt=$options->{salt};my$random_salt=1 unless defined$salt && $salt ne '1';croak "Argument to -salt must be exactly 8 bytes long" if defined$salt && length$salt!=8 && $salt ne '1';my$iv=$options->{iv};my$random_iv=1 unless defined$iv;croak "Initialization vector must be exactly $bs bytes long when using the $cipherclass cipher" if defined$iv and length($iv)!=$bs;my$literal_key=$options->{literal_key}|| (exists$options->{regenerate_key}&&!$options->{regenerate_key});my$legacy_hack=$options->{insecure_legacy_decrypt};my$padding=$options->{padding}|| 'standard';if ($padding && ref($padding)eq 'CODE'){for my$i (1..$bs-1){my$rbs=length($padding->(" "x$i,$bs,'e'));croak "padding method callback does not behave properly: expected $bs bytes back, got $rbs bytes back." unless ($rbs==$bs)}}else {$padding=$padding eq 'none' ? \&_no_padding :$padding eq 'null' ? \&_null_padding :$padding eq 'space' ? \&_space_padding :$padding eq 'oneandzeroes' ? \&_oneandzeroes_padding :$padding eq 'rijndael_compat'? \&_rijndael_compat :$padding eq 'standard' ? \&_standard_padding :croak "'$padding' padding not supported.  See perldoc Crypt::CBC for instructions on creating your own."}if ($header_mode eq 'salt'){croak "Cannot use salt-based key generation if literal key is specified" if$options->{literal_key};croak "Cannot use salt-based IV generation if literal IV is specified" if exists$options->{iv}}elsif ($header_mode eq 'randomiv'){croak "Cannot encrypt using a non-8 byte blocksize cipher when using randomiv header mode" unless$bs==8 || $legacy_hack}elsif ($header_mode eq 'none'){croak "You must provide an initialization vector using -iv when using -header=>'none'" unless exists$options->{iv}}if (defined$key && length($key)!=$ks){croak "If specified by -literal_key, then the key length must be equal to the chosen cipher's key length of $ks bytes"}if (defined$iv && length($iv)!=$bs){croak "If specified by -iv, then the initialization vector length must be equal to the chosen cipher's blocksize of $bs bytes"}return bless {'cipher'=>$cipher,'passphrase'=>$pass,'key'=>$key,'iv'=>$iv,'salt'=>$salt,'padding'=>$padding,'blocksize'=>$bs,'keysize'=>$ks,'header_mode'=>$header_mode,'legacy_hack'=>$legacy_hack,'literal_key'=>$literal_key,'pcbc'=>$pcbc,'make_random_salt'=>$random_salt,'make_random_iv'=>$random_iv,},$class}sub encrypt (\$$) {my ($self,$data)=@_;$self->start('encrypting');my$result=$self->crypt($data);$result .= $self->finish;$result}sub decrypt (\$$){my ($self,$data)=@_;$self->start('decrypting');my$result=$self->crypt($data);$result .= $self->finish;$result}sub encrypt_hex (\$$) {my ($self,$data)=@_;return join('',unpack 'H*',$self->encrypt($data))}sub decrypt_hex (\$$) {my ($self,$data)=@_;return$self->decrypt(pack'H*',$data)}sub start (\$$) {my$self=shift;my$operation=shift;croak "Specify <e>ncryption or <d>ecryption" unless$operation=~/^[ed]/i;$self->{'buffer'}='';$self->{'decrypt'}=$operation=~/^d/i}sub crypt (\$$){my$self=shift;my$data=shift;my$result;croak "crypt() called without a preceding start()" unless exists$self->{'buffer'};my$d=$self->{'decrypt'};unless ($self->{civ}){$result=$self->_generate_iv_and_cipher_from_datastream(\$data)if$d;$result=$self->_generate_iv_and_cipher_from_options()unless$d}my$iv=$self->{'civ'};$self->{'buffer'}.= $data;my$bs=$self->{'blocksize'};croak "When using no padding, plaintext size must be a multiple of $bs" if$self->{'padding'}eq \&_no_padding and length($data)% $bs;croak "When using rijndael_compat padding, plaintext size must be a multiple of $bs" if$self->{'padding'}eq \&_rijndael_compat and length($data)% $bs;return$result unless (length($self->{'buffer'})>= $bs);my@blocks=unpack("a$bs "x(int(length($self->{'buffer'})/$bs))."a*",$self->{'buffer'});$self->{'buffer'}='';if ($d){$self->{'buffer'}=length($blocks[-1])< $bs ? join '',splice(@blocks,-2): pop(@blocks)}else {$self->{'buffer'}=pop@blocks if length($blocks[-1])< $bs}for my$block (@blocks){if ($d){$result .= $iv=$iv ^ $self->{'crypt'}->decrypt($block);$iv=$block unless$self->{pcbc}}else {$result .= $iv=$self->{'crypt'}->encrypt($iv ^ $block)}$iv=$iv ^ $block if$self->{pcbc}}$self->{'civ'}=$iv;return$result}sub finish (\$) {my$self=shift;my$bs=$self->{'blocksize'};my$block=defined$self->{'buffer'}? $self->{'buffer'}: '';$self->{civ}||='';my$result;if ($self->{'decrypt'}){$block=length$block ? pack("a$bs",$block): '';if (length($block)){$result=$self->{'civ'}^ $self->{'crypt'}->decrypt($block);$result=$self->{'padding'}->($result,$bs,'d')}else {$result=''}}else {$block=$self->{'padding'}->($block,$bs,'e')|| '';$result=length$block ? $self->{'crypt'}->encrypt($self->{'civ'}^ $block): ''}delete$self->{'civ'};delete$self->{'buffer'};return$result}sub _generate_iv_and_cipher_from_datastream {my$self=shift;my$input_stream=shift;my$bs=$self->blocksize;my$header_mode=$self->header_mode;if ($header_mode eq 'none'){croak "You must specify a $bs byte initialization vector by passing the -iv option to new() when using -header_mode=>'none'" unless exists$self->{iv};$self->{civ}=$self->{iv};$self->{key}||=$self->_key_from_key($self->{passphrase})}elsif ($header_mode eq 'salt'){my ($salt)=$$input_stream =~ /^Salted__(.{8})/s;croak "Ciphertext does not begin with a valid header for 'salt' header mode" unless defined$salt;$self->{salt}=$salt;substr($$input_stream,0,16)='';my ($key,$iv)=$self->_salted_key_and_iv($self->{passphrase},$salt);$self->{iv}=$self->{civ}=$iv;$self->{key}=$key}elsif ($header_mode eq 'randomiv'){my ($iv)=$$input_stream =~ /^RandomIV(.{8})/s;croak "Ciphertext does not begin with a valid header for 'randomiv' header mode" unless defined$iv;croak "randomiv header mode cannot be used securely when decrypting with a >8 byte block cipher.\nUse the -insecure_legacy_decrypt flag if you are sure you want to do this" unless$self->blocksize==8 || $self->legacy_hack;$self->{iv}=$self->{civ}=$iv;$self->{key}=$self->_key_from_key($self->{passphrase});undef$self->{salt};substr($$input_stream,0,16)=''}else {croak "Invalid header mode '$header_mode'"}croak "Cipher stream did not contain IV or salt, and you did not specify these values in new()" unless$self->{key}&& $self->{civ};$self->{crypt}=ref$self->{cipher}? $self->{cipher}: $self->{cipher}->new($self->{key})or croak "Could not create $self->{cipher} object: $@";return ''}sub _generate_iv_and_cipher_from_options {my$self=shift;my$blocksize=$self->blocksize;my$result='';my$header_mode=$self->header_mode;if ($header_mode eq 'none'){croak "You must specify a $blocksize byte initialization vector by passing the -iv option to new() when using -header_mode=>'none'" unless exists$self->{iv};$self->{civ}=$self->{iv};$self->{key}||=$self->_key_from_key($self->{passphrase})}elsif ($header_mode eq 'salt'){$self->{salt}=$self->_get_random_bytes(8)if$self->{make_random_salt};defined (my$salt=$self->{salt})or croak "No header_mode of 'salt' specified, but no salt value provided";length($salt)==8 or croak "Salt must be exactly 8 bytes long";my ($key,$iv)=$self->_salted_key_and_iv($self->{passphrase},$salt);$self->{key}=$key;$self->{civ}=$self->{iv}=$iv;$result="Salted__${salt}"}elsif ($header_mode eq 'randomiv'){croak "randomiv header mode cannot be used when encrypting with a >8 byte block cipher. There is no option to allow this" unless$blocksize==8;$self->{key}||=$self->_key_from_key($self->{passphrase});$self->{iv}=$self->_get_random_bytes(8)if$self->{make_random_iv};length($self->{iv})==8 or croak "IV must be exactly 8 bytes long when used with header mode of 'randomiv'";$self->{civ}=$self->{iv};$result="RandomIV$self->{iv}"}croak "key and/or iv are missing" unless defined$self->{key}&& defined$self->{civ};$self->_taintcheck($self->{key});$self->{crypt}=ref$self->{cipher}? $self->{cipher}: $self->{cipher}->new($self->{key})or croak "Could not create $self->{cipher} object: $@";return$result}sub _taintcheck {my$self=shift;my$key=shift;return unless ${^TAINT};my$has_scalar_util=eval "require Scalar::Util; 1";my$tainted;if ($has_scalar_util){$tainted=Scalar::Util::tainted($key)}else {local($@,$SIG{__DIE__},$SIG{__WARN__});local $^W=0;eval {kill 0 * $key};$tainted=$@ =~ /^Insecure/}croak "Taint checks are turned on and your key is tainted. Please untaint the key and try again" if$tainted}sub _key_from_key {my$self=shift;my$pass=shift;my$ks=$self->{keysize};return$pass if$self->{literal_key};my$material=md5($pass);while (length($material)< $ks){$material .= md5($material)}return substr($material,0,$ks)}sub _salted_key_and_iv {my$self=shift;my ($pass,$salt)=@_;croak "Salt must be 8 bytes long" unless length$salt==8;my$key_len=$self->{keysize};my$iv_len=$self->{blocksize};my$desired_len=$key_len+$iv_len;my$data='';my$d='';while (length$data < $desired_len){$d=md5($d .$pass .$salt);$data .= $d}return (substr($data,0,$key_len),substr($data,$key_len,$iv_len))}sub random_bytes {my$self=shift;my$bytes=shift or croak "usage: random_bytes(\$byte_length)";$self->_get_random_bytes($bytes)}sub _get_random_bytes {my$self=shift;my$length=shift;my$result;if (-r RANDOM_DEVICE && open(F,RANDOM_DEVICE)){read(F,$result,$length);close F}else {$result=pack("C*",map {rand(256)}1..$length)}$result =~ /^(.+)$/s;length($1)==$length or croak "Invalid length while gathering $length random bytes";return $1}sub _standard_padding ($$$) {my ($b,$bs,$decrypt)=@_;$b=length$b ? $b : '';if ($decrypt eq 'd'){my$pad_length=unpack("C",substr($b,-1));return$b unless$pad_length >= 0 && $pad_length <= $bs;my@pad_chars=unpack("C*",substr($b,-$pad_length));return$b if grep {$pad_length!=$_}@pad_chars;return substr($b,0,$bs-$pad_length)}my$pad=$bs - length($b)% $bs;return$b .pack("C*",($pad)x$pad)}sub _space_padding ($$$) {my ($b,$bs,$decrypt)=@_;return unless length$b;$b=length$b ? $b : '';if ($decrypt eq 'd'){$b=~ s/ *\z//s;return$b}return$b .pack("C*",(32)x ($bs - length($b)% $bs))}sub _no_padding ($$$) {my ($b,$bs,$decrypt)=@_;return$b}sub _null_padding ($$$) {my ($b,$bs,$decrypt)=@_;return unless length$b;$b=length$b ? $b : '';if ($decrypt eq 'd'){$b=~ s/\0*\z//s;return$b}return$b .pack("C*",(0)x ($bs - length($b)% $bs))}sub _oneandzeroes_padding ($$$) {my ($b,$bs,$decrypt)=@_;$b=length$b ? $b : '';if ($decrypt eq 'd'){$b=~ s/\x80\0*\z//s;return$b}return$b .pack("C*",128,(0)x ($bs - length($b)% $bs - 1))}sub _rijndael_compat ($$$) {my ($b,$bs,$decrypt)=@_;return unless length$b;if ($decrypt eq 'd'){$b=~ s/\x80\0*\z//s;return$b}return$b .pack("C*",128,(0)x ($bs - length($b)% $bs - 1))}sub get_initialization_vector (\$) {my$self=shift;$self->iv()}sub set_initialization_vector (\$$) {my$self=shift;my$iv=shift;my$bs=$self->blocksize;croak "Initialization vector must be $bs bytes in length" unless length($iv)==$bs;$self->iv($iv)}sub salt {my$self=shift;my$d=$self->{salt};$self->{salt}=shift if @_;$d}sub iv {my$self=shift;my$d=$self->{iv};$self->{iv}=shift if @_;$d}sub key {my$self=shift;my$d=$self->{key};$self->{key}=shift if @_;$d}sub passphrase {my$self=shift;my$d=$self->{passphrase};if (@_){undef$self->{key};undef$self->{iv};$self->{passphrase}=shift}$d}sub cipher {shift->{cipher}}sub padding {shift->{padding}}sub keysize {shift->{keysize}}sub blocksize {shift->{blocksize}}sub pcbc {shift->{pcbc}}sub header_mode {shift->{header_mode}}sub legacy_hack {shift->{legacy_hack}}1;
CRYPT_CBC

$fatpacked{"Crypt/XXTEA_PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CRYPT_XXTEA_PP';
  package Crypt::XXTEA_PP;use strict;use warnings;use utf8;use integer;use Carp;our$VERSION='0.0102';use Config;BEGIN {if (not defined$Config{use64bitint}){require bigint;bigint->import}}my$DELTA=0x9e3779b9;my$FACTOR=4;my$KEY_SIZE=16;my$ELEMENTS_IN_KEY=$KEY_SIZE / $FACTOR;my$MIN_BLOCK_SIZE=8;my$MIN_ELEMENTS_IN_BLOCK=$MIN_BLOCK_SIZE / $FACTOR;use constant keysize=>$KEY_SIZE;use constant blocksize=>$MIN_BLOCK_SIZE;sub isint {local $_=shift;return 0 unless defined;return 1 if /\A\s*[+-]?(?:0|[1-9][0-9]*)\s*\z/s;0}sub all (&@) {my$f=shift;$f->()or return 0 foreach @_;return 1}sub new {my$class=shift;my$key=shift;my$xxtea_key;croak('key is required')if not defined$key;if (my$ref_of_key=ref($key)){croak(sprintf('key must be a %d-byte-long STRING or a reference of ARRAY',$KEY_SIZE))if not $ref_of_key eq 'ARRAY';croak(sprintf('key must has %d elements if key is a reference of ARRAY',$ELEMENTS_IN_KEY))if scalar(@{$key})!=$ELEMENTS_IN_KEY;croak('each element of key must be a 32bit Integer if key is a reference of ARRAY')if not all {isint($_)!=0}@{$key};$xxtea_key=$key}else {croak(sprintf('key must be a %d-byte-long STRING or a reference of ARRAY',$KEY_SIZE))if length$key!=$KEY_SIZE;$xxtea_key=key_setup($key)}my$self={key=>$xxtea_key,};bless$self,ref($class)|| $class}sub encrypt {my$self=shift;my$plain_text=shift;croak(sprintf('plain_text size must be at least %d bytes',$MIN_BLOCK_SIZE))if length($plain_text)< $MIN_BLOCK_SIZE;croak(sprintf('plain_text size must be a multiple of %d bytes',$FACTOR))if length($plain_text)% $FACTOR!=0;my@block=unpack 'N*',$plain_text;my$cipher_text_ref=$self->encrypt_block(\@block);return pack('N*',@{$cipher_text_ref})}sub decrypt {my$self=shift;my$cipher_text=shift;croak(sprintf('cipher_text size must be at least %d bytes',$MIN_BLOCK_SIZE))if length($cipher_text)< $MIN_BLOCK_SIZE;croak(sprintf('cipher_text size must be a multiple of %d bytes',$FACTOR))if length($cipher_text)% $FACTOR!=0;my@block=unpack 'N*',$cipher_text;my$plain_text_ref=$self->decrypt_block(\@block);return pack('N*',@{$plain_text_ref})}sub encrypt_block {my$self=shift;my$block_ref=shift;my$key_ref=$self->{key};croak(sprintf('block must has at least %d elements',$MIN_ELEMENTS_IN_BLOCK))if scalar(@{$block_ref})< $MIN_ELEMENTS_IN_BLOCK;croak(sprintf('key must has %d elements',$ELEMENTS_IN_KEY))if scalar(@{$key_ref})!=$ELEMENTS_IN_KEY;my@block=map {$_ & 0xffff_ffff}@{$block_ref};my@key=map {$_ & 0xffff_ffff}@{$key_ref};my$delta=$DELTA & 0xffff_ffff;my$rounds=6 + 52 / (scalar@block);my$sum=0 & 0xffff_ffff;my$z=$block[-1];my ($e,$p,$y);for (0 .. $rounds-1){$sum=($sum + $delta)& 0xffff_ffff;$e=($sum >> 2)& 3;for (0 .. $#block-1){$p=$_;$y=$block[$p + 1 ];$z=$block[$p ]=($block[$p ]+ _MX($y,$z,$sum,$p,$e,\@key))& 0xffff_ffff}$p += 1;$y=$block[0];$z=$block[-1]=($block[-1]+ _MX($y,$z,$sum,$p,$e,\@key))& 0xffff_ffff}return \@block}sub decrypt_block {my$self=shift;my$block_ref=shift;my$key_ref=$self->{key};croak(sprintf('block must has at least %d elements',$MIN_ELEMENTS_IN_BLOCK))if scalar(@{$block_ref})< $MIN_ELEMENTS_IN_BLOCK;croak(sprintf('key must has %d elements',$ELEMENTS_IN_KEY))if scalar(@{$key_ref})!=$ELEMENTS_IN_KEY;my@block=map {$_ & 0xffff_ffff}@{$block_ref};my@key=map {$_ & 0xffff_ffff}@{$key_ref};my$delta=$DELTA & 0xffff_ffff;my$rounds=6 + 52 / (scalar@block);my$sum=($rounds * $delta)& 0xffff_ffff;my$y=$block[0];my ($e,$p,$z);for (0 .. $rounds-1){$e=($sum >> 2)& 3;for (reverse 1 .. $#block){$p=$_;$z=$block[$p - 1 ];$y=$block[$p ]=($block[$p ]- _MX($y,$z,$sum,$p,$e,\@key))& 0xffff_ffff}$p -= 1;$z=$block[-1];$y=$block[0]=($block[0]- _MX($y,$z,$sum,$p,$e,\@key))& 0xffff_ffff;$sum=($sum - $delta)& 0xffff_ffff}return \@block}sub _MX {my ($y,$z,$sum,$p,$e,$key)=@_;return ((((((($z >> 5)& 0xffff_ffff)^ (($y << 2)& 0xffff_ffff))& 0xffff_ffff)+ (((($y >> 3)& 0xffff_ffff)^ (($z << 4)& 0xffff_ffff))& 0xffff_ffff))& 0xffff_ffff)^ (((($sum ^ $y)& 0xffff_ffff)+ (($key->[($p & 3)^ $e ]^ $z)& 0xffff_ffff))& 0xffff_ffff))& 0xffff_ffff}sub key_setup {my$key_str=shift;croak(sprintf('key must be %s bytes long',$KEY_SIZE))if length($key_str)!=$KEY_SIZE;my@xxtea_key=unpack 'N*',$key_str;return \@xxtea_key}1;
CRYPT_XXTEA_PP

$fatpacked{"Date/Parse.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATE_PARSE';
  package Date::Parse;require 5.000;use strict;use vars qw($VERSION @ISA @EXPORT);use Time::Local;use Carp;use Time::Zone;use Exporter;@ISA=qw(Exporter);@EXPORT=qw(&strtotime &str2time &strptime);$VERSION="2.30";my%month=(january=>0,february=>1,march=>2,april=>3,may=>4,june=>5,july=>6,august=>7,september=>8,sept=>8,october=>9,november=>10,december=>11,);my%day=(sunday=>0,monday=>1,tuesday=>2,tues=>2,wednesday=>3,wednes=>3,thursday=>4,thur=>4,thurs=>4,friday=>5,saturday=>6,);my@suf=(qw(th st nd rd th th th th th th))x 3;@suf[11,12,13]=qw(th th th);map {$month{substr($_,0,3)}=$month{$_}}keys%month;map {$day{substr($_,0,3)}=$day{$_}}keys%day;my$strptime=<<'ESQ';use vars qw($day_ref $mon_ref $suf_ref $obj);sub gen_parser {local($day_ref,$mon_ref,$suf_ref,$obj)=@_;if($obj){my$obj_strptime=$strptime;substr($obj_strptime,index($strptime,"sub")+6,0)=<<'ESQ';my$sub=eval "$obj_strptime" or die $@;return$sub}eval "$strptime" or die $@}*strptime=gen_parser(\%day,\%month,\@suf);sub str2time {my@t=strptime(@_);return undef unless@t;my($ss,$mm,$hh,$day,$month,$year,$zone)=@t;my@lt=localtime(time);$hh ||=0;$mm ||=0;$ss ||=0;my$frac=$ss - int($ss);$ss=int$ss;$month=$lt[4]unless(defined$month);$day=$lt[3]unless(defined$day);$year=($month > $lt[4])? ($lt[5]- 1): $lt[5]unless(defined$year);return undef unless($month <= 11 && $day >= 1 && $day <= 31 && $hh <= 23 && $mm <= 59 && $ss <= 59);my$result;if (defined$zone){$result=eval {local$SIG{__DIE__}=sub {};timegm($ss,$mm,$hh,$day,$month,$year)};return undef if!defined$result or $result==-1 && join("",$ss,$mm,$hh,$day,$month,$year)ne "595923311169";$result -= $zone}else {$result=eval {local$SIG{__DIE__}=sub {};timelocal($ss,$mm,$hh,$day,$month,$year)};return undef if!defined$result or $result==-1 && join("",$ss,$mm,$hh,$day,$month,$year)ne join("",(localtime(-1))[0..5])}return$result + $frac}1;
   my %month = map { lc $_ } %$mon_ref;
   my $daypat = join("|", map { lc $_ } reverse sort keys %$day_ref);
   my $monpat = join("|", reverse sort keys %month);
   my $sufpat = join("|", reverse sort map { lc $_ } @$suf_ref);
  
   my %ampm = (
  	'a' => 0,  # AM
  	'p' => 12, # PM
  	);
  
   my($AM, $PM) = (0,12);
  
  sub {
  
    my $dtstr = lc shift;
    my $merid = 24;
  
    my($year,$month,$day,$hh,$mm,$ss,$zone,$dst,$frac);
  
    $zone = tz_offset(shift) if @_;
  
    1 while $dtstr =~ s#\([^\(\)]*\)# #o;
  
    $dtstr =~ s#(\A|\n|\Z)# #sog;
  
    # ignore day names
    $dtstr =~ s#([\d\w\s])[\.\,]\s#$1 #sog;
    $dtstr =~ s/,/ /g;
    $dtstr =~ s#($daypat)\s*(den\s)?\b# #o;
    # Time: 12:00 or 12:00:00 with optional am/pm
  
    return unless $dtstr =~ /\S/;
    
    if ($dtstr =~ s/\s(\d{4})([-:]?)(\d\d?)\2(\d\d?)(?:[-Tt ](\d\d?)(?:([-:]?)(\d\d?)(?:\6(\d\d?)(?:[.,](\d+))?)?)?)?(?=\D)/ /) {
      ($year,$month,$day,$hh,$mm,$ss,$frac) = ($1,$3-1,$4,$5,$7,$8,$9);
    }
  
    unless (defined $hh) {
      if ($dtstr =~ s#[:\s](\d\d?):(\d\d?)(:(\d\d?)(?:\.\d+)?)?(z)?\s*(?:([ap])\.?m?\.?)?\s# #o) {
        ($hh,$mm,$ss) = ($1,$2,$4);
        $zone = 0 if $5;
        $merid = $ampm{$6} if $6;
      }
  
      # Time: 12 am
      
      elsif ($dtstr =~ s#\s(\d\d?)\s*([ap])\.?m?\.?\s# #o) {
        ($hh,$mm,$ss) = ($1,0,0);
        $merid = $ampm{$2};
      }
    }
      
    if (defined $hh and $hh <= 12 and $dtstr =~ s# ([ap])\.?m?\.?\s# #o) {
      $merid = $ampm{$1};
    }
  
  
    unless (defined $year) {
      # Date: 12-June-96 (using - . or /)
      
      if ($dtstr =~ s#\s(\d\d?)([\-\./])($monpat)(\2(\d\d+))?\s# #o) {
        ($month,$day) = ($month{$3},$1);
        $year = $5 if $5;
      }
      
      # Date: 12-12-96 (using '-', '.' or '/' )
      
      elsif ($dtstr =~ s#\s(\d+)([\-\./])(\d\d?)(\2(\d+))?\s# #o) {
        ($month,$day) = ($1 - 1,$3);
  
        if ($5) {
  	$year = $5;
  	# Possible match for 1995-01-24 (short mainframe date format);
  	($year,$month,$day) = ($1, $3 - 1, $5) if $month > 12;
  	return if length($year) > 2 and $year < 1901;
        }
      }
      elsif ($dtstr =~ s#\s(\d+)\s*($sufpat)?\s*($monpat)# #o) {
        ($month,$day) = ($month{$3},$1);
      }
      elsif ($dtstr =~ s#($monpat)\s*(\d+)\s*($sufpat)?\s# #o) {
        ($month,$day) = ($month{$1},$2);
      }
      elsif ($dtstr =~ s#($monpat)([\/-])(\d+)[\/-]# #o) {
        ($month,$day) = ($month{$1},$3);
      }
  
      # Date: 961212
  
      elsif ($dtstr =~ s#\s(\d\d)(\d\d)(\d\d)\s# #o) {
        ($year,$month,$day) = ($1,$2-1,$3);
      }
  
      $year = $1 if !defined($year) and $dtstr =~ s#\s(\d{2}(\d{2})?)[\s\.,]# #o;
  
    }
  
    # Zone
  
    $dst = 1 if $dtstr =~ s#\bdst\b##o;
  
    if ($dtstr =~ s#\s"?([a-z]{3,4})(dst|\d+[a-z]*|_[a-z]+)?"?\s# #o) {
      $dst = 1 if $2 and $2 eq 'dst';
      $zone = tz_offset($1);
      return unless defined $zone;
    }
    elsif ($dtstr =~ s#\s([a-z]{3,4})?([\-\+]?)-?(\d\d?):?(\d\d)?(00)?\s# #o) {
      my $m = defined($4) ? "$2$4" : 0;
      my $h = "$2$3";
      $zone = defined($1) ? tz_offset($1) : 0;
      return unless defined $zone;
      $zone += 60 * ($m + (60 * $h));
    }
  
    if ($dtstr =~ /\S/) {
      # now for some dumb dates
      if ($dtstr =~ s/^\s*(ut?|z)\s*$//) {
        $zone = 0;
      }
      elsif ($dtstr =~ s#\s([a-z]{3,4})?([\-\+]?)-?(\d\d?)(\d\d)?(00)?\s# #o) {
        my $m = defined($4) ? "$2$4" : 0;
        my $h = "$2$3";
        $zone = defined($1) ? tz_offset($1) : 0;
        return unless defined $zone;
        $zone += 60 * ($m + (60 * $h));
      }
  
      return if $dtstr =~ /\S/o;
    }
  
    if (defined $hh) {
      if ($hh == 12) {
        $hh = 0 if $merid == $AM;
      }
      elsif ($merid == $PM) {
        $hh += 12;
      }
    }
  
    $year -= 1900 if defined $year && $year > 1900;
  
    $zone += 3600 if defined $zone && $dst;
    $ss += "0.$frac" if $frac;
  
    return ($ss,$mm,$hh,$day,$month,$year,$zone);
  }
  ESQ
   shift; # package
  ESQ
DATE_PARSE

$fatpacked{"IO/Multiplex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_MULTIPLEX';
  package IO::Multiplex;use strict;use warnings;our$VERSION='1.16';use POSIX qw(errno_h BUFSIZ);use Socket;use FileHandle qw(autoflush);use IO::Handle;use Fcntl;use Carp qw(carp);use constant IsWin=>($^O eq 'MSWin32');BEGIN {eval {require Time::HiRes;Time::HiRes->import('time')}}$SIG{PIPE}='IGNORE';{no warnings;if(IsWin){*EWOULDBLOCK=sub() {10035}}}sub new {my$package=shift;my$self=bless {_readers=>'',_writers=>'',_fhs=>{},_handles=>{},_timerkeys=>{},_timers=>[],_listen=>{}}=>$package;return$self}sub listen {my$self=shift;my$fh=shift;$self->add($fh);$self->{_fhs}{"$fh"}{listen}=1;$fh}sub add {my$self=shift;my$fh=shift;return if$self->{_fhs}{"$fh"};nonblock($fh);autoflush($fh,1);fd_set($self->{_readers},$fh,1);my$sockopt=getsockopt$fh,SOL_SOCKET,SO_TYPE;$self->{_fhs}{"$fh"}{udp_true}=1 if defined$sockopt && SOCK_DGRAM==unpack "i",$sockopt;$self->{_fhs}{"$fh"}{inbuffer}='';$self->{_fhs}{"$fh"}{outbuffer}='';$self->{_fhs}{"$fh"}{fileno}=fileno($fh);$self->{_handles}{"$fh"}=$fh;tie *$fh,"IO::Multiplex::Handle",$self,$fh;return$fh}sub remove {my$self=shift;my$fh=shift;fd_set($self->{_writers},$fh,0);fd_set($self->{_readers},$fh,0);delete$self->{_fhs}{"$fh"};delete$self->{_handles}{"$fh"};$self->_removeTimer($fh);untie *$fh;return 1}sub set_callback_object {my$self=shift;my$obj=shift;my$fh=shift;return if$fh &&!exists($self->{_fhs}{"$fh"});my$old=$fh ? $self->{_fhs}{"$fh"}{object}: $self->{_object};$fh ? $self->{_fhs}{"$fh"}{object}: $self->{_object}=$obj;return$old}sub kill_output {my$self=shift;my$fh=shift;return unless$fh && exists($self->{_fhs}{"$fh"});$self->{_fhs}{"$fh"}{outbuffer}='';fd_set($self->{_writers},$fh,0)}sub outbuffer {my$self=shift;my$fh=shift;return unless$fh && exists($self->{_fhs}{"$fh"});if (@_){$self->{_fhs}{"$fh"}{outbuffer}=$_[0]if @_;fd_set($self->{_writers},$fh,0)if!$_[0]}$self->{_fhs}{"$fh"}{outbuffer}}sub inbuffer {my$self=shift;my$fh=shift;return unless$fh && exists($self->{_fhs}{"$fh"});if (@_){$self->{_fhs}{"$fh"}{inbuffer}=$_[0]if @_}return$self->{_fhs}{"$fh"}{inbuffer}}sub set_timeout {my$self=shift;my$fh=shift;my$timeout=shift;return unless$fh && exists($self->{_fhs}{"$fh"});if (defined$timeout){$self->_addTimer($fh,$timeout + time)}else {$self->_removeTimer($fh)}}sub handles {my$self=shift;return grep(!$self->{_fhs}{"$_"}{listen},values %{$self->{_handles}})}sub _addTimer {my$self=shift;my$fh=shift;my$time=shift;$self->{_timerkeys}{"$fh"}=1;@{$self->{_timers}}=sort {$a->[1]<=> $b->[1]}(@{$self->{_timers}},[$fh,$time ])}sub _removeTimer {my$self=shift;my$fh=shift;return unless exists$self->{_timerkeys}{"$fh"};@{$self->{_timers}}=grep {$_->[0]ne $fh}@{$self->{_timers}};delete$self->{_timerkeys}{"$fh"}}sub loop {my$self=shift;my$heartbeat=shift;$self->{_endloop}=0;while (!$self->{_endloop}&& keys %{$self->{_fhs}}){my$rv;my$data;my$rdready="";my$wrready="";my$timeout=undef;for my$fh (values %{$self->{_handles}}){fd_set($rdready,$fh,1)if ref($fh)=~ /SSL/ && $fh->can("pending")&& $fh->pending}if (!length$rdready){if (@{$self->{_timers}}){$timeout=$self->{_timers}[0][1]- time}my$numready=select($rdready=$self->{_readers},$wrready=$self->{_writers},undef,$timeout);unless(defined($numready)){if ($!==EINTR || $!==EAGAIN){next}else {last}}}&{$heartbeat}($rdready,$wrready)if$heartbeat;for my$k (keys %{$self->{_handles}}){my$fh=$self->{_handles}->{$k}or next;next unless exists$self->{_fhs}{"$fh"};my$obj=$self->{_fhs}{"$fh"}{object}|| $self->{_object};if (fd_isset($rdready,$fh)){if ($self->{_fhs}{"$fh"}{listen}){my$client=$fh->accept;next unless ($client);$self->add($client);$obj->mux_connection($self,$client)if$obj && $obj->can("mux_connection")}else {if ($self->is_udp($fh)){$rv=recv($fh,$data,BUFSIZ,0);if (defined$rv){$self->{_fhs}{"$fh"}{udp_peer}=$rv}}else {$rv=&POSIX::read(fileno($fh),$data,BUFSIZ)}if (defined($rv)&& length($data)){$self->{_fhs}{"$fh"}{inbuffer}.= $data;$obj->mux_input($self,$fh,\$self->{_fhs}{"$fh"}{inbuffer})if$obj && $obj->can("mux_input")}else {unless (defined$rv){next if $!==EINTR || $!==EAGAIN || $!==EWOULDBLOCK;warn "IO::Multiplex read error: $!" if $!!=ECONNRESET}fd_set($self->{_readers},$fh,0);$obj->mux_eof($self,$fh,\$self->{_fhs}{"$fh"}{inbuffer})if$obj && $obj->can("mux_eof");if (exists$self->{_fhs}{"$fh"}){$self->{_fhs}{"$fh"}{inbuffer}='';$self->close($fh)unless exists$self->{_fhs}{"$fh"}&& length$self->{_fhs}{"$fh"}{outbuffer}}next}}}next unless exists$self->{_fhs}{"$fh"};if (fd_isset($wrready,$fh)){unless (length$self->{_fhs}{"$fh"}{outbuffer}){fd_set($self->{_writers},$fh,0);$obj->mux_outbuffer_empty($self,$fh)if ($obj && $obj->can("mux_outbuffer_empty"));next}$rv=&POSIX::write(fileno($fh),$self->{_fhs}{"$fh"}{outbuffer},length($self->{_fhs}{"$fh"}{outbuffer}));unless (defined($rv)){unless ($!==EWOULDBLOCK || $!==EINTR || $!==EAGAIN){if ($!==EPIPE){$obj->mux_epipe($self,$fh)if$obj && $obj->can("mux_epipe")}else {warn "IO::Multiplex: write error: $!\n"}$self->close($fh)}next}substr($self->{_fhs}{"$fh"}{outbuffer},0,$rv)='';unless (length$self->{_fhs}{"$fh"}{outbuffer}){fd_set($self->{_writers},$fh,0);$obj->mux_outbuffer_empty($self,$fh)if ($obj && $obj->can("mux_outbuffer_empty"));if ($self->{_fhs}{"$fh"}&& $self->{_fhs}{"$fh"}{shutdown}){shutdown($fh,1);$self->{_fhs}{"$fh"}{outbuffer}='';unless (length$self->{_fhs}{"$fh"}{inbuffer}){$self->close($fh);next}}}}next unless exists$self->{_fhs}{"$fh"}}$self->_checkTimeouts()if @{$self->{_timers}}}}sub _checkTimeouts {my$self=shift;my$time=time;my@timers=();for my$timer (@{$self->{_timers}}){last if$timer->[1]> $time;push@timers,$timer}for my$timer (@timers){my$fh=$timer->[0];$self->_removeTimer($fh);next unless exists$self->{_fhs}{"$fh"};my$obj=$self->{_fhs}{"$fh"}{object}|| $self->{_object};$obj->mux_timeout($self,$fh)if$obj && $obj->can("mux_timeout")}}sub endloop {my$self=shift;$self->{_endloop}=1}sub udp_peer {my$self=shift;my$fh=shift;return$self->{_fhs}{"$fh"}{udp_peer}}sub is_udp {my$self=shift;my$fh=shift;return$self->{_fhs}{"$fh"}{udp_true}}sub write {my$self=shift;my$fh=shift;my$data=shift;return unless$fh && exists($self->{_fhs}{"$fh"});if ($self->{_fhs}{"$fh"}{shutdown}){$!=EPIPE;return undef}if ($self->is_udp($fh)){if (my$udp_peer=$self->udp_peer($fh)){return send($fh,$data,0,$udp_peer)}else {return send($fh,$data,0)}}$self->{_fhs}{"$fh"}{outbuffer}.= $data;fd_set($self->{_writers},$fh,1);return length($data)}sub shutdown {my$self=shift;my$fh=shift;my$which=shift;return unless$fh && exists($self->{_fhs}{"$fh"});if ($which==0 || $which==2){shutdown($fh,0)}if ($which==1 || $which==2){if(length$self->{_fhs}{"$fh"}{outbuffer}){$self->{_fhs}{"$fh"}{shutdown}=1}else {shutdown($fh,1);$self->{_fhs}{"$fh"}{outbuffer}=''}}unless (length$self->{_fhs}{"$fh"}{inbuffer}|| length$self->{_fhs}{"$fh"}{outbuffer}){$self->close($fh)}}sub close {my$self=shift;my$fh=shift;return unless exists$self->{_fhs}{"$fh"};my$obj=$self->{_fhs}{"$fh"}{object}|| $self->{_object};warn "closing with read buffer" if length$self->{_fhs}{"$fh"}{inbuffer};warn "closing with write buffer" if length$self->{_fhs}{"$fh"}{outbuffer};fd_set($self->{_readers},$fh,0);fd_set($self->{_writers},$fh,0);delete$self->{_fhs}{"$fh"};delete$self->{_handles}{"$fh"};untie *$fh;close$fh;$obj->mux_close($self,$fh)if$obj && $obj->can("mux_close")}sub nonblock {my$fh=shift;if(IsWin){ioctl($fh,0x8004667e,pack("L!",1))}else {my$flags=fcntl($fh,F_GETFL,0)or die "fcntl F_GETFL: $!\n";fcntl($fh,F_SETFL,$flags | O_NONBLOCK)or die "fcntl F_SETFL $!\n"}}sub fd_set {vec($_[0],fileno($_[1]),1)=$_[2]}sub fd_isset {return vec($_[0],fileno($_[1]),1)}package IO::Multiplex::Handle;use strict;use Tie::Handle;use Carp;use vars qw(@ISA);@ISA=qw(Tie::Handle);sub FILENO {my$self=shift;return ($self->{_mux}->{_fhs}->{"$self->{_fh}"}->{fileno})}sub TIEHANDLE {my$package=shift;my$mux=shift;my$fh=shift;my$self=bless {_mux=>$mux,_fh=>$fh }=>$package;return$self}sub WRITE {my$self=shift;my ($msg,$len,$offset)=@_;$offset ||=0;return$self->{_mux}->write($self->{_fh},substr($msg,$offset,$len))}sub CLOSE {my$self=shift;return$self->{_mux}->shutdown($self->{_fh},2)}sub READ {carp "Do not read from a muxed file handle"}sub READLINE {carp "Do not read from a muxed file handle"}sub FETCH {return "Fnord"}sub UNTIE {}1;
IO_MULTIPLEX

$fatpacked{"MLDBM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MLDBM';
  require 5.005;use strict;package MLDBM::Serializer;$MLDBM::Serializer::VERSION=$MLDBM::Serializer::VERSION='2.05';use Carp;sub new {bless {},shift};sub serialize {confess "deferred"};sub deserialize {confess "deferred"};sub DumpMeth {my$s=shift;confess "can't set dumpmeth with " .ref($s)if @_;$s->_attrib('dumpmeth')}sub RemoveTaint {my$s=shift;confess "can't set untaint with " .ref($s)if @_;$s->_attrib('removetaint')}sub Key {my$s=shift;confess "can't set key with " .ref($s)if @_;$s->_attrib('key')}sub _attrib {my ($s,$a,$v)=@_;if (ref$s and @_ > 2){$s->{$a}=$v;return$s}$s->{$a}}package MLDBM;$MLDBM::VERSION=$MLDBM::VERSION='2.05';require Tie::Hash;@MLDBM::ISA='Tie::Hash';use Carp;$MLDBM::UseDB="SDBM_File" unless$MLDBM::UseDB;$MLDBM::Serializer='Data::Dumper' unless$MLDBM::Serializer;$MLDBM::Key='$MlDbM' unless$MLDBM::Key;$MLDBM::DumpMeth="" unless$MLDBM::DumpMeth;$MLDBM::RemoveTaint=0 unless$MLDBM::RemoveTaint;my$loadpack=sub {my$pack=shift;$pack =~ s|::|/|g;$pack .= ".pm";eval {require$pack};if ($@){carp "MLDBM error: " ."Please make sure $pack is a properly installed package.\n" ."\tPerl says: \"$@\"";return undef}1};sub TIEHASH {my$c=shift;my$s=bless {},$c;my$szr=$MLDBM::Serializer;unless (ref$szr){$szr="MLDBM::Serializer::$szr" unless$szr =~ /^MLDBM::Serializer::/;$loadpack->($szr)or return undef;$szr=$szr->new($MLDBM::DumpMeth,$MLDBM::RemoveTaint,$MLDBM::Key)}$s->Serializer($szr);my$db=$MLDBM::UseDB;unless (ref$db){$loadpack->($db)or return undef;$db=$db->TIEHASH(@_)or carp "MLDBM error: Second level tie failed, \"$!\"" and return undef}$s->UseDB($db);return$s}sub FETCH {my ($s,$k)=@_;my$ret=$s->{DB}->FETCH($k);$s->{SR}->deserialize($ret)}sub STORE {my ($s,$k,$v)=@_;$v=$s->{SR}->serialize($v);$s->{DB}->STORE($k,$v)}sub DELETE {my$s=shift;$s->{DB}->DELETE(@_)}sub FIRSTKEY {my$s=shift;$s->{DB}->FIRSTKEY(@_)}sub NEXTKEY {my$s=shift;$s->{DB}->NEXTKEY(@_)}sub EXISTS {my$s=shift;$s->{DB}->EXISTS(@_)}sub CLEAR {my$s=shift;$s->{DB}->CLEAR(@_)}sub new {&TIEHASH}sub AUTOLOAD {return if$MLDBM::AUTOLOAD =~ /::DESTROY$/;my$s=shift;if (ref$s){my$dbname=ref($s->{DB});$MLDBM::AUTOLOAD =~ s/^.*::([^:]+)$/$dbname\:\:$1/;$s->{DB}->$MLDBM::AUTOLOAD(@_)}}sub DumpMeth {my$s=shift;$s->{SR}->DumpMeth(@_)}sub RemoveTaint {my$s=shift;$s->{SR}->RemoveTaint(@_)}sub Key {my$s=shift;$s->{SR}->Key(@_)}sub UseDB {my$s=shift;@_ ? ($s->{DB}=shift): $s->{DB}}sub Serializer {my$s=shift;@_ ? ($s->{SR}=shift): $s->{SR}}sub import {my ($pack,$dbpack,$szr,$dumpmeth,$removetaint,$key)=@_;$MLDBM::UseDB=$dbpack if defined$dbpack and $dbpack;$MLDBM::Serializer=$szr if defined$szr and $szr;$MLDBM::DumpMeth=$dumpmeth if defined$dumpmeth;$MLDBM::RemoveTaint=$removetaint if defined$removetaint;$MLDBM::Key=$key if defined$key and $key}sub _compare {use vars qw(%compared);local%compared;return _cmp(@_)}sub _cmp {my($a,$b)=@_;return(1)if$compared{$a.'&*&*&*&*&*'.$b}++;if(ref($a)and ref($a)eq ref($b)){if(eval {@$a}){@$a==@$b or return 0;for(0..@$a-1){&_cmp($a->[$_],$b->[$_])or return 0}}elsif(eval {%$a}){keys %$a==keys %$b or return 0;for (keys %$a){&_cmp($a->{$_},$b->{$_})or return 0}}elsif(eval {$$a}){&_cmp($$a,$$b)or return 0}else {die("data $a $b not handled")}return 1}elsif(!ref($a)and!ref($b)){return ($a eq $b)}else {return 0}}1;
MLDBM

$fatpacked{"MLDBM/Serializer/Data/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MLDBM_SERIALIZER_DATA_DUMPER';
  package MLDBM::Serializer::Data::Dumper;BEGIN {@MLDBM::Serializer::Data::Dumper::ISA=qw(MLDBM::Serializer)}use Data::Dumper '2.08';use Carp;sub new {my$self=shift->SUPER::new();my$meth=shift || "";$meth=(defined(&Data::Dumper::Dumpxs)? 'Dumpxs' : 'Dump')unless$meth =~ /^Dump(xs)?$/;$self->DumpMeth($meth);$self->RemoveTaint(shift);$self->Key(shift);$self}sub serialize {my$self=shift;my ($val)=@_;return undef unless defined$val;return$val unless ref($val)or $val =~ m|^\Q$self->{'key'}|o;my$dumpmeth=$self->{'dumpmeth'};local$Data::Dumper::Indent=0;local$Data::Dumper::Purity=1;local$Data::Dumper::Terse=1;return$self->{'key'}.Data::Dumper->$dumpmeth([$val],['M'])}sub deserialize {my$self=shift;my ($val)=@_;return undef unless defined$val;return$val unless$val =~ s|^\Q$self->{'key'}||o;my$M="";($val)=$val =~ /^(.*)$/s if$self->{'removetaint'};my$N=eval($val =~ /^\{/ ? '+'.$val : $val);return$M ? $M : $N unless $@;carp "MLDBM error: $@\twhile evaluating:\n $val"}sub DumpMeth {my$s=shift;$s->_attrib('dumpmeth',@_)}sub RemoveTaint {my$s=shift;$s->_attrib('removetaint',@_)}sub Key {my$s=shift;$s->_attrib('key',@_)}{local$Data::Dumper::Terse}1;
MLDBM_SERIALIZER_DATA_DUMPER

$fatpacked{"MLDBM/Serializer/FreezeThaw.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MLDBM_SERIALIZER_FREEZETHAW';
  package MLDBM::Serializer::FreezeThaw;BEGIN {@MLDBM::Serializer::FreezeThaw::ISA=qw(MLDBM::Serializer)}use FreezeThaw;sub serialize {return FreezeThaw::freeze($_[1])}sub deserialize {my ($obj)=FreezeThaw::thaw($_[1]);return$obj}1;
MLDBM_SERIALIZER_FREEZETHAW

$fatpacked{"MLDBM/Serializer/Storable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MLDBM_SERIALIZER_STORABLE';
  package MLDBM::Serializer::Storable;BEGIN {@MLDBM::Serializer::Storable::ISA=qw(MLDBM::Serializer)}use Storable;sub new {my$self=shift->SUPER::new();$self->DumpMeth(shift);$self}sub serialize {my$self=shift;my$dumpmeth=$self->{'_dumpsub_'};&$dumpmeth(\$_[0])}sub deserialize {my$obj=Storable::thaw($_[1]);defined($obj)? $$obj : undef}sub DumpMeth {my$self=shift;$self->{'_dumpsub_'}=($_[0]&& $_[0]eq 'portable' ? \&Storable::nfreeze : \&Storable::freeze);$self->_attrib('dumpmeth',@_)}1;
MLDBM_SERIALIZER_STORABLE

$fatpacked{"MLDBM/Sync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MLDBM_SYNC';
  package MLDBM::Sync;$VERSION='0.30';use MLDBM;use MLDBM::Sync::SDBM_File;use Data::Dumper;use Fcntl qw(:flock);use Digest::MD5 qw(md5_hex);use strict;use Carp qw(confess);no strict qw(refs);use vars qw($AUTOLOAD @EXT $CACHE_ERR $LOCK_SH $LOCK_EX $LOCK_UN);eval "use Tie::Cache;";if (($@)){$CACHE_ERR=$@}$LOCK_SH=LOCK_SH;$LOCK_UN=LOCK_UN;$LOCK_EX=LOCK_EX;@EXT=('.pag','.dir','');sub TIEHASH {my($class,$file,@args)=@_;$file =~ /^(.*)$/s;$file=$1;my$fh=$file.".lock";my$self=bless {'file'=>$file,'args'=>[$file,@args ],'lock_fh'=>$fh,'lock_file'=>$fh,'lock_num'=>0,'md5_keys'=>0,'pid'=>$$,'keys'=>[],'db_type'=>$MLDBM::UseDB,'serializer'=>$MLDBM::Serializer,'remove_taint'=>$MLDBM::RemoveTaint,};$self}sub DESTROY {my$self=shift;if($self->{lock_num}){$self->{lock_num}=1;$self->UnLock}}sub AUTOLOAD {my($self,$key,$value)=@_;$AUTOLOAD =~ /::([^:]+)$/;my$func=$1;grep($func eq $_,('FETCH','STORE','EXISTS','DELETE'))|| die("$func not handled by object $self");if(defined$key && $self->{md5_keys}){$key=$self->SyncChecksum($key)}my$cache=(defined$key)? $self->{cache}: undef;if($cache && ($func eq 'FETCH' or $func eq 'EXISTS')){my$rv=$cache->$func($key);defined($rv)&& return($rv)}my$rv;if ($func eq 'FETCH' or $func eq 'EXISTS'){$self->read_lock}else {$self->lock}{local$MLDBM::RemoveTaint=$self->{remove_taint};if (defined$value){$rv=$self->{dbm}->$func($key,$value)}else {$rv=$self->{dbm}->$func($key)}}$self->unlock;$cache && $cache->$func($key,$value);$rv}sub CLEAR {my$self=shift;$self->lock;$self->{dbm}->CLEAR;$self->{dbm}=undef;my$unlinked=0;for (@EXT){my$file=$self->{file}.$_;next if(!-e $file);if(-d $file){rmdir($file)|| warn("can't unlink dir $file: $!")}else {unlink($file)|| die("can't unlink file $file: $!")}$unlinked++}if($self->{lock_num}> 1){$self->SyncTie}$self->unlock;if($self->{lock_num}==0){unlink($self->{lock_file})}$self->{cache}&& $self->{cache}->CLEAR;1};sub FIRSTKEY {my$self=shift;if($self->{md5_keys}){confess("can't get keys() or each() on MLDBM::Sync database "."with SyncKeysChecksum(1) set")}$self->read_lock;my$key=$self->{dbm}->FIRSTKEY();my@keys;while(1){last if!defined($key);push(@keys,$key);$key=$self->{dbm}->NEXTKEY($key)}$self->unlock;$self->{'keys'}=\@keys;$self->NEXTKEY}sub NEXTKEY {my$self=shift;if($self->{md5_keys}){confess("can't get keys() or each() on MLDBM::Sync database "."with SyncKeysChecksum(1) set")}my$rv=shift(@{$self->{'keys'}})}sub SyncChecksum {my($self,$key)=@_;if(ref$key){join('g',md5_hex($$key),sprintf("%07d",length($$key)))}else {join('g',md5_hex($key),sprintf("%07d",length($key)))}}sub SyncCacheSize {my($self,$size)=@_;$CACHE_ERR && die("need Tie::Cache installed to use this feature: $@");if ($size =~ /^(\d+)(M|K)$/){my($num,$type)=($1,$2);if (($type eq 'M')){$size=$num * 1024 * 1024}elsif (($type eq 'K')){$size=$num * 1024}else {die "$type symbol not understood for $size"}}else {($size =~ /^\d+$/)or die("$size must be bytes size for cache")}if ($self->{cache}){$self->{cache}->CLEAR()}my%cache;my$cache=tie%cache,'Tie::Cache',{MaxBytes=>$size };$self->{cache}=$cache}sub SyncTie {my$self=shift;my%temp_hash;my$args=$self->{args};local$MLDBM::UseDB=$self->{db_type};local$MLDBM::Serializer=$self->{serializer};local$MLDBM::RemoveTaint=$self->{remove_taint};$self->{dbm}=tie(%temp_hash,'MLDBM',@$args)|| die("can't tie to MLDBM with args: ".join(',',@$args)."; error: $!");$self->{dbm}}sub SyncKeysChecksum {my($self,$setting)=@_;if(defined$setting){$self->{md5_keys}=$setting}else {$self->{md5_keys}}}*read_lock=*ReadLock;sub ReadLock {shift->Lock(1)}*lock=*SyncLock=*Lock;sub Lock {my($self,$read_lock)=@_;if($self->{lock_num}++==0){my$file=$self->{lock_file};open($self->{lock_fh},"+>$file")|| die("can't open file $file: $!");flock($self->{lock_fh},($read_lock ? $LOCK_SH : $LOCK_EX))|| die("can't ".($read_lock ? "read" : "write")." lock $file: $!");$self->{read_lock}=$read_lock;$self->SyncTie}else {if ($self->{read_lock}and!$read_lock){$self->{lock_num}--;confess("Can't upgrade lock type from LOCK_SH to LOCK_EX! "."This could happen if you tried to write to the MLDBM "."in a critical section locked by ReadLock(). "."Also the read expression my \$v = \$db{'key1'}{'key2'} will trigger a write "."if \$db{'key1'} does not already exist, so this will error in a ReadLock() section")}1}}*unlock=*SyncUnLock=*UnLock;sub UnLock {my$self=shift;if($self->{lock_num}&& $self->{lock_num}--==1){$self->{lock_num}=0;undef$self->{dbm};flock($self->{'lock_fh'},$LOCK_UN)|| die("can't unlock $self->{'lock_file'}: $!");close($self->{'lock_fh'})|| die("can't close $self->{'lock_file'}");$self->{read_lock}=undef;1}else {1}}sub SyncSize {my$self=shift;my$size=0;for (@EXT){my$file=$self->{file}.$_;next unless -e $file;$size += (stat($file))[7];if(-d $file){$size += (stat($file))[7];opendir(DIR,$file)|| next;my@files=readdir(DIR);for my$dir_file (@files){next if$dir_file =~ /^\.\.?$/;$size += (stat("$file/$dir_file"))[7]}closedir(DIR)}}$size}1;
MLDBM_SYNC

$fatpacked{"MLDBM/Sync/SDBM_File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MLDBM_SYNC_SDBM_FILE';
  package MLDBM::Sync::SDBM_File;$VERSION=.17;use SDBM_File;use strict;use vars qw(@ISA $MaxSegments $MaxSegmentLength %KEYS $Zlib $VERSION);@ISA=qw(SDBM_File);$MaxSegments=8192;$MaxSegmentLength=128;eval "use Compress::Zlib";$Zlib=$@ ? 0 : 1;sub FETCH {my($self,$key)=@_;my$segment_length=$MaxSegmentLength;my$total_rv;for(my$index=0;$index < $MaxSegments;$index++){my$rv=$self->SUPER::FETCH(_index_key($key,$index));if(defined$rv){$total_rv ||='';$total_rv .= $rv;last if length($rv)< $segment_length}else {last}}if(defined$total_rv){$total_rv =~ s/^(..)//s;my$type=$1;if($type eq 'G}'){$total_rv=uncompress($total_rv)}elsif ($type eq 'N}'){}else {$total_rv=$type .$total_rv}}$total_rv}sub STORE {my($self,$key,$value)=@_;my$segment_length=$MaxSegmentLength;for(my$index=0;$index < $MaxSegments;$index++){my$index_key=_index_key($key,$index);my$rv=$self->SUPER::FETCH($index_key);if(defined$rv){$self->SUPER::DELETE($index_key)}else {last}last if length($rv)< $segment_length}my$old_value=$value;$value=($Zlib && (length($value)>= $segment_length/2))? "G}".compress($value): "N}".$value;my($total_rv,$last_index);for(my$index=0;$index < $MaxSegments;$index++){if($index==$MaxSegments){die("can't store more than $MaxSegments segments of $MaxSegmentLength bytes per key in ".__PACKAGE__)}$value =~ s/^(.{0,$segment_length})//so;my$segment=$1;last if length($segment)==0;my$rv=$self->SUPER::STORE(_index_key($key,$index),$segment);$total_rv .= $segment;$last_index=$index}$old_value}sub DELETE {my($self,$key)=@_;my$segment_length=$MaxSegmentLength;my$total_rv;for(my$index=0;$index < $MaxSegments;$index++){my$index_key=_index_key($key,$index);my$rv=$self->SUPER::FETCH($index_key)|| '';$self->SUPER::DELETE($index_key);$total_rv ||='';$total_rv .= $rv;last if length($rv)< $segment_length}$total_rv =~ s/^(..)//s;my$type=$1;if($type eq 'G}'){$total_rv=uncompress($total_rv)}elsif ($type eq 'N}'){}else {$total_rv=$type.$total_rv}$total_rv}sub FIRSTKEY {my$self=shift;my$key=$self->SUPER::FIRSTKEY();my@keys=();if (defined$key){do {if($key !~ /\*\*\d+$/s){if(my$new_key=_decode_key($key)){push(@keys,$new_key)}}}while($key=$self->SUPER::NEXTKEY($key))}$KEYS{$self}=\@keys;$self->NEXTKEY}sub NEXTKEY {my$self=shift;shift(@{$KEYS{$self}})}sub _index_key {my($key,$index)=@_;$key =~ s/([\%\*])/uc sprintf("%%%02x",ord($1))/esg;$index ? $key.'**'.$index : $key}sub _decode_key {my$key=shift;$key =~ s/%([0-9a-fA-F]{2})/pack("c",hex($1))/ge;$key}1;
MLDBM_SYNC_SDBM_FILE

$fatpacked{"Net/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER';
  package Net::Server;use strict;use Socket qw(AF_INET AF_UNIX SOCK_DGRAM SOCK_STREAM);use IO::Socket ();use IO::Select ();use POSIX ();use Net::Server::Proto ();use Net::Server::Daemonize qw(check_pid_file create_pid_file safe_fork get_uid get_gid set_uid set_gid);our$VERSION='2.008';sub new {my$class=shift || die "Missing class";my$args=@_==1 ? shift : {@_};return bless {server=>{%$args}},$class}sub net_server_type {__PACKAGE__}sub get_property {$_[0]->{'server'}->{$_[1]}}sub set_property {$_[0]->{'server'}->{$_[1]}=$_[2]}sub run {my$self=ref($_[0])? shift(): shift->new;$self->{'server'}->{'_run_args'}=[@_==1 ? %{$_[0]}: @_];$self->_initialize;$self->post_configure;$self->post_configure_hook;$self->pre_bind;$self->bind;$self->post_bind_hook;$self->post_bind;$self->pre_loop_hook;$self->loop;$self->server_close}sub run_client_connection {my$self=shift;my$c=$self->{'server'}->{'client'};$self->post_accept($c);$self->get_client_info($c);$self->post_accept_hook($c);my$ok=$self->allow_deny($c)&& $self->allow_deny_hook($c);if ($ok){$self->process_request($c)}else {$self->request_denied_hook($c)}$self->post_process_request_hook($ok);$self->post_process_request;$self->post_client_connection_hook}sub _initialize {my$self=shift;my$prop=$self->{'server'}||={};$self->commandline($self->_get_commandline)if!eval {$self->commandline};$self->configure_hook;$self->configure;my@defaults=%{$self->default_values || {}};$self->process_args(\@defaults)if@defaults}sub commandline {my$self=shift;$self->{'server'}->{'commandline'}=ref($_[0])? shift : \@_ if @_;return$self->{'server'}->{'commandline'}|| die "commandline was not set during initialization"}sub _get_commandline {my$self=shift;my$script=$0;$script=$ENV{'PWD'}.'/'.$script if$script =~ m|^[^/]+/| && $ENV{'PWD'};$script =~ /^(.+)$/;return [$1,@ARGV]}sub configure_hook {}sub configure {my$self=shift;my$prop=$self->{'server'};my$template=($_[0]&& ref($_[0]))? shift : undef;$self->process_args(\@ARGV,$template)if@ARGV;$self->process_args($prop->{'_run_args'},$template)if$prop->{'_run_args'};if ($prop->{'conf_file'}){$self->process_args($self->_read_conf($prop->{'conf_file'}),$template)}else {my$def=$self->default_values || {};$self->process_args($self->_read_conf($def->{'conf_file'}),$template)if$def->{'conf_file'}}}sub default_values {{}}sub post_configure {my$self=shift;my$prop=$self->{'server'};$prop->{'log_level'}=2 if!defined($prop->{'log_level'})|| $prop->{'log_level'}!~ /^\d+$/;$prop->{'log_level'}=4 if$prop->{'log_level'}> 4;$self->initialize_logging;if ($prop->{'pid_file'}){if (!eval{check_pid_file($prop->{'pid_file'})}){warn $@ if!$ENV{'BOUND_SOCKETS'};$self->fatal(my$e=$@)}}if (!$prop->{'_is_inet'}){if ($prop->{'setsid'}|| length($prop->{'log_file'})){open(STDIN,'<','/dev/null')|| die "Cannot read /dev/null  [$!]";open(STDOUT,'>','/dev/null')|| die "Cannot write /dev/null [$!]"}}if (!$ENV{'BOUND_SOCKETS'}){if ($prop->{'setsid'}|| $prop->{'background'}){my$pid=eval {safe_fork()};$self->fatal(my$e=$@)if!defined$pid;exit(0)if$pid;$self->log(2,"Process Backgrounded")}POSIX::setsid()if$prop->{'setsid'}}if (length($prop->{'log_file'})&&!$prop->{'log_function'}){open STDERR,'>&_SERVER_LOG' || die "Cannot open STDERR to _SERVER_LOG [$!]"}elsif ($prop->{'setsid'}){open STDERR,'>&STDOUT' || die "Cannot open STDERR to STDOUT [$!]"}if ($prop->{'pid_file'}){if (eval {create_pid_file($prop->{'pid_file'})}){$prop->{'pid_file_unlink'}=1}else {$self->fatal(my$e=$@)}}$prop->{$_}=[]for grep {!ref$prop->{$_}}qw(allow deny cidr_allow cidr_deny)}sub initialize_logging {my$self=shift;my$prop=$self->{'server'};if (!defined($prop->{'log_file'})){$prop->{'log_file'}='';return}if ($prop->{'log_file'}=~ /^([a-zA-Z]\w*(?:::[a-zA-Z]\w*)*)$/){my$pkg="Net::Server::Log::$prop->{'log_file'}";(my$file="$pkg.pm")=~ s|::|/|g;if (eval {require$file}){$prop->{'log_function'}=$pkg->initialize($self);$prop->{'log_class'}=$pkg;return}elsif ($file =~ /::/ || grep {-e "$_/$file"}@INC){$self->fatal("Unable to load log module $pkg from file $file: $@")}}die "Unsecure filename \"$prop->{'log_file'}\"" if$prop->{'log_file'}!~ m|^([\:\w\.\-/\\]+)$|;$prop->{'log_file'}=$1;open(_SERVER_LOG,">>",$prop->{'log_file'})|| die "Couldn't open log file \"$prop->{'log_file'}\" [$!].";_SERVER_LOG->autoflush(1);push @{$prop->{'chown_files'}},$prop->{'log_file'}}sub post_configure_hook {}sub _server_type {ref($_[0])}sub pre_bind {my$self=shift;my$prop=$self->{'server'};my$super=$self->net_server_type;my$type=$self->_server_type;if ($self->isa('Net::Server::MultiType')){my$base=delete($prop->{'_recursive_multitype'})|| Net::Server::MultiType->net_server_type;$super="$super -> MultiType -> $base"}$type .= " (type $super)" if$type ne $super;$self->log(2,$self->log_time ." $type starting! pid($$)");$prop->{'sock'}=[grep {$_}map {$self->proto_object($_)}@{$self->prepared_ports}];$self->fatal("No valid socket parameters found")if!@{$prop->{'sock'}}}sub prepared_ports {my$self=shift;my$prop=$self->{'server'};my ($ports,$hosts,$protos,$ipvs)=@$prop{qw(port host proto ipv)};$ports ||=$prop->{'ports'};if (!defined($ports)|| (ref($ports)&&!@$ports)){$ports=$self->default_port;if (!defined($ports)|| (ref($ports)&&!@$ports)){$ports=default_port();$self->log(2,"Port Not Defined.  Defaulting to '$ports'")}}my%bound;my$bind=$prop->{'_bind'}=[];for my$_port (ref($ports)? @$ports : $ports){my$_host=ref($hosts)? $hosts->[@$bind >= @$hosts ? -1 : $#$bind + 1]: $hosts;my$_proto=ref($protos)? $protos->[@$bind >= @$protos ? -1 : $#$bind + 1]: $protos;my$_ipv=ref($ipvs)? $ipvs->[@$bind >= @$ipvs ? -1 : $#$bind + 1]: $ipvs;for my$info ($self->port_info($_port,$_host,$_proto,$_ipv)){my ($port,$host,$proto,$ipv)=@$info{qw(port host proto ipv)};if ($port ne "0" && $bound{"$host\e$port\e$proto\e$ipv"}++){$self->log(2,"Duplicate configuration (\U$proto\E) on [$host]:$port with IPv$ipv) - skipping");next}push @$bind,$info}}return$bind}sub port_info {my ($self,$port,$host,$proto,$ipv)=@_;return Net::Server::Proto->parse_info($port,$host,$proto,$ipv,$self)}sub proto_object {my ($self,$info)=@_;return Net::Server::Proto->object($info,$self)}sub bind {my$self=shift;my$prop=$self->{'server'};if (exists$ENV{'BOUND_SOCKETS'}){$self->restart_open_hook;$self->log(2,"Binding open file descriptors");my%map;for my$info (split /\s*;\s*/,$ENV{'BOUND_SOCKETS'}){my ($fd,$host,$port,$proto,$ipv,$orig)=split /\|/,$info;$orig=$port if!defined$orig;$fd=($fd =~ /^(\d+)$/)? $1 : $self->fatal("Bad file descriptor");$map{"$host|$orig|$proto|$ipv"}->{$fd}=$port}for my$sock (@{$prop->{'sock'}}){$sock->log_connect($self);if (my$ref=$map{$sock->hup_string}){my ($fd,$port)=each %$ref;$sock->reconnect($fd,$self,$port);delete$ref->{$fd};delete$map{$sock->hup_string}if!keys %$ref}else {$self->log(2,"Added new port configuration");$sock->connect($self)}}for my$str (keys%map){for my$fd (keys %{$map{$str}}){$self->log(2,"Closing un-mapped port ($str) on fd $fd");POSIX::close($fd)}}delete$ENV{'BOUND_SOCKETS'};$self->{'hup_waitpid'}=1}else {for my$sock (@{$prop->{'sock'}}){$sock->log_connect($self);$sock->connect($self)}}if (@{$prop->{'sock'}}> 1 || $prop->{'multi_port'}){$prop->{'multi_port'}=1;$prop->{'select'}=IO::Select->new;$prop->{'select'}->add($_)for @{$prop->{'sock'}}}else {$prop->{'multi_port'}=undef;$prop->{'select'}=undef}}sub post_bind_hook {}sub post_bind {my$self=shift;my$prop=$self->{'server'};if (!defined$prop->{'group'}){$self->log(1,"Group Not Defined.  Defaulting to EGID '$)'");$prop->{'group'}=$)}elsif ($prop->{'group'}=~ /^([\w-]+(?: [\w-]+)*)$/){$prop->{'group'}=eval {get_gid($1)};$self->fatal(my$e=$@)if $@}else {$self->fatal("Invalid group \"$prop->{'group'}\"")}if (!defined$prop->{'user'}){$self->log(1,"User Not Defined.  Defaulting to EUID '$>'");$prop->{'user'}=$>}elsif ($prop->{'user'}=~ /^([\w-]+)$/){$prop->{'user'}=eval {get_uid($1)};$self->fatal(my$e=$@)if $@}else {$self->fatal("Invalid user \"$prop->{'user'}\"")}if ($prop->{'group'}ne $) || $prop->{'user'}ne $>){my@chown_files;push@chown_files,map {$_->NS_port}grep {$_->NS_proto =~ /^UNIX/}@{$prop->{'sock'}};push@chown_files,$prop->{'pid_file'}if$prop->{'pid_file_unlink'};push@chown_files,$prop->{'lock_file'}if$prop->{'lock_file_unlink'};push@chown_files,@{$prop->{'chown_files'}|| []};my$uid=$prop->{'user'};my$gid=(split /\ /,$prop->{'group'})[0];for my$file (@chown_files){chown($uid,$gid,$file)|| $self->fatal("Couldn't chown \"$file\" [$!]")}}if ($prop->{'chroot'}){$self->fatal("Specified chroot \"$prop->{'chroot'}\" doesn't exist.")if!-d $prop->{'chroot'};$self->log(2,"Chrooting to $prop->{'chroot'}");chroot($prop->{'chroot'})|| $self->fatal("Couldn't chroot to \"$prop->{'chroot'}\": $!")}eval {if ($prop->{'group'}ne $)){$self->log(2,"Setting gid to \"$prop->{'group'}\"");set_gid($prop->{'group'})}if ($prop->{'user'}ne $>){$self->log(2,"Setting uid to \"$prop->{'user'}\"");set_uid($prop->{'user'})}};if ($@){if ($>==0){$self->fatal(my$e=$@)}elsif ($<==0){$self->log(2,"NOTICE: Effective UID changed, but Real UID is 0: $@")}else {$self->log(2,my$e=$@)}}$prop->{'requests'}=0;$SIG{'INT'}=$SIG{'TERM'}=$SIG{'QUIT'}=sub {$self->server_close};$SIG{'PIPE'}='IGNORE';$SIG{'CHLD'}=\&sig_chld;$SIG{'HUP'}=sub {$self->sig_hup}}sub sig_chld {1 while waitpid(-1,POSIX::WNOHANG())> 0;$SIG{'CHLD'}=\&sig_chld}sub pre_loop_hook {}sub loop {my$self=shift;while ($self->accept){$self->run_client_connection;last if$self->done}}sub accept {my$self=shift;my$prop=$self->{'server'};my$sock=undef;my$retries=30;while ($retries--){if ($prop->{'multi_port'}){return 0 if$prop->{'_HUP'};$sock=$self->accept_multi_port || next;return 0 if$prop->{'_HUP'};if ($self->can_read_hook($sock)){$retries++;next}}else {$sock=$prop->{'sock'}->[0]}$self->fatal("Received a bad sock!")if!defined$sock;if (SOCK_DGRAM==$sock->getsockopt(Socket::SOL_SOCKET(),Socket::SO_TYPE())){$prop->{'client'}=$sock;$prop->{'udp_true'}=1;$prop->{'udp_peer'}=$sock->recv($prop->{'udp_data'},$sock->NS_recv_len,$sock->NS_recv_flags)}else {delete$prop->{'udp_true'};$prop->{'client'}=$sock->accept()}return 0 if$prop->{'_HUP'};return 1 if$prop->{'client'};$self->log(2,"Accept failed with $retries tries left: $!");sleep(1)}$self->log(1,"Ran out of accept retries!");return undef}sub accept_multi_port {my@waiting=shift->{'server'}->{'select'}->can_read();return undef if!@waiting;return$waiting[rand@waiting]}sub can_read_hook {}sub post_accept {my$self=shift;my$prop=$self->{'server'};my$client=shift || $prop->{'client'};$prop->{'requests'}++;return if$prop->{'udp_true'};if (!$client){$self->log(1,"Client socket information could not be determined!");return}$client->post_accept()if$client->can("post_accept");if (!$prop->{'no_client_stdout'}){close STDIN;close STDOUT;if ($prop->{'tie_client_stdout'}|| ($client->can('tie_stdout')&& $client->tie_stdout)){open STDIN,'<','/dev/null' or die "Couldn't open STDIN to the client socket: $!";open STDOUT,'>','/dev/null' or die "Couldn't open STDOUT to the client socket: $!";tie*STDOUT,'Net::Server::TiedHandle',$client,$prop->{'tied_stdout_callback'}or die "Couldn't tie STDOUT: $!";tie*STDIN,'Net::Server::TiedHandle',$client,$prop->{'tied_stdin_callback'}or die "Couldn't tie STDIN: $!"}elsif (defined(my$fileno=fileno$prop->{'client'})){open STDIN,'<&',$fileno or die "Couldn't open STDIN to the client socket: $!";open STDOUT,'>&',$fileno or die "Couldn't open STDOUT to the client socket: $!"}else {*STDIN=\*{$client};*STDOUT=\*{$client}}STDIN->autoflush(1);STDOUT->autoflush(1);select STDOUT}}sub get_client_info {my$self=shift;my$prop=$self->{'server'};my$client=shift || $prop->{'client'};if ($client->NS_proto =~ /^UNIX/){delete @$prop{qw(sockaddr sockport peeraddr peerport peerhost)};$self->log(3,$self->log_time." CONNECT ".$client->NS_proto." Socket: \"".$client->NS_port."\"")if$prop->{'log_level'}&& 3 <= $prop->{'log_level'};return}if (my$sockname=$client->sockname){$prop->{'sockaddr'}=$client->sockhost;$prop->{'sockport'}=$client->sockport}else {@{$prop}{qw(sockaddr sockhost sockport)}=($ENV{'REMOTE_HOST'}|| '0.0.0.0','inet.test',0)}my$addr;if ($prop->{'udp_true'}){if ($client->sockdomain==AF_INET){($prop->{'peerport'},$addr)=Socket::sockaddr_in($prop->{'udp_peer'});$prop->{'peeraddr'}=Socket::inet_ntoa($addr)}else {warn "Right here\n";($prop->{'peerport'},$addr)=Socket6::sockaddr_in6($prop->{'udp_peer'});$prop->{'peeraddr'}=Socket6->can('inet_ntop')? Socket6::inet_ntop($client->sockdomain,$addr): Socket::inet_ntoa($addr)}}elsif ($prop->{'peername'}=$client->peername){$addr=$client->peeraddr;$prop->{'peeraddr'}=$client->peerhost;$prop->{'peerport'}=$client->peerport}else {@{$prop}{qw(peeraddr peerhost peerport)}=('0.0.0.0','inet.test',0)}if ($addr && defined$prop->{'reverse_lookups'}){if ($INC{'Socket6.pm'}&& Socket6->can('getnameinfo')){my@res=Socket6::getnameinfo($addr,0);$prop->{'peerhost'}=$res[0]if@res > 1}else{$prop->{'peerhost'}=gethostbyaddr($addr,AF_INET)}}$self->log(3,$self->log_time ." CONNECT ".$client->NS_proto ." Peer: \"[$prop->{'peeraddr'}]:$prop->{'peerport'}\"" ." Local: \"[$prop->{'sockaddr'}]:$prop->{'sockport'}\"")if$prop->{'log_level'}&& 3 <= $prop->{'log_level'}}sub post_accept_hook {}sub allow_deny {my$self=shift;my$prop=$self->{'server'};my$sock=shift || $prop->{'client'};return 1 if$sock && $sock->NS_proto =~ /^UNIX/;return 1 if!@{$prop->{'allow'}}&&!@{$prop->{'deny'}}&&!@{$prop->{'cidr_allow'}}&&!@{$prop->{'cidr_deny'}};my$peeraddr=($prop->{'peeraddr'}=~ /^\s*::ffff:([0-9.]+\s*)$/)? $1 : $prop->{'peeraddr'};for (@{$prop->{'deny'}}){return 0 if$prop->{'reverse_lookups'}&& defined($prop->{'peerhost'})&& $prop->{'peerhost'}=~ /^$_$/;return 0 if$peeraddr =~ /^$_$/}if (@{$prop->{'cidr_deny'}}){require Net::CIDR;return 0 if Net::CIDR::cidrlookup($peeraddr,@{$prop->{'cidr_deny'}})}for (@{$prop->{'allow'}}){return 1 if$prop->{'reverse_lookups'}&& defined($prop->{'peerhost'})&& $prop->{'peerhost'}=~ /^$_$/;return 1 if$peeraddr =~ /^$_$/}if (@{$prop->{'cidr_allow'}}){require Net::CIDR;return 1 if Net::CIDR::cidrlookup($peeraddr,@{$prop->{'cidr_allow'}})}return 0}sub allow_deny_hook {1}sub request_denied_hook {}sub process_request {my$self=shift;my$prop=$self->{'server'};if ($prop->{'udp_true'}){my$client=shift || $prop->{'client'};if ($prop->{'udp_data'}=~ /dump/){require Data::Dumper;return$client->send(Data::Dumper::Dumper($self),0)}return$client->send("You said \"$prop->{'udp_data'}\"",0)}print "Welcome to \"".ref($self)."\" ($$)\015\012";my$previous_alarm=alarm 30;eval {local$SIG{'ALRM'}=sub {die "Timed Out!\n"};while (<STDIN>){s/[\r\n]+$//;print ref($self),":$$: You said \"$_\"\015\012";$self->log(5,$_);if (/get\s+(\w+)/){print "$1: $self->{'server'}->{$1}\015\012"}elsif (/dump/){require Data::Dumper;print Data::Dumper::Dumper($self)}elsif (/quit/){last}elsif (/exit/){$self->server_close}alarm 30}alarm($previous_alarm)};alarm 0;print "Timed Out.\015\012" if $@ eq "Timed Out!\n"}sub post_process_request_hook {}sub post_client_connection_hook {}sub post_process_request {my$self=shift;$self->close_client_stdout}sub close_client_stdout {my$self=shift;my$prop=$self->{'server'};return if$prop->{'udp_true'};if (!$prop->{'no_client_stdout'}){my$t=tied*STDOUT;if ($t){undef$t;untie*STDOUT};$t=tied*STDIN;if ($t){undef$t;untie*STDIN};open(STDIN,'<','/dev/null')|| die "Cannot read /dev/null  [$!]";open(STDOUT,'>','/dev/null')|| die "Cannot write /dev/null [$!]"}$prop->{'client'}->close}sub done {my$self=shift;$self->{'server'}->{'done'}=shift if @_;return$self->{'server'}->{'done'}}sub pre_fork_hook {}sub child_init_hook {}sub child_finish_hook {}sub run_dequeue {my$self=shift;$self->pre_fork_hook('dequeue');my$pid=fork;$self->fatal("Bad fork [$!]")if!defined$pid;if (!$pid){$SIG{'INT'}=$SIG{'TERM'}=$SIG{'QUIT'}=$SIG{'HUP'}=sub {$self->child_finish_hook('dequeue');exit};$SIG{'PIPE'}=$SIG{'TTIN'}=$SIG{'TTOU'}='DEFAULT';$self->child_init_hook('dequeue');$self->dequeue();$self->child_finish_hook('dequeue');exit}$self->log(4,"Running dequeue child $pid");$self->{'server'}->{'children'}->{$pid}->{'status'}='dequeue' if$self->{'server'}->{'children'}}sub default_port {20203}sub dequeue {}sub pre_server_close_hook {}sub server_close {my ($self,$exit_val)=@_;my$prop=$self->{'server'};$SIG{'INT'}='DEFAULT';if (defined($prop->{'ppid'})&& $prop->{'ppid'}!=$$ &&!defined($prop->{'no_close_by_child'})){$self->close_parent;exit}$self->pre_server_close_hook;$self->log(2,$self->log_time ." Server closing!");if ($prop->{'kind_quit'}&& $prop->{'children'}){$self->log(3,"Attempting a slow shutdown");$prop->{$_}=0 for qw(min_servers max_servers);$self->hup_children;while (1){Net::Server::SIG::check_sigs();$self->coordinate_children if$self->can('coordinate_children');last if!keys %{$self->{'server'}->{'children'}};sleep 1}}if ($prop->{'_HUP'}&& $prop->{'leave_children_open_on_hup'}){$self->hup_children}else {$self->close_children()if$prop->{'children'};$self->post_child_cleanup_hook}if (defined($prop->{'lock_file'})&& -e $prop->{'lock_file'}&& defined($prop->{'lock_file_unlink'})){unlink($prop->{'lock_file'})|| $self->log(1,"Couldn't unlink \"$prop->{'lock_file'}\" [$!]")}if (defined($prop->{'pid_file'})&& -e $prop->{'pid_file'}&&!$prop->{'_HUP'}&& defined($prop->{'pid_file_unlink'})){unlink($prop->{'pid_file'})|| $self->log(1,"Couldn't unlink \"$prop->{'pid_file'}\" [$!]")}if ($prop->{'_HUP'}){$self->restart_close_hook();$self->hup_server}$self->shutdown_sockets;return$self if$prop->{'no_exit_on_close'};$self->server_exit($exit_val)}sub server_exit {my ($self,$exit_val)=@_;exit($exit_val || 0)}sub shutdown_sockets {my$self=shift;my$prop=$self->{'server'};for my$sock (@{$prop->{'sock'}}){$sock->shutdown(2);unlink$sock->NS_port if$sock->NS_proto =~ /^UNIX/}$prop->{'sock'}=[];return 1}sub close_parent {my$self=shift;my$prop=$self->{'server'};die "Missing parent pid (ppid)" if!$prop->{'ppid'};kill 2,$prop->{'ppid'}}sub close_children {my$self=shift;my$prop=$self->{'server'};return unless$prop->{'children'}&& scalar keys %{$prop->{'children'}};for my$pid (keys %{$prop->{'children'}}){$self->log(4,"Kill TERM pid $pid");if (kill(15,$pid)||!kill(0,$pid)){$self->delete_child($pid)}}1 while waitpid(-1,POSIX::WNOHANG())> 0}sub is_prefork {0}sub hup_children {my$self=shift;my$prop=$self->{'server'};return unless defined$prop->{'children'}&& scalar keys %{$prop->{'children'}};return if!$self->is_prefork;$self->log(2,"Sending children hup signal");for my$pid (keys %{$prop->{'children'}}){$self->log(4,"Kill HUP pid $pid");kill(1,$pid)or $self->log(2,"Failed to kill pid $pid: $!")}}sub post_child_cleanup_hook {}sub sig_hup {my$self=shift;my$prop=$self->{'server'};$self->log(2,"Received a SIG HUP");my$i=0;my@fd;$prop->{'_HUP'}=[];for my$sock (@{$prop->{'sock'}}){my$fd=POSIX::dup($sock->fileno)|| $self->fatal("Cannot duplicate the socket [$!]");$prop->{'_HUP'}->[$i]=IO::Socket::INET->new;$prop->{'_HUP'}->[$i]->fdopen($fd,'w')|| $self->fatal("Cannot open to file descriptor [$!]");require Fcntl;$prop->{'_HUP'}->[$i]->fcntl(Fcntl::F_SETFD(),my$flags="");push@fd,$fd .'|'.$sock->hup_string;$sock->close();$i++}delete$prop->{'select'};$ENV{'BOUND_SOCKETS'}=join "; ",@fd;if ($prop->{'leave_children_open_on_hup'}&& scalar keys %{$prop->{'children'}}){$ENV{'HUP_CHILDREN'}=join "\n",map {"$_\t$prop->{'children'}->{$_}->{'status'}"}sort keys %{$prop->{'children'}}}}sub hup_server {my$self=shift;$self->log(0,$self->log_time()." Re-exec server during HUP");delete@ENV{$self->hup_delete_env_keys};exec @{$self->commandline}}sub hup_delete_env_keys {return qw(PATH)}sub restart_open_hook {}sub restart_close_hook {}sub fatal {my ($self,$error)=@_;my ($package,$file,$line)=caller;$self->fatal_hook($error,$package,$file,$line);$self->log(0,$self->log_time ." $error\n  at line $line in file $file");$self->server_close(1)}sub fatal_hook {}sub log {my ($self,$level,$msg,@therest)=@_;my$prop=$self->{'server'};return if!$prop->{'log_level'};return if$level =~ /^\d+$/ && $level > $prop->{'log_level'};$msg=sprintf($msg,@therest)if@therest;if ($prop->{'log_function'}){return if eval {$prop->{'log_function'}->($level,$msg);1};my$err=$@;if ($prop->{'log_class'}&& $prop->{'log_class'}->can('handle_error')){$prop->{'log_class'}->handle_log_error($self,$err,[$level,$msg])}else {$self->handle_log_error($err,[$level,$msg])}}return if$level !~ /^\d+$/;$self->write_to_log_hook($level,$msg)}sub handle_log_error {my ($self,$error)=@_;die$error}sub handle_syslog_error {&handle_log_error}sub write_to_log_hook {my ($self,$level,$msg)=@_;my$prop=$self->{'server'};chomp$msg;$msg =~ s/([^\n\ -\~])/sprintf("%%%02X",ord($1))/eg;if ($prop->{'log_file'}){print _SERVER_LOG$msg,"\n"}elsif ($prop->{'setsid'}){}else {my$old=select STDERR;print$msg."\n";select$old}}sub log_time {my ($sec,$min,$hour,$day,$mon,$year)=localtime;return sprintf "%04d/%02d/%02d-%02d:%02d:%02d",$year + 1900,$mon + 1,$day,$hour,$min,$sec}sub options {my$self=shift;my$ref=shift || {};my$prop=$self->{'server'};for (qw(port host proto ipv allow deny cidr_allow cidr_deny)){if (!defined$prop->{$_}){$prop->{$_}=[]}elsif (!ref$prop->{$_}){$prop->{$_}=[$prop->{$_}]}$ref->{$_}=$prop->{$_}}for (qw(conf_file user group chroot log_level log_file pid_file background setsid listen reverse_lookups no_close_by_child no_client_stdout tie_client_stdout tied_stdout_callback tied_stdin_callback leave_children_open_on_hup)){$ref->{$_}=\$prop->{$_}}return$ref}sub process_args {my ($self,$args,$template)=@_;$self->options($template={})if!$template ||!ref$template;if (!$_[2]&&!scalar(keys %$template)&&!$self->{'server'}->{'_no_options'}++){warn "Configuration options were empty - skipping any commandline, config file, or run argument parsing.\n"}my%previously_set;for (my$i=0;$i < @$args;$i++){if ($args->[$i]=~ /^(?:--)?(\w+)(?:[=\ ](\S+))?$/ && exists$template->{$1}){my ($key,$val)=($1,$2);splice @$args,$i,1;if (!defined$val){if ($i > $#$args || ($args->[$i]&& $args->[$i]=~ /^--\w+/)){$val=1}else {$val=splice @$args,$i,1;$val=$val->[0]if ref($val)eq 'ARRAY' && @$val==1 && ref($template->{$key})ne 'ARRAY'}}$i--;$val =~ s/%([A-F0-9])/chr(hex $1)/eig if!ref$val;if (ref$template->{$key}eq 'ARRAY'){if (!defined$previously_set{$key}){$previously_set{$key}=scalar @{$template->{$key}}}next if$previously_set{$key};push @{$template->{$key}},ref($val)eq 'ARRAY' ? @$val : $val}else {if (!defined$previously_set{$key}){$previously_set{$key}=defined(${$template->{$key}})? 1 : 0}next if$previously_set{$key};die "Found multiple values on the configuration item \"$key\" which expects only one value" if ref($val)eq 'ARRAY';${$template->{$key}}=$val}}}}sub _read_conf {my ($self,$file)=@_;my@args;$file=($file =~ m|^([\w\.\-\/\\\:]+)$|)? $1 : $self->fatal("Unsecure filename \"$file\"");open my$fh,'<',$file or do {$self->fatal("Couldn't open conf \"$file\" [$!]")if$ENV{'BOUND_SOCKETS'};warn "Couldn't open conf \"$file\" [$!]\n"};while (defined(my$line=<$fh>)){push@args,$1,$2 if$line =~ m/^\s* ((?:--)?\w+) (?:\s*[=:]\s*|\s+) (\S+)/x}close$fh;return \@args}sub other_child_died_hook {}sub delete_child {my ($self,$pid)=@_;my$prop=$self->{'server'};return$self->other_child_died_hook($pid)if!exists$prop->{'children'}->{$pid};if ($prop->{'child_communication'}){if ($prop->{'children'}->{$pid}->{'sock'}){$prop->{'child_select'}->remove($prop->{'children'}->{$pid}->{'sock'});$prop->{'children'}->{$pid}->{'sock'}->close}}delete$prop->{'children'}->{$pid}}sub sig_pass {my ($self,$sig)=@_;for my$chld (keys %{$self->{'server'}->{'children'}}){$self->log(4,"signaling $chld with $sig");kill($sig,$chld)|| $self->log(1,"child $chld not signaled with $sig")}}sub register_sig_pass {my$self=shift;my$ref=$self->{'server'}->{'sig_passthrough'}|| [];$ref=[$ref]if!ref$ref;$self->fatal('invalid sig_passthrough')if ref$ref ne 'ARRAY';return if!@$ref;$self->log(4,"sig_passthrough option found");require Net::Server::SIG;for my$sig (map {split /\s*,\s*/,$_}@$ref){my$code=Net::Server::SIG::sig_is_registered($sig);if ($code){$self->log(2,"Installing passthrough for $sig even though it is already registered.")}else {$code=ref($SIG{$sig})eq 'CODE' ? $SIG{$sig}: undef}Net::Server::SIG::register_sig($sig=>sub {$self->sig_pass($sig);$code->($sig)if$code});$self->log(2,"Installed passthrough for $sig")}}package Net::Server::TiedHandle;sub TIEHANDLE {my$pkg=shift;return bless [@_],$pkg}sub READLINE {my$s=shift;$s->[1]? $s->[1]->($s->[0],'getline',@_): $s->[0]->getline}sub SAY {my$s=shift;$s->[1]? $s->[1]->($s->[0],'say',@_): $s->[0]->say(@_)}sub PRINT {my$s=shift;$s->[1]? $s->[1]->($s->[0],'print',@_): $s->[0]->print(@_)}sub PRINTF {my$s=shift;$s->[1]? $s->[1]->($s->[0],'printf',@_): $s->[0]->printf(@_)}sub READ {my$s=shift;$s->[1]? $s->[1]->($s->[0],'read',@_): $s->[0]->read(@_)}sub WRITE {my$s=shift;$s->[1]? $s->[1]->($s->[0],'write',@_): $s->[0]->write(@_)}sub SYSREAD {my$s=shift;$s->[1]? $s->[1]->($s->[0],'sysread',@_): $s->[0]->sysread(@_)}sub SYSWRITE {my$s=shift;$s->[1]? $s->[1]->($s->[0],'syswrite',@_): $s->[0]->syswrite(@_)}sub SEEK {my$s=shift;$s->[1]? $s->[1]->($s->[0],'seek',@_): $s->[0]->seek(@_)}sub BINMODE {}sub FILENO {}sub CLOSE {my$s=shift;$s->[1]? $s->[1]->($s->[0],'close',@_): $s->[0]->close(@_)}1;
NET_SERVER

$fatpacked{"Net/Server/Daemonize.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_DAEMONIZE';
  package Net::Server::Daemonize;use strict;use base qw(Exporter);use POSIX qw(SIGINT SIG_BLOCK SIG_UNBLOCK);our$VERSION="0.06";our@EXPORT_OK=qw(check_pid_file create_pid_file unlink_pid_file is_root_user get_uid get_gid set_uid set_gid set_user safe_fork daemonize);sub check_pid_file ($) {my$pid_file=shift;return 1 if!-e $pid_file;open my$fh,'<',$pid_file or die "Couldn't open existant pid_file \"$pid_file\" [$!]\n";my$current_pid=<$fh>;close$fh;$current_pid=($current_pid =~ /^(\d{1,10})/)? $1 : die "Couldn't find pid in existing pid_file";my$exists;if ($$==$current_pid){warn "Pid_file created by this same process. Doing nothing.\n";return 1}elsif (-d "/proc/$$"){$exists=-e "/proc/$current_pid"}elsif (kill 0,$current_pid){$exists=1}die "Pid_file already exists for running process ($current_pid)... aborting\n" if$exists;warn "Pid_file \"$pid_file\" already exists.  Overwriting!\n";unlink$pid_file || die "Couldn't remove pid_file \"$pid_file\" [$!]\n";return 1}sub create_pid_file ($) {my$pid_file=shift;check_pid_file($pid_file);open my$fh,'>',$pid_file or die "Couldn't open pid file \"$pid_file\" [$!].\n";print$fh "$$\n";close$fh;die "Pid_file \"$pid_file\" not created.\n" if!-e $pid_file;return 1}sub unlink_pid_file ($) {my$pid_file=shift;return 1 if!-e $pid_file;open my$fh,'<',$pid_file or die "Couldn't open existant pid_file \"$pid_file\" [$!]\n";my$current_pid=<$fh>;close$fh;chomp$current_pid;die "Process $$ doesn't own pid_file \"$pid_file\". Can't remove it.\n" if$current_pid ne $$;unlink($pid_file)|| die "Couldn't unlink pid_file \"$pid_file\" [$!]\n";return 1}sub is_root_user () {my$id=get_uid('root');return!defined($id)|| $<==$id || $>==$id}sub get_uid ($) {my$user=shift;my$uid=($user =~ /^(\d+)$/)? $1 : getpwnam($user);die "No such user \"$user\"\n" unless defined$uid;return$uid}sub get_gid {my@gid;for my$group (split(/[, ]+/,join(" ",@_))){if($group =~ /^\d+$/){push@gid,$group}else{my$id=getgrnam($group);die "No such group \"$group\"\n" unless defined$id;push@gid,$id}}die "No group found in arguments.\n" unless@gid;return join(" ",$gid[0],@gid)}sub set_uid {my$uid=get_uid(shift());POSIX::setuid($uid);if ($<!=$uid || $>!=$uid){$<=$>=$uid;if ($<!=$uid){die "Couldn't become uid \"$uid\": $!\n"}}return 1}sub set_gid {my$gids=get_gid(@_);my$gid=(split /\s+/,$gids)[0];eval {$)=$gids};POSIX::setgid($gid);if (!grep {$gid==$_}split /\s+/,$(){die "Couldn't become gid \"$gid\": $!\n"}return 1}sub set_user {my ($user,@group)=@_;set_gid(@group)|| return undef;set_uid($user)|| return undef;return 1}sub safe_fork () {my$sigset=POSIX::SigSet->new(SIGINT);POSIX::sigprocmask(SIG_BLOCK,$sigset)or die "Can't block SIGINT for fork: [$!]\n";my$pid=fork;die "Couldn't fork: [$!]" if!defined$pid;$SIG{'INT'}='DEFAULT';POSIX::sigprocmask(SIG_UNBLOCK,$sigset)or die "Can't unblock SIGINT for fork: [$!]\n";return$pid}sub daemonize ($$$) {my ($user,$group,$pid_file)=@_;check_pid_file($pid_file)if defined$pid_file;my$uid=get_uid($user);my$gid=get_gid($group);$gid=(split /\s+/,$gid)[0];my$pid=safe_fork();exit(0)if$pid;create_pid_file($pid_file)if defined$pid_file;chown($uid,$gid,$pid_file)if defined$pid_file;set_user($uid,$gid);open STDIN,'<','/dev/null' or die "Can't open STDIN from /dev/null: [$!]\n";open STDOUT,'>','/dev/null' or die "Can't open STDOUT to /dev/null: [$!]\n";open STDERR,'>&STDOUT' or die "Can't open STDERR to STDOUT: [$!]\n";chdir '/' or die "Can't chdir to \"/\": [$!]";POSIX::setsid();$SIG{'INT'}=sub {HUNTSMAN($pid_file)}if defined$pid_file;return 1}sub HUNTSMAN {my$path=shift;unlink$path;eval {require Unix::Syslog;Unix::Syslog::syslog(Unix::Syslog::LOG_ERR(),"Exiting on INT signal.")};exit}1;
NET_SERVER_DAEMONIZE

$fatpacked{"Net/Server/Fork.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_FORK';
  package Net::Server::Fork;use strict;use base qw(Net::Server);use Net::Server::SIG qw(register_sig check_sigs);use Socket qw(SO_TYPE SOL_SOCKET SOCK_DGRAM);use POSIX qw(WNOHANG);sub net_server_type {__PACKAGE__}sub options {my$self=shift;my$ref=$self->SUPER::options(@_);my$prop=$self->{'server'};$ref->{$_}=\$prop->{$_}for qw(max_servers max_dequeue check_for_dead check_for_dequeue);$ref->{'sig_passthrough'}=$prop->{'sig_passthrough'}=[];return$ref}sub post_configure {my$self=shift;my$prop=$self->{'server'};$self->SUPER::post_configure(@_);$prop->{'max_servers'}=256 if!defined$prop->{'max_servers'};$prop->{'check_for_dead'}=60 if!defined$prop->{'check_for_dead'};$prop->{'ppid'}=$$;$prop->{'multi_port'}=1}sub loop {my$self=shift;my$prop=$self->{'server'};$prop->{'children'}={};if ($ENV{'HUP_CHILDREN'}){my%children=map {/^(\w+)$/;$1}split(/\s+/,$ENV{'HUP_CHILDREN'});$children{$_}={status=>$children{$_},hup=>1}foreach keys%children;$prop->{'children'}=\%children}register_sig(PIPE=>'IGNORE',INT=>sub {$self->server_close()},TERM=>sub {$self->server_close()},HUP=>sub {$self->sig_hup()},CHLD=>sub {while (defined(my$chld=waitpid(-1,WNOHANG))){last if$chld <= 0;$self->delete_child($chld)}},QUIT=>sub {$self->{'server'}->{'kind_quit'}=1;$self->server_close()},TTIN=>sub {$self->{'server'}->{'max_servers'}++;$self->log(3,"Increasing max server count ($self->{'server'}->{'max_servers'})")},TTOU=>sub {$self->{'server'}->{'max_servers'}--;$self->log(3,"Decreasing max server count ($self->{'server'}->{'max_servers'})")},);$self->register_sig_pass;if ($ENV{'HUP_CHILDREN'}){while (defined(my$chld=waitpid(-1,WNOHANG))){last unless$chld > 0;$self->delete_child($chld)}}my ($last_checked_for_dead,$last_checked_for_dequeue)=(time(),time());while (1){my$n_children=grep {$_->{'status'}!~ /dequeue/}values %{$prop->{'children'}};while ($n_children > $prop->{'max_servers'}){select(undef,undef,undef,5);check_sigs();my$time=time();if ($time - $last_checked_for_dead > $prop->{'check_for_dead'}){$last_checked_for_dead=$time;$self->log(2,"Max number of children reached ($prop->{max_servers}) -- checking for alive.");for (keys %{$prop->{'children'}}){kill(0,$_)or $self->delete_child($_)}}$n_children=grep {$_->{'status'}!~ /dequeue/}values %{$prop->{'children'}}}if ($prop->{'check_for_dequeue'}){my$time=time();if ($time - $last_checked_for_dequeue > $prop->{'check_for_dequeue'}){$last_checked_for_dequeue=$time;if ($prop->{'max_dequeue'}){my$n_dequeue=grep {$_->{'status'}=~ /dequeue/}values %{$prop->{'children'}};$self->run_dequeue()if$n_dequeue < $prop->{'max_dequeue'}}}}$self->pre_accept_hook;if (!$self->accept()){last if$prop->{'_HUP'};last if$prop->{'done'};next}$self->pre_fork_hook;local $!;my$pid=fork;if (!defined$pid){$self->log(1,"Bad fork [$!]");sleep 5;next}if (!$pid){$self->run_client_connection;exit}close($prop->{'client'})if!$prop->{'udp_true'};$prop->{'children'}->{$pid}->{'status'}='processing'}}sub pre_accept_hook {};sub accept {my ($self,$class)=@_;my$prop=$self->{'server'};my@socks=$prop->{'select'}->can_read(2);if (check_sigs()){return undef if$prop->{'_HUP'};return undef if!@socks}my$sock=$socks[rand@socks];return undef if!defined$sock;if (SOCK_DGRAM==$sock->getsockopt(SOL_SOCKET,SO_TYPE)){$prop->{'udp_true'}=1;$prop->{'client'}=$sock;$prop->{'udp_peer'}=$sock->recv($prop->{'udp_data'},$sock->NS_recv_len,$sock->NS_recv_flags)}else {delete$prop->{'udp_true'};$prop->{'client'}=$sock->accept($class)|| return}}sub run_client_connection {my$self=shift;$_=undef foreach @{$self->{'server'}->{'sock'}};$SIG{'HUP'}=$SIG{'CHLD'}=$SIG{'INT'}=$SIG{'TERM'}=$SIG{'QUIT'}='DEFAULT';$SIG{'PIPE'}='IGNORE';delete$self->{'server'}->{'children'};$self->child_init_hook;$self->SUPER::run_client_connection;$self->child_finish_hook}sub close_children {my$self=shift;$self->SUPER::close_children(@_);check_sigs();register_sig(PIPE=>'DEFAULT',INT=>'DEFAULT',TERM=>'DEFAULT',QUIT=>'DEFAULT',HUP=>'DEFAULT',CHLD=>'DEFAULT',TTIN=>'DEFAULT',TTOU=>'DEFAULT',)}1;
NET_SERVER_FORK

$fatpacked{"Net/Server/HTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_HTTP';
  package Net::Server::HTTP;use strict;use base qw(Net::Server::MultiType);use Scalar::Util qw(weaken blessed);use IO::Handle ();use re 'taint';use POSIX ();use Time::HiRes qw(time);my$has_xs_parser;BEGIN {$has_xs_parser=$ENV{'USE_XS_PARSER'}&& eval {require HTTP::Parser::XS}};sub net_server_type {__PACKAGE__}sub options {my$self=shift;my$ref=$self->SUPER::options(@_);my$prop=$self->{'server'};$ref->{$_}=\$prop->{$_}for qw(timeout_header timeout_idle server_revision max_header_size access_log_format access_log_file enable_dispatch);return$ref}sub timeout_header {shift->{'server'}->{'timeout_header'}}sub timeout_idle {shift->{'server'}->{'timeout_idle'}}sub server_revision {shift->{'server'}->{'server_revision'}}sub max_header_size {shift->{'server'}->{'max_header_size'}}sub default_port {80}sub default_server_type {'PreFork'}sub post_configure {my$self=shift;$self->SUPER::post_configure(@_);my$prop=$self->{'server'};my$d={timeout_header=>15,timeout_idle=>60,server_revision=>__PACKAGE__."/$Net::Server::VERSION",max_header_size=>100_000,access_log_format=>'%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"',};$prop->{$_}=$d->{$_}foreach grep {!defined($prop->{$_})}keys %$d;$self->_init_access_log;$self->_tie_client_stdout}sub post_bind {my$self=shift;$self->SUPER::post_bind(@_);$self->_check_dispatch}sub _init_access_log {my$self=shift;my$prop=$self->{'server'};my$log=$prop->{'access_log_file'};return if!$log || $log eq '/dev/null';return if!$prop->{'access_log_format'};$prop->{'access_log_format'}=~ s/\\([\\\"nt])/$1 eq 'n' ? "\n" : $1 eq 't' ? "\t" : $1/eg;if ($log eq 'STDERR'){$prop->{'access_log_function'}=sub {print STDERR @_,"\n"}}else {open my$fh,'>>',$log or die "Could not open access_log_file \"$log\": $!";$fh->autoflush(1);push @{$prop->{'chown_files'}},$log;$prop->{'access_log_function'}=sub {print$fh @_,"\n"}}}sub _tie_client_stdout {my$self=shift;my$prop=$self->{'server'};my$copy=$self;$prop->{'tie_client_stdout'}=1;$prop->{'tied_stdout_callback'}=sub {my$client=shift;my$method=shift;alarm($copy->timeout_idle);my$request_info=$copy->{'request_info'};if ($request_info->{'headers_sent'}){my ($resp,$len);if ($method eq 'print'){$resp=$client->print(my$str=join '',@_);$len=length$str}elsif ($method eq 'printf'){$resp=$client->print(my$str=sprintf(shift,@_));$len=length$str}elsif ($method eq 'say'){$resp=$client->print(my$str=join '',@_,"\n");$len=length$str}elsif ($method eq 'write'){my$buf=shift;$buf=substr($buf,$_[1]|| 0,$_[0])if @_;$resp=$client->print($buf);$len=length$buf}elsif ($method eq 'syswrite'){$len=$resp=$client->syswrite(@_)}else {return$client->$method(@_)}$request_info->{'response_size'}=($request_info->{'response_size'}|| 0)+ $len if defined$len;return$resp}die "All headers must only be sent via print ($method)\n" if$method ne 'print';my$headers=${*$client}{'headers'}||={unparsed=>'',parsed=>''};$headers->{'unparsed'}.= join('',@_);while ($headers->{'unparsed'}=~ s/^(.*?)\015?\012//){my$line=$1;if (!$headers->{'parsed'}&& $line =~ m{^HTTP/(1.[01]) \s+ (\d+) (?: | \s+ .+)$ }x){$headers->{'status'}=[];$headers->{'parsed'}.= "$line\015\012";$prop->{'request_info'}->{'http_version'}=$1;$prop->{'request_info'}->{'response_status'}=$2}elsif (!length$line){my$s=$headers->{'status'}|| die "Premature end of script headers\n";delete ${*$client}{'headers'};$copy->send_status(@$s)if @$s;$client->print($headers->{'parsed'}."\015\012");$request_info->{'headers_sent'}=1;$request_info->{'response_header_size'}+= length($headers->{'parsed'})+2;$request_info->{'response_size'}=length($headers->{'unparsed'});return$client->print($headers->{'unparsed'})}elsif ($line !~ s/^(\w+(?:-(?:\w+))*):\s*//){my$invalid=($line =~ /(.{0,120})/)? "$1..." : '';$invalid =~ s/</&lt;/g;die "Premature end of script headers: $invalid<br>\n"}else {my$key="\u\L$1";$key =~ y/_/-/;push @{$request_info->{'response_headers'}},[$key,$line];if ($key eq 'Status' && $line =~ /^(\d+) (?:|\s+(.+?))$/ix){$headers->{'status'}=[$1,$2 || '-']}elsif ($key eq 'Location'){$headers->{'status'}=[302,'bouncing']}elsif ($key eq 'Content-type'){$headers->{'status'}||=[200,'OK']}$headers->{'parsed'}.= "$key: $line\015\012"}}};weaken$copy}sub _check_dispatch {my$self=shift;if (!$self->{'server'}->{'enable_dispatch'}){return if __PACKAGE__->can('process_request')ne $self->can('process_request');return if __PACKAGE__->can('process_http_request')ne $self->can('process_http_request')}my$app=$self->{'server'}->{'app'};if (!$app || (ref($app)eq 'ARRAY' &&!@$app)){$app=[];$self->configure({app=>$app})}my%dispatch;my$first;my@dispatch;for my$a (ref($app)eq 'ARRAY' ? @$app : $app){next if!$a;my@pairs=ref($a)eq 'ARRAY' ? @$a : ref($a)eq 'HASH' ? %$a : ref($a)eq 'CODE' ? ('/',$a): $a =~ m{^(.+?)\s+(.+)$} ? ($1,$2): $a =~ m{^(.+?)=(.+)$} ? ($1,$2): ($a,$a);for (my$i=0;$i < @pairs;$i+=2){my ($key,$val)=("/$pairs[$i]",$pairs[$i+1]);$key =~ s{/\./}{/}g;$key =~ s{(?:/[^/]+|)/\../}{/}g;$key =~ s{//+}{/}g;if ($dispatch{$key}){$self->log(2,"Already found a path matching \"$key\" - skipping.");next}$dispatch{$key}=$val;push@dispatch,$key;$first ||=$key;$self->log(2,"  Dispatch: $key => $val")}}if (@dispatch){if (!$dispatch{'/'}&& $first){$dispatch{'/'}=$dispatch{$first};push@dispatch,'/';$self->log(2,"  Dispatch: / => $dispatch{$first} (default)")}$self->{'dispatch_qr'}=join "|",map {"\Q$_\E"}@dispatch;$self->{'dispatch'}=\%dispatch}}sub http_base_headers {my$self=shift;return [[Date=>gmtime()." GMT"],[Connection=>'close'],[Server=>$self->server_revision],]}sub send_status {my ($self,$status,$msg,$body)=@_;$msg ||=($status==200)? 'OK' : '-';my$request_info=$self->{'request_info'};my$out="HTTP/1.0 $status $msg\015\012";for my$row (@{$self->http_base_headers}){$out .= "$row->[0]: $row->[1]\015\012";push @{$request_info->{'response_headers'}},$row}$self->{'server'}->{'client'}->print($out);$request_info->{'http_version'}='1.0';$request_info->{'response_status'}=$status;$request_info->{'response_header_size'}+= length$out;if ($body){push @{$request_info->{'response_headers'}},['Content-type','text/html'];$out="Content-type: text/html\015\012\015\012";$request_info->{'response_header_size'}+= length$out;$self->{'server'}->{'client'}->print($out);$request_info->{'headers_sent'}=1;$self->{'server'}->{'client'}->print($body);$request_info->{'response_size'}+= length$body}}sub send_500 {my ($self,$err)=@_;$self->send_status(500,'Internal Server Error',"<h1>Internal Server Error</h1><p>$err</p>")}sub run_client_connection {my$self=shift;local$self->{'request_info'}={};return$self->SUPER::run_client_connection(@_)}sub get_client_info {my$self=shift;$self->SUPER::get_client_info(@_);$self->clear_http_env}sub clear_http_env {my$self=shift;%ENV=()}sub process_request {my$self=shift;my$client=shift || $self->{'server'}->{'client'};my$ok=eval {local$SIG{'ALRM'}=sub {die "Server Timeout on headers\n"};alarm($self->timeout_header);$self->process_headers($client);$SIG{'ALRM'}=sub {die "Server Timeout on process\n"};alarm($self->timeout_idle);$self->process_http_request($client);alarm(0);1};alarm(0);if (!$ok){my$err="$@" || "Something happened";$self->log(1,$err);$self->send_500($err)}}sub script_name {shift->{'script_name'}|| ''}sub process_headers {my$self=shift;my$client=shift || $self->{'server'}->{'client'};$ENV{'REMOTE_PORT'}=$self->{'server'}->{'peerport'};$ENV{'REMOTE_ADDR'}=$self->{'server'}->{'peeraddr'};$ENV{'SERVER_PORT'}=$self->{'server'}->{'sockport'};$ENV{'SERVER_ADDR'}=$self->{'server'}->{'sockaddr'};$ENV{'HTTPS'}='on' if$self->{'server'}->{'client'}->NS_proto =~ /SSL/;my ($ok,$headers)=$client->read_until($self->max_header_size,qr{\n\r?\n});my ($req,$len,@parsed);die "Could not parse http headers successfully\n" if$ok!=1;if ($has_xs_parser){$len=HTTP::Parser::XS::parse_http_request($headers,\%ENV);die "Corrupt request" if$len==-1;die "Incomplete request" if$len==-2;$req="$ENV{'REQUEST_METHOD'} $ENV{'REQUEST_URI'} $ENV{'SERVER_PROTOCOL'}"}else {($req,my@lines)=split /\r?\n/,$headers;die "Missing request\n" if!defined$req;if (!defined($req)|| $req !~ m{ ^\s*(GET|POST|PUT|DELETE|PUSH|HEAD|OPTIONS)\s+(.+)\s+(HTTP/1\.[01])\s*$ }ix){die "Invalid request\n"}$ENV{'REQUEST_METHOD'}=uc $1;$ENV{'REQUEST_URI'}=$2;$ENV{'SERVER_PROTOCOL'}=$3;$ENV{'QUERY_STRING'}=$1 if$ENV{'REQUEST_URI'}=~ m{ \?(.*)$ }x;$ENV{'PATH_INFO'}=$1 if$ENV{'REQUEST_URI'}=~ m{^([^\?]+)};for my$l (@lines){my ($key,$val)=split /\s*:\s*/,$l,2;push@parsed,[$key,$val];$key=uc($key);$key='COOKIE' if$key eq 'COOKIES';$key =~ y/-/_/;$key =~ s/^\s+//;$key="HTTP_$key" if$key !~ /^CONTENT_(?:LENGTH|TYPE)$/;$val =~ s/\s+$//;if (exists$ENV{$key}){$ENV{$key}.= ", $val"}else {$ENV{$key}=$val}}$len=length$headers}$ENV{'SCRIPT_NAME'}=$self->script_name($ENV{'PATH_INFO'})|| '';my$type=$Net::Server::HTTP::ISA[0];$type=$Net::Server::MultiType::ISA[0]if$type eq 'Net::Server::MultiType';$ENV{'NET_SERVER_TYPE'}=$type;$ENV{'NET_SERVER_SOFTWARE'}=$self->server_revision;$self->_init_http_request_info($req,\@parsed,$len)}sub http_request_info {shift->{'request_info'}}sub _init_http_request_info {my ($self,$req,$parsed,$len)=@_;my$prop=$self->{'server'};my$info=$self->{'request_info'};@$info{qw(sockaddr sockport peeraddr peerport)}=@$prop{qw(sockaddr sockport peeraddr peerport)};$info->{'peerhost'}=$prop->{'peerhost'}|| $info->{'peeraddr'};$info->{'begin'}=time;$info->{'request'}=$req;$info->{'request_headers'}=$parsed;$info->{'query_string'}="?$ENV{'QUERY_STRING'}" if defined$ENV{'QUERY_STRING'};$info->{'request_protocol'}=$ENV{'HTTPS'}? 'https' : 'http';$info->{'request_method'}=$ENV{'REQUEST_METHOD'};$info->{'request_path'}=$ENV{'PATH_INFO'};$info->{'request_header_size'}=$len;$info->{'request_size'}=$ENV{'CONTENT_LENGTH'}|| 0;$info->{'remote_user'}='-'}sub http_note {my ($self,$key,$val)=@_;return$self->{'request_info'}->{'notes'}->{$key}=$val if @_ >= 3;return$self->{'request_info'}->{'notes'}->{$key}}sub http_dispatch {my ($self,$dispatch_qr,$dispatch_table)=@_;$ENV{'PATH_INFO'}=~ s{^($dispatch_qr)(?=/|$|(?<=/))}{} or die "Dispatch not found\n";$ENV{'SCRIPT_NAME'}=$1;if ($ENV{'PATH_INFO'}){$ENV{'PATH_INFO'}="/$ENV{'PATH_INFO'}" if$ENV{'PATH_INFO'}!~ m{^/};$ENV{'PATH_INFO'}=~ s/%([a-fA-F0-9]{2})/chr(hex $1)/eg}my$code=$self->{'dispatch'}->{$1};return$self->$code()if ref$code;$self->exec_cgi($code)}sub process_http_request {my ($self,$client)=@_;if (my$table=$self->{'dispatch'}){my$qr=$self->{'dispatch_qr'}or die "Dispatch was not correctly setup\n";return$self->http_dispatch($qr,$table)}return$self->http_echo}sub http_echo {my$self=shift;print "Content-type: text/html\n\n";print "<form method=post action=/bam><input type=text name=foo><input type=submit></form>\n";if (eval {require Data::Dumper}){local$Data::Dumper::Sortkeys=1;my$form={};if (eval {require CGI}){my$q=CGI->new;$form->{$_}=$q->param($_)for$q->param}print "<pre>".Data::Dumper->Dump([\%ENV,$form],['*ENV','form'])."</pre>"}}sub post_process_request {my$self=shift;my$info=$self->{'request_info'};$info->{'begin'}=time unless defined$info->{'begin'};$info->{'elapsed'}=time - $info->{'begin'};$self->SUPER::post_process_request(@_);$self->log_http_request($info)}sub log_http_request {my ($self,$info)=@_;my$prop=$self->{'server'};my$fmt=$prop->{'access_log_format'}|| return;my$log=$prop->{'access_log_function'}|| return;$log->($self->http_log_format($fmt,$info))}my%fmt_map=qw(a peeraddr A sockaddr B response_size f filename h peerhost H request_protocol l remote_logname m request_method p sockport q query_string r request s response_status u remote_user U request_path);my%fmt_code=qw(C http_log_cookie e http_log_env i http_log_header_in n http_log_note o http_log_header_out P http_log_pid t http_log_time v http_log_vhost V http_log_vhost X http_log_constat);sub http_log_format {my ($self,$fmt,$info,$orig)=@_;$fmt =~ s{ % ([<>])?                      # 1
                   (!? \d\d\d (?:,\d\d\d)* )?   # 2
                   (?: \{ ([^\}]+) \} )?        # 3
                   ([aABDfhHmpqrsTuUvVhblPtIOCeinoPtX%])  # 4
      }{
          $info = $orig if $1 && $orig && $1 eq '<';
          my $v = $2 && (substr($2,0,1) eq '!' ? index($2, $info->{'response_status'})!=-1 : index($2, $info->{'response_status'})==-1) ? '-'
                : $fmt_map{$4}  ? $info->{$fmt_map{$4}}
                : $fmt_code{$4} ? do { my $m = $fmt_code{$4}; $self->$m($info, $3, $1, $4) }
                : $4 eq 'b'     ? $info->{'response_size'} || '-' # B can be 0, b cannot
                : $4 eq 'I'     ? $info->{'request_size'} + $info->{'request_header_size'}
                : $4 eq 'O'     ? $info->{'response_size'} + $info->{'response_header_size'}
                : $4 eq 'T'     ? sprintf('%d', $info->{'elapsed'})
                : $4 eq 'D'     ? sprintf('%d', $info->{'elapsed'}/.000_001)
                : $4 eq '%'     ? '%'
                : '-';
          $v = '-' if !defined($v) || !length($v);
          $v =~ s/([^\ -\!\#-\[\]-\~])/$1 eq "\n" ? '\n' : $1 eq "\t" ? '\t' : sprintf('\x%02X', ord($1))/eg; # escape non-printable or " or \
          $v;
      }gxe;return$fmt}sub http_log_time {my ($self,$info,$fmt)=@_;return '['.POSIX::strftime($fmt || '%d/%b/%Y:%T %z',localtime($info->{'begin'})).']'}sub http_log_env {$ENV{$_[2]}}sub http_log_cookie {my ($self,$info,$var)=@_;my@c;for my$cookie (map {$_->[1]}grep {$_->[0]eq 'Cookie'}@{$info->{'request_headers'}|| []}){push@c,$1 if$cookie =~ /^\Q$var\E=(.*)/}return join ', ',@c}sub http_log_header_in {my ($self,$info,$var)=@_;return join ', ',map {$_->[1]}grep {$_->[0]eq $var}@{$info->{'request_headers'}|| []}}sub http_log_note {my ($self,$info,$var)=@_;return$self->http_note($var)}sub http_log_header_out {my ($self,$info,$var)=@_;return join ', ',map {$_->[1]}grep {$_->[0]eq $var}@{$info->{'response_headers'}|| []}}sub http_log_pid {$_[1]->{'pid'}|| $$}sub http_log_vhost {my ($self,$info,$fmt,$f_l,$type)=@_;return$self->http_log_header_in($info,'Host')|| $self->{'server'}->{'client'}->NS_host || $self->{'server'}->{'sockaddr'}}sub http_log_constat {my ($self,$info)=@_;return$info->{'headers_sent'}? '-' : 'X'}sub exec_fork_hook {}sub exec_trusted_perl {my ($self,$file)=@_;die "File $file is not executable\n" if!-x $file;local $!;my$pid=fork;die "Could not spawn child process: $!\n" if!defined$pid;$self->exec_fork_hook($pid,$file,1);if (!$pid){if (!eval {require$file}){my$err="$@" || "Error while running trusted perl script\n";$err =~ s{\s*Compilation failed in require at lib/Net/Server/HTTP\.pm line \d+\.\s*\z}{\n};die$err if!$self->{'request_info'}->{'headers_sent'};warn$err}exit}else {waitpid$pid,0;return}}sub exec_cgi {my ($self,$file)=@_;my$done=0;my$pid;Net::Server::SIG::register_sig(CHLD=>sub {while (defined(my$chld=waitpid(-1,POSIX::WNOHANG()))){$done=($? >> 8)|| -1 if$pid==$chld;last unless$chld > 0}});require IPC::Open3;require Symbol;my$in;my$out;my$err=Symbol::gensym();local $!;$pid=eval {IPC::Open3::open3($in,$out,$err,$file)}or die "Could not run external script $file: $!\n";$self->exec_fork_hook($pid,$file);my$len=$ENV{'CONTENT_LENGTH'}|| 0;my$s_in=$len ? IO::Select->new($in): undef;my$s_out=IO::Select->new($out,$err);my$printed;while (!$done){my ($o,$i,$e)=IO::Select->select($s_out,$s_in,undef);Net::Server::SIG::check_sigs();for my$fh (@$o){read($fh,my$buf,4096)|| next;if ($fh==$out){print$buf;$printed ||=1}else {print STDERR$buf}}if (@$i){my$bytes=read(STDIN,my$buf,$len);print$in $buf if$bytes;$len -= $bytes;$s_in=undef if$len <= 0}}if (!$self->{'request_info'}->{'headers_sent'}){if (!$printed){$self->send_500("Premature end of script headers")}elsif ($done > 0){$self->send_500("Script exited unsuccessfully")}}Net::Server::SIG::unregister_sig('CHLD')}1;
NET_SERVER_HTTP

$fatpacked{"Net/Server/INET.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_INET';
  package Net::Server::INET;use strict;use base qw(Net::Server);use Scalar::Util qw(blessed);sub net_server_type {__PACKAGE__}sub post_configure {my$self=shift;$self->{'server'}->{'_is_inet'}=1;$self->SUPER::post_configure();delete$self->{'server'}->{'_is_inet'}}sub pre_bind {}sub bind {}sub accept {my$self=shift;my$prop=$self->{'server'};delete$prop->{'udp_true'};1}sub get_client_info {my$self=shift;my$prop=$self->{'server'};my$sock=shift || $prop->{'client'};if (blessed($sock)&& $sock->can('NS_proto')&& $sock->NS_proto eq 'UNIX'){$self->log(3,$self->log_time." CONNECT UNIX Socket: \"".$sock->NS_port."\"");return}$prop->{'sockaddr'}=$ENV{'REMOTE_HOST'}|| '0.0.0.0';$prop->{'peeraddr'}='0.0.0.0';$prop->{'sockhost'}=$prop->{'peerhost'}='inetd.server';$prop->{'sockport'}=$prop->{'peerport'}=0;return}sub done {1}sub post_accept {my$self=shift;$self->{'server'}->{'client'}=Net::Server::INET::Handle->new()}sub hup_server {}package Net::Server::INET::Handle;use base qw(IO::Handle);use strict;sub new {my$class=shift;local*HAND;STDIN->autoflush(1);STDOUT->autoflush(1);tie*HAND,$class,*STDIN,*STDOUT or die "can't tie *HAND: $!";bless \*HAND,$class;return \*HAND}sub NS_proto {''}sub TIEHANDLE {my ($class,$in,$out)=@_;bless [\$in,\$out ],$class}sub PRINT {my$handle=shift()->[1];local*FH=$$handle;CORE::print FH @_}sub PRINTF {my$handle=shift()->[1];local*FH=$$handle;CORE::printf FH @_}sub WRITE {my$handle=shift()->[1];local*FH=$$handle;local ($\)="";$_[1]=length($_[0])unless defined $_[1];CORE::print FH substr($_[0],$_[2]|| 0,$_[1])}sub READ {my$handle=shift()->[0];local*FH=$$handle;CORE::read(FH,$_[0],$_[1],$_[2]|| 0)}sub READLINE {my$handle=shift()->[0];local*FH=$$handle;return scalar <FH>}sub GETC {my$handle=shift()->[0];local*FH=$$handle;return CORE::getc(FH)}sub EOF {my$handle=shift()->[0];local*FH=$$handle;return CORE::eof(FH)}sub OPEN {}sub CLOSE {my$self=shift;$self=undef}sub BINMODE {}sub TELL {}sub SEEK {}sub DESTROY {}sub FILENO {}sub FETCH {}sub read_until {my ($client,$bytes,$end_qr)=@_;die "One of bytes or end_qr should be defined for TCP read_until\n" if!defined($bytes)&&!defined($end_qr);my$content='';my$ok=0;while (1){$client->read($content,1,length($content));if (defined($bytes)&& length($content)>= $bytes){$ok=2;last}elsif (defined($end_qr)&& $content =~ $end_qr){$ok=1;last}}return wantarray ? ($ok,$content): $content}1;
NET_SERVER_INET

$fatpacked{"Net/Server/Log/Log/Log4perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_LOG_LOG_LOG4PERL';
  package Net::Server::Log::Log::Log4perl;use strict;use warnings;our%log4perl_map=(1=>"error",2=>"warn",3=>"info",4=>"debug");sub initialize {my ($class,$server)=@_;my$prop=$server->{'server'};require Log::Log4perl;$server->configure({log4perl_conf=>\$prop->{'log4perl_conf'},log4perl_logger=>\$prop->{'log4perl_logger'},log4perl_poll=>\$prop->{'log4perl_poll'},});die "Must specify a log4perl_conf file" if!$prop->{'log4perl_conf'};my$poll=defined($prop->{'log4perl_poll'})? $prop->{'log4perl_poll'}: "0";my$logger=$prop->{'log4perl_logger'}|| "Net::Server";if ($poll eq "0"){Log::Log4perl::init($prop->{'log4perl_conf'})}else {Log::Log4perl::init_and_watch($prop->{'log4perl_conf'},$poll)}my$l4p=Log::Log4perl->get_logger($logger);return sub {my ($level,$msg)=@_;$level=$log4perl_map{$level}|| "error";$l4p->$level($msg)}}1;
NET_SERVER_LOG_LOG_LOG4PERL

$fatpacked{"Net/Server/Log/Sys/Syslog.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_LOG_SYS_SYSLOG';
  package Net::Server::Log::Sys::Syslog;use strict;use warnings;use Sys::Syslog qw(setlogsock openlog syslog);;our%syslog_map=(0=>'err',1=>'warning',2=>'notice',3=>'info',4=>'debug');sub initialize {my ($class,$server)=@_;my$prop=$server->{'server'};$server->configure({syslog_logsock=>\$prop->{'syslog_logsock'},syslog_ident=>\$prop->{'syslog_ident'},syslog_logopt=>\$prop->{'syslog_logopt'},syslog_facility=>\$prop->{'syslog_facility'},});if (ref($prop->{'syslog_logsock'})eq 'ARRAY'){}else {if (!defined$prop->{'syslog_logsock'}){$prop->{'syslog_logsock'}=($Sys::Syslog::VERSION < 0.15)? 'unix' : ''}if ($prop->{'syslog_logsock'}=~ /^(|native|tcp|udp|unix|inet|stream|console)$/){$prop->{'syslog_logsock'}=$1}else {$prop->{'syslog_logsock'}=($Sys::Syslog::VERSION < 0.15)? 'unix' : ''}}my$ident=defined($prop->{'syslog_ident'})? $prop->{'syslog_ident'}: 'net_server';$prop->{'syslog_ident'}=($ident =~ /^([\ -~]+)$/)? $1 : 'net_server';my$opt=defined($prop->{'syslog_logopt'})? $prop->{'syslog_logopt'}: $Sys::Syslog::VERSION ge '0.15' ? 'pid,nofatal' : 'pid';$prop->{'syslog_logopt'}=($opt =~ /^( (?: (?:cons|ndelay|nowait|pid|nofatal) (?:$|[,|]) )* )/x)? $1 : 'pid';my$fac=defined($prop->{'syslog_facility'})? $prop->{'syslog_facility'}: 'daemon';$prop->{'syslog_facility'}=($fac =~ /^((\w+)($|\|))*/)? $1 : 'daemon';if ($prop->{'syslog_logsock'}){setlogsock($prop->{'syslog_logsock'})|| die "Syslog err [$!]"}if (!openlog($prop->{'syslog_ident'},$prop->{'syslog_logopt'},$prop->{'syslog_facility'})){die "Couldn't open syslog [$!]" if$prop->{'syslog_logopt'}ne 'ndelay'}return sub {my ($level,$msg)=@_;$level=$syslog_map{$level}|| $level if$level =~ /^\d+$/;syslog($level,'%s',$msg)}}sub handle_log_error {my ($class,$server,$err,$info)=@_;return$server->handle_syslog_error($err,$info)}1;
NET_SERVER_LOG_SYS_SYSLOG

$fatpacked{"Net/Server/MultiType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_MULTITYPE';
  package Net::Server::MultiType;use strict;use base qw(Net::Server);sub options {my$self=shift;my$ref=$self->SUPER::options(@_);$ref->{'server_type'}=$self->{'server'}->{'server_type'}||=[];return$ref}sub default_server_type {'Fork'}sub run {my$self=ref($_[0])? shift(): shift->new;$self->{'server'}->{'_run_args'}=[@_==1 ? %{$_[0]}: @_];$self->_initialize;my$prop=$self->{'server'};if (!defined$prop->{'server_type'}||!@{$prop->{'server_type'}}){if (my$ref=$self->can('default_server_type')&& $self->default_server_type){$prop->{'server_type'}=ref($ref)? $ref : [$ref]}}for my$type (@{$prop->{'server_type'}|| []}){next if$type eq 'MultiType';$type=($type =~ /^(\w+)$/)? $1 : next;my$pkg=($type =~ /::/)? $type : "Net::Server::$type";(my$file="$pkg.pm")=~ s{::}{/}g;eval {require$file};if ($@){warn "Couldn't become server type \"$pkg\" [$@]\n";next}if ($pkg->isa(__PACKAGE__)){my$type=$self->default_server_type || 'Single';$type=($type =~ /^(\w+)$/)? $1 : next;my$_pkg=($type =~ /::/)? $type : "Net::Server::$type";$prop->{'_recursive_multitype'}=$_pkg;(my$file="$_pkg.pm")=~ s{::}{/}g;eval {require$file}or die "Trouble becoming server type $pkg while loading default package $_pkg: $@\n";die "Recursive inheritance - Package $pkg inherits from $_pkg.\n" if$_pkg->isa($pkg);no strict 'refs';@{"${pkg}::ISA"}=($_pkg)}@Net::Server::MultiType::ISA=($pkg);last}$self->SUPER::run(@_)}1;
NET_SERVER_MULTITYPE

$fatpacked{"Net/Server/Multiplex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_MULTIPLEX';
  package Net::Server::Multiplex;use strict;use base qw(Net::Server);use Net::Server::SIG qw(register_sig check_sigs);use Carp qw(confess);eval {require IO::Multiplex;import IO::Multiplex 1.05};$@ && warn "Module IO::Multiplex is required for Multiplex.";our$VERSION=$Net::Server::VERSION;sub net_server_type {__PACKAGE__}sub loop {my$self=shift;my$prop=$self->{server};my$mux=IO::Multiplex->new;$self->{mux}=$mux;for my$sock (@{$prop->{sock}}){if (Net::Server::SOCK_DGRAM==$sock->getsockopt(Socket::SOL_SOCKET(),Socket::SO_TYPE())){$mux->add($sock)}else {$mux->listen($sock)}}$mux->set_callback_object(Net::Server::Multiplex::MUX->init($self));register_sig(PIPE=>sub {$self->log(4,"SIG$_[0] received")},INT=>sub {$self->server_close()},TERM=>sub {$self->server_close()},QUIT=>sub {$self->server_close()},HUP=>sub {$self->sig_hup()},CHLD=>sub {$self->sig_chld()},);if (defined$prop->{check_for_dequeue}){$mux->set_timeout($prop->{sock}->[0],$prop->{check_for_dequeue})}$mux->loop(sub {my ($rdready,$wrready)=@_;check_sigs();$mux->endloop if$prop->{_HUP}})}sub sig_hup {my$self=shift;my$prop=$self->{server};if (my$mux=$self->{mux}){for my$sock (@{$prop->{sock}}){$mux->remove($sock)}}return$self->SUPER::sig_hup(@_)}sub setup_client_connection {my ($self,$mux)=@_;my$prop=$self->{server};$prop->{requests}++;if (!$prop->{no_client_stdout}){*STDIN=\*{$prop->{client}}}$self->get_client_info;$self->post_accept_hook;unless($self->allow_deny && $self->allow_deny_hook){$self->request_denied_hook;if (!$prop->{no_client_stdout}){close (STDOUT)}return 0}return 1}sub run_dequeue {confess "&$Net::Server::Multiplex::MUX::ISA[0]\::run_dequeue never defined"}sub mux_connection {}sub mux_input {confess "&$Net::Server::Multiplex::MUX::ISA[0]\::mux_input never defined"}sub mux_eof {}sub mux_close {}sub mux_timeout {confess "&$Net::Server::Multiplex::MUX::ISA[0]\::mux_timeout never defined"}package Net::Server::Multiplex::MUX;use strict;our$VERSION=$Net::Server::Multiplex::VERSION;our@ISA=qw(Net::Server::Multiplex);sub init {my$package=shift;my$net_server=shift;@ISA=(ref$net_server);my$self=bless {net_server=>$net_server,}=>$package;return$self}sub new {my$package=shift;my$net_server=shift;my$self=bless {net_server=>$net_server,peeraddr=>$net_server->{server}->{peeraddr},connected=>time,},$package;return$self}sub log {shift->{net_server}->log(@_)}sub mux_connection {my ($self,$mux,$fh)=@_;my$net_server=$self->{net_server};$net_server->{server}->{client}=$fh;$self->_link_stdout($mux,$fh);if ($net_server->setup_client_connection($mux)){my$client_object=Net::Server::Multiplex::MUX->new($net_server,$fh);$mux->set_callback_object($client_object,$fh);$client_object->SUPER::mux_connection($mux,$fh)}$self->_unlink_stdout();return}sub mux_input {my ($self,$mux,$fh,$in_ref)=@_;$self->_link_stdout($mux,$fh);$self->SUPER::mux_input($mux,$fh,$in_ref);$self->_unlink_stdout();return}sub mux_eof {my ($self,$mux,$fh,$in_ref)=@_;$self->_link_stdout($mux,$fh);$self->SUPER::mux_eof($mux,$fh,$in_ref);$self->_unlink_stdout();$mux->shutdown($fh,1);return}sub mux_close {my ($self,$mux,$fh)=@_;$self->{net_server}->post_process_request_hook;$self->SUPER::mux_close($mux,$fh);return}sub mux_timeout {my ($self,$mux,$fh)=@_;if (my$check=$self->{net_server}->{server}->{check_for_dequeue}){$self->{net_server}->run_dequeue();$mux->set_timeout($fh,$check)}else {$self->_link_stdout($mux,$fh);$self->SUPER::mux_timeout($mux,$fh);$self->_unlink_stdout()}return}sub _link_stdout {my ($self,$mux,$fh)=@_;return if$self->{net_server}->{server}->{no_client_stdout};if (tied *$fh){tie (*STDOUT,(ref tied *$fh),$mux,$fh)}else {*STDOUT=*$fh}}sub _unlink_stdout {my$self=shift;return if$self->{net_server}->{server}->{no_client_stdout};my$x=tied*STDOUT;if ($x){undef$x;untie*STDOUT}}1;
NET_SERVER_MULTIPLEX

$fatpacked{"Net/Server/PSGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_PSGI';
  package Net::Server::PSGI;use strict;use base qw(Net::Server::HTTP);sub net_server_type {__PACKAGE__}sub options {my$self=shift;my$ref=$self->SUPER::options(@_);my$prop=$self->{'server'};$ref->{$_}=\$prop->{$_}for qw(app);return$ref}sub post_configure {my$self=shift;my$prop=$self->{'server'};$prop->{'log_handle'}=IO::Handle->new;$prop->{'log_handle'}->fdopen(fileno(STDERR),"w");$prop->{'no_client_stdout'}=1;$self->SUPER::post_configure(@_)}sub _tie_client_stdout {}sub process_request {my$self=shift;local$SIG{'ALRM'}=sub {die "Server Timeout\n"};my$ok=eval {alarm($self->timeout_header);$self->process_headers;alarm($self->timeout_idle);my$env=\%ENV;$env->{'psgi.version'}=[1,0];$env->{'psgi.url_scheme'}=($ENV{'HTTPS'}&& $ENV{'HTTPS'}eq 'on')? 'https' : 'http';$env->{'psgi.input'}=$self->{'server'}->{'client'};$env->{'psgi.errors'}=$self->{'server'}->{'log_handle'};$env->{'psgi.multithread'}=1;$env->{'psgi.multiprocess'}=1;$env->{'psgi.nonblocking'}=1;$env->{'psgi.streaming'}=1;local%ENV;$self->process_psgi_request($env);alarm(0);1};alarm(0);if (!$ok){my$err="$@" || "Something happened";$self->send_500($err);die$err}}sub process_psgi_request {my ($self,$env)=@_;my$app=$self->find_psgi_handler($env);my$resp=$app->($env);return$resp->(sub {my$resp=shift;$self->print_psgi_headers($resp->[0],$resp->[1]);return$self->{'server'}->{'client'}if @$resp==2;return$self->print_psgi_body($resp->[2])})if ref($resp)eq 'CODE';$self->print_psgi_headers($resp->[0],$resp->[1]);$self->print_psgi_body($resp->[2])}sub find_psgi_handler {shift->app || \&psgi_echo_handler}sub app {my$self=shift;$self->{'server'}->{'app'}=shift if @_;my$app=$self->{'server'}->{'app'};if (!ref($app)&& $app){$app=$self->{'server'}->{'app'}=eval {require CGI::Compile;CGI::Compile->compile($app)}|| die "Failed to compile app with CGI::Compile"}return$app}sub print_psgi_headers {my ($self,$status,$headers)=@_;$self->send_status($status);my$request_info=$self->{'request_info'};my$out='';for my$i (0 .. @{$headers || []}/ 2 - 1){my$key="\u\L$headers->[$i*2]";my$val=$headers->[$i*2 + 1];$key =~ y/_/-/;$out .= "$key: $val\015\012";push @{$request_info->{'response_headers'}},[$key,$val]}$out .= "\015\012";$request_info->{'response_header_size'}+= length$out;$self->{'server'}->{'client'}->print($out);$request_info->{'headers_sent'}=1}sub print_psgi_body {my ($self,$body)=@_;my$client=$self->{'server'}->{'client'};my$request_info=$self->{'request_info'};if (ref$body eq 'ARRAY'){for my$chunk (@$body){$client->print($chunk);$request_info->{'response_size'}+= length$chunk}}elsif (blessed($body)&& $body->can('getline')){while (defined(my$chunk=$body->getline)){$client->print($chunk);$request_info->{'response_size'}+= length$chunk}}else {while (defined(my$chunk=<$body>)){$client->print($chunk);$request_info->{'response_size'}+= length$chunk}}}sub psgi_echo_handler {my$env=shift;my$txt=qq{<form method="post" action="/bam"><input type="text" name="foo"><input type="submit"></form>\n};if (eval {require Data::Dumper}){local$Data::Dumper::Sortkeys=1;my$form={};if (eval {require CGI::PSGI}){my$q=CGI::PSGI->new($env);$form->{$_}=$q->param($_)for$q->param}$txt .= "<pre>".Data::Dumper->Dump([$env,$form],['env','form'])."</pre>"}return [200,['Content-type','text/html'],[$txt]]}sub exec_cgi {die "Not implemented"}sub exec_trusted_perl {die "Not implemented"}1;
NET_SERVER_PSGI

$fatpacked{"Net/Server/PreFork.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_PREFORK';
  package Net::Server::PreFork;use strict;use base qw(Net::Server::PreForkSimple);use Net::Server::SIG qw(register_sig check_sigs);use POSIX qw(WNOHANG);use IO::Select ();use Time::HiRes qw(time);sub net_server_type {__PACKAGE__}sub options {my$self=shift;my$ref=$self->SUPER::options(@_);my$prop=$self->{'server'};$ref->{$_}=\$prop->{$_}for qw(min_servers min_spare_servers max_spare_servers spare_servers check_for_waiting child_communication check_for_spawn min_child_ttl);return$ref}sub post_configure {my$self=shift;my$prop=$self->{'server'};$self->SUPER::post_configure;my$d={min_servers=>5,min_spare_servers=>2,max_spare_servers=>10,check_for_waiting=>10,check_for_spawn=>30,min_child_ttl=>10,};$prop->{'min_servers'}=$prop->{'max_servers'}if!!defined($prop->{'min_servers'})&& $d->{'min_servers'}> $prop->{'max_servers'};$prop->{'max_spare_servers'}=$prop->{'max_servers'}- 1 if!defined($prop->{'max_spare_servers'})&& $d->{'max_spare_servers'}>= $prop->{'max_servers'};if (!defined$prop->{'min_spare_servers'}){my$min=defined($prop->{'min_servers'})? $prop->{'min_servers'}: $d->{'min_servers'};$prop->{'min_spare_servers'}=$min if$prop > $min}for (keys %$d){$prop->{$_}=$d->{$_}if!defined($prop->{$_})|| $prop->{$_}!~ /^\d+(?:\.\d+)?$/}if($prop->{'max_spare_servers'}>= $prop->{'max_servers'}){$self->fatal("Error: \"max_spare_servers\" must be less than \"max_servers\"")}if ($prop->{'min_spare_servers'}){$self->fatal("Error: \"min_spare_servers\" ($prop->{'min_spare_servers'}) must be less than \"$_\" ($prop->{$_})")for grep {$prop->{'min_spare_servers'}> $prop->{$_}}qw(min_servers max_spare_servers)}}sub loop {my$self=shift;my$prop=$self->{'server'};pipe(my$read,my$write);$read->autoflush(1);$write->autoflush(1);$prop->{'_READ'}=$read;$prop->{'_WRITE'}=$write;$prop->{'child_select'}=IO::Select->new($read);$prop->{'children'}={};$prop->{'reaped_children'}={};if ($ENV{'HUP_CHILDREN'}){for my$line (split /\n/,$ENV{'HUP_CHILDREN'}){my ($pid,$status)=($line =~ /^(\d+)\t(\w+)$/)? ($1,$2): next;$prop->{'children'}->{$pid}={status=>$status,hup=>1}}}$prop->{'tally'}={time=>time(),waiting=>scalar(grep {$_->{'status'}eq 'waiting'}values %{$prop->{'children'}}),processing=>scalar(grep {$_->{'status'}eq 'processing'}values %{$prop->{'children'}}),dequeue=>scalar(grep {$_->{'status'}eq 'dequeue'}values %{$prop->{'children'}}),};my$start=$prop->{'min_servers'};$self->log(3,"Beginning prefork ($start processes)");$self->run_n_children($start);$self->run_parent}sub kill_n_children {my ($self,$n)=@_;my$prop=$self->{'server'};return unless$n > 0;my$time=time;return unless$time - $prop->{'last_kill'}> 10;$prop->{'last_kill'}=$time;$self->log(3,"Killing \"$n\" children");for my$pid (keys %{$prop->{'children'}}){my$child=$prop->{'children'}->{$pid};next if$child->{'status'}ne 'waiting';$n--;if (!kill('HUP',$pid)){$self->delete_child($pid)}last if$n <= 0}}sub run_n_children {my ($self,$n)=@_;my$prop=$self->{'server'};return unless$n > 0;$self->run_n_children_hook($n);my ($parentsock,$childsock);$self->log(3,"Starting \"$n\" children");$prop->{'last_start'}=time();for (1 .. $n){if ($prop->{'child_communication'}){require IO::Socket::UNIX;($parentsock,$childsock)=IO::Socket::UNIX->socketpair(IO::Socket::AF_UNIX,IO::Socket::SOCK_STREAM,IO::Socket::PF_UNSPEC)}$self->pre_fork_hook;local $!;my$pid=fork;if (!defined$pid){if ($prop->{'child_communication'}){$parentsock->close();$childsock->close()}$self->fatal("Bad fork [$!]")}if ($pid){if($prop->{'child_communication'}){$prop->{'child_select'}->add($parentsock);$prop->{'children'}->{$pid}->{'sock'}=$parentsock}$prop->{'children'}->{$pid}->{'status'}='waiting';$prop->{'tally'}->{'waiting'}++}else {if ($prop->{'child_communication'}){$prop->{'parent_sock'}=$childsock}$self->run_child}}}sub run_n_children_hook {}sub run_child {my$self=shift;my$prop=$self->{'server'};$SIG{'INT'}=$SIG{'TERM'}=$SIG{'QUIT'}=sub {$self->child_finish_hook;exit};$SIG{'PIPE'}='IGNORE';$SIG{'CHLD'}='DEFAULT';$SIG{'HUP'}=sub {if (!$prop->{'connected'}){$self->child_finish_hook;exit}$prop->{'SigHUPed'}=1};if ($prop->{'serialize'}eq 'flock'){open$prop->{'lock_fh'},">",$prop->{'lock_file'}or $self->fatal("Couldn't open lock file \"$prop->{'lock_file'}\"[$!]")}$self->log(4,"Child Preforked ($$)");delete @{$prop}{qw(children tally last_start last_process)};$self->child_init_hook;my$write=$prop->{'_WRITE'};while ($self->accept()){$prop->{'connected'}=1;print$write "$$ processing\n";my$ok=eval {$self->run_client_connection;1};if (!$ok){print$write "$$ exiting\n";die $@}last if$self->done;$prop->{'connected'}=0;print$write "$$ waiting\n"}$self->child_finish_hook;print$write "$$ exiting\n";exit}sub run_parent {my$self=shift;my$prop=$self->{'server'};my$id;$self->log(4,"Parent ready for children.");my$read_fh=$prop->{'_READ'};@{$prop}{qw(last_checked_for_dead last_checked_for_waiting last_checked_for_dequeue last_process last_kill)}=(time)x 5;register_sig(PIPE=>'IGNORE',INT=>sub {$self->server_close()},TERM=>sub {$self->server_close()},HUP=>sub {$self->sig_hup()},CHLD=>sub {while (defined(my$chld=waitpid(-1,WNOHANG))){last unless$chld > 0;$self->{'reaped_children'}->{$chld}=1}},QUIT=>sub {$self->{'server'}->{'kind_quit'}=1;$self->server_close()},TTIN=>sub {$self->{'server'}->{$_}++ for qw(min_servers max_servers);$self->log(3,"Increasing server count ($self->{'server'}->{'max_servers'})")},TTOU=>sub {$self->{'server'}->{$_}-- for qw(min_servers max_servers);$self->log(3,"Decreasing server count ($self->{'server'}->{'max_servers'})")},);$self->register_sig_pass;if ($ENV{'HUP_CHILDREN'}){while (defined(my$chld=waitpid(-1,WNOHANG))){last unless$chld > 0;$self->{'reaped_children'}->{$chld}=1}}while (1){my@fh=$prop->{'child_select'}->can_read($prop->{'check_for_waiting'});if (check_sigs()){last if$prop->{'_HUP'}}$self->idle_loop_hook(\@fh);if (!@fh){$self->coordinate_children();next}for my$fh (@fh){if ($fh!=$read_fh){$self->child_is_talking_hook($fh);next}my$line=<$fh>;next if!defined$line;last if$self->parent_read_hook($line);next if$line !~ /^(\d+)\ +(waiting|processing|dequeue|exiting)$/;my ($pid,$status)=($1,$2);if (my$child=$prop->{'children'}->{$pid}){if ($status eq 'exiting'){$self->delete_child($pid)}else {my$old_status=$child->{'status'}|| $self->log(2,"No status for $pid when changing to $status");--$prop->{'tally'}->{$old_status}>= 0 || $self->log(2,"Tally for $status < 0 changing pid $pid from $old_status to $status");$child->{'status'}=$status;++$prop->{'tally'}->{$status};$prop->{'last_process'}=time()if$status eq 'processing'}}}$self->coordinate_children()}}sub run_dequeue {my$self=shift;$self->SUPER::run_dequeue;$self->{'server'}->{'tally'}->{'dequeue'}++}sub coordinate_children {my$self=shift;my$prop=$self->{'server'};my$time=time();for my$pid (keys %{$self->{'reaped_children'}}){delete$self->{'reaped_children'}->{$pid};next if!$prop->{'children'}->{$pid};$self->delete_child($pid)}my$tally=$prop->{'tally'}||={};if ($time - $tally->{'time'}> $prop->{'check_for_spawn'}){my$w=$tally->{'waiting'};my$p=$tally->{'processing'};$tally=$prop->{'tally'}={time=>$time,waiting=>0,processing=>0,dequeue=>0,};for (values %{$prop->{'children'}}){$tally->{$_->{'status'}}++}$w -= $tally->{'waiting'};$p -= $tally->{'processing'};$self->log(3,"Processing diff ($p), Waiting diff ($w)")if$p || $w}my$total=$tally->{'waiting'}+ $tally->{'processing'};if ($total < $prop->{'min_servers'}){$self->run_n_children($prop->{'min_servers'}- $total)}elsif ($tally->{'waiting'}< $prop->{'min_spare_servers'}&& $total < $prop->{'max_servers'}){my$n1=$prop->{'min_spare_servers'}- $tally->{'waiting'};my$n2=$prop->{'max_servers'}- $total;$self->run_n_children(($n2 > $n1)? $n1 : $n2)}if ($time - $prop->{'last_checked_for_waiting'}> $prop->{'check_for_waiting'}){$prop->{'last_checked_for_waiting'}=$time;if ($tally->{'waiting'}> $prop->{'max_spare_servers'}&& $total > $prop->{'min_servers'}){if ($time - $prop->{'last_start'}> $prop->{'min_child_ttl'}){my$n1=$tally->{'waiting'}- $prop->{'max_spare_servers'};my$n2=$total - $prop->{'min_servers'};$self->kill_n_children(($n2 > $n1)? $n1 : $n2)}}elsif ($total > $prop->{'max_servers'}){$self->kill_n_children($total - $prop->{'max_servers'})}}if ($time - $prop->{'last_checked_for_dead'}> $prop->{'check_for_dead'}){$prop->{'last_checked_for_dead'}=$time;for my$pid (keys %{$prop->{'children'}}){kill(0,$pid)|| $self->delete_child($pid)}}if ($time - $prop->{'last_process'}> 30 && $tally->{'waiting'}> $prop->{'min_spare_servers'}){my$n1=$tally->{'waiting'}- $prop->{'min_spare_servers'};my$n2=$total - $prop->{'min_servers'};$self->kill_n_children(($n2 > $n1)? $n1 : $n2)}if (defined$prop->{'check_for_dequeue'}){if ($time - $prop->{'last_checked_for_dequeue'}> $prop->{'check_for_dequeue'}){$prop->{'last_checked_for_dequeue'}=$time;if (defined($prop->{'max_dequeue'})&& $tally->{'dequeue'}< $prop->{'max_dequeue'}){$self->run_dequeue()}}}}sub delete_child {my ($self,$pid)=@_;my$prop=$self->{'server'};my$child=$prop->{'children'}->{$pid};if (!$child){$self->log(2,"Attempt to delete already deleted child $pid");return}return if!exists$prop->{'children'}->{$pid};my$status=$child->{'status'}|| $self->log(2,"No status for $pid when deleting child");--$prop->{'tally'}->{$status}>= 0 || $self->log(2,"Tally for $status < 0 deleting pid $pid");$prop->{'tally'}->{'time'}=0 if$child->{'hup'};$self->SUPER::delete_child($pid)}sub parent_read_hook {}sub child_is_talking_hook {}1;
NET_SERVER_PREFORK

$fatpacked{"Net/Server/PreForkSimple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_PREFORKSIMPLE';
  package Net::Server::PreForkSimple;use strict;use base qw(Net::Server);use Net::Server::SIG qw(register_sig check_sigs);use POSIX qw(WNOHANG EINTR);use Fcntl ();sub net_server_type {__PACKAGE__}sub options {my$self=shift;my$ref=$self->SUPER::options(@_);my$prop=$self->{'server'};$ref->{$_}=\$prop->{$_}for qw(max_servers max_requests max_dequeue check_for_dead check_for_dequeue lock_file serialize);$ref->{'sig_passthrough'}=$prop->{'sig_passthrough'}=[];return$ref}sub post_configure {my$self=shift;my$prop=$self->{'server'};$self->SUPER::post_configure;my$d={max_servers=>50,max_requests=>1000,check_for_dead=>30,};for (keys %$d){$prop->{$_}=$d->{$_}unless defined($prop->{$_})&& $prop->{$_}=~ /^\d+$/}$prop->{'ppid'}=$$}sub post_bind {my$self=shift;my$prop=$self->{'server'};$self->SUPER::post_bind;if ($prop->{'multi_port'}&& $prop->{'serialize'}&& $prop->{'serialize'}eq 'none'){$self->log(2,"Passed serialize value of none is incompatible with multiple ports - using default serialize");delete$prop->{'serialize'}}if (!$prop->{'serialize'}|| $prop->{'serialize'}!~ /^(flock|semaphore|pipe|none)$/i){$prop->{'serialize'}=($^O eq 'MSWin32')? 'pipe' : 'flock'}$prop->{'serialize'}=~ tr/A-Z/a-z/;if ($prop->{'serialize'}eq 'flock'){$self->log(3,"Setting up serialization via flock");if (defined$prop->{'lock_file'}){$prop->{'lock_file_unlink'}=undef}else {$prop->{'lock_file'}=eval {require File::Temp}? File::Temp::tmpnam(): POSIX::tmpnam();$prop->{'lock_file_unlink'}=1}}elsif ($prop->{'serialize'}eq 'semaphore'){$self->log(3,"Setting up serialization via semaphore");require IPC::SysV;require IPC::Semaphore;my$s=IPC::Semaphore->new(IPC::SysV::IPC_PRIVATE(),1,IPC::SysV::S_IRWXU()| IPC::SysV::IPC_CREAT())or $self->fatal("Semaphore error [$!]");$s->setall(1)or $self->fatal("Semaphore create error [$!]");$prop->{'sem'}=$s}elsif ($prop->{'serialize'}eq 'pipe'){$self->log(3,"Setting up serialization via pipe");pipe(my$waiting,my$ready);$ready->autoflush(1);$waiting->autoflush(1);$prop->{'_READY'}=$ready;$prop->{'_WAITING'}=$waiting;print$ready "First\n"}elsif ($prop->{'serialize'}eq 'none'){$self->log(3,"Using no serialization")}else {$self->fatal("Unknown serialization type \"$prop->{'serialize'}\"")}}sub loop {my$self=shift;my$prop=$self->{'server'};$prop->{'children'}={};if ($ENV{'HUP_CHILDREN'}){my%children=map {/^(\w+)$/;$1}split(/\s+/,$ENV{'HUP_CHILDREN'});$children{$_}={status=>$children{$_},hup=>1}foreach keys%children;$prop->{'children'}=\%children}$self->log(3,"Beginning prefork ($prop->{'max_servers'} processes)");$self->run_n_children($prop->{'max_servers'});$self->run_parent}sub run_n_children {my ($self,$n)=@_;return if$n <= 0;my$prop=$self->{'server'};$self->run_n_children_hook;$self->log(3,"Starting \"$n\" children");for (1 .. $n){$self->pre_fork_hook;local $!;my$pid=fork;$self->fatal("Bad fork [$!]")if!defined$pid;if ($pid){$prop->{'children'}->{$pid}->{'status'}='processing'}else {$self->run_child}}}sub run_n_children_hook {}sub run_child {my$self=shift;my$prop=$self->{'server'};$SIG{'INT'}=$SIG{'TERM'}=$SIG{'QUIT'}=sub {$self->child_finish_hook;exit};$SIG{'PIPE'}='IGNORE';$SIG{'CHLD'}='DEFAULT';$SIG{'HUP'}=sub {if (!$prop->{'connected'}){$self->child_finish_hook;exit}$prop->{'SigHUPed'}=1};my$needs_lock=($prop->{'serialize'}eq 'flock')? 1 : 0;if ($needs_lock){open($prop->{'lock_fh'},">",$prop->{'lock_file'})or $self->fatal("Couldn't open lock file \"$prop->{'lock_file'}\"[$!]")}$self->log(4,"Child Preforked ($$)");delete$prop->{'children'};$self->child_init_hook;while ($self->accept()){$prop->{'connected'}=1;$self->run_client_connection;$prop->{'connected'}=0;last if$self->done}$self->child_finish_hook;close($prop->{'lock_fh'})if$needs_lock && $prop->{'lock_fh'};$self->log(4,"Child leaving ($prop->{'max_requests'})");exit}sub is_prefork {1}sub accept {my$self=shift;my$prop=$self->{'server'};if ($prop->{'serialize'}eq 'flock'){while (!flock$prop->{'lock_fh'},Fcntl::LOCK_EX()){next if $!==EINTR;$self->fatal("Couldn't get lock on file \"$prop->{'lock_file'}\" [$!]")}my$v=$self->SUPER::accept();flock$prop->{'lock_fh'},Fcntl::LOCK_UN();return$v}elsif ($prop->{'serialize'}eq 'semaphore'){$prop->{'sem'}->op(0,-1,IPC::SysV::SEM_UNDO())or $self->fatal("Semaphore Error [$!]");my$v=$self->SUPER::accept();$prop->{'sem'}->op(0,1,IPC::SysV::SEM_UNDO())or $self->fatal("Semaphore Error [$!]");return$v}elsif ($prop->{'serialize'}eq 'pipe'){my$waiting=$prop->{'_WAITING'};scalar <$waiting>;my$v=$self->SUPER::accept();print {$prop->{'_READY'}}"Next!\n";return$v}else {my$v=$self->SUPER::accept();return$v}}sub done {my$self=shift;my$prop=$self->{'server'};$prop->{'done'}=shift if @_;return 1 if$prop->{'done'};return 1 if$prop->{'requests'}>= $prop->{'max_requests'};return 1 if$prop->{'SigHUPed'};if (!kill 0,$prop->{'ppid'}){$self->log(3,"Parent process gone away. Shutting down");return 1}}sub run_parent {my$self=shift;my$prop=$self->{'server'};$self->log(4,"Parent ready for children.");$prop->{'last_checked_for_dead'}=$prop->{'last_checked_for_dequeue'}=time();register_sig(PIPE=>'IGNORE',INT=>sub {$self->server_close()},TERM=>sub {$self->server_close()},HUP=>sub {$self->sig_hup()},CHLD=>sub {while (defined(my$chld=waitpid(-1,WNOHANG))){last unless$chld > 0;$self->delete_child($chld)}},QUIT=>sub {$self->{'server'}->{'kind_quit'}=1;$self->server_close()},TTIN=>sub {$self->{'server'}->{'max_servers'}++;$self->log(3,"Increasing max server count ($self->{'server'}->{'max_servers'})")},TTOU=>sub {$self->{'server'}->{'max_servers'}--;$self->log(3,"Decreasing max server count ($self->{'server'}->{'max_servers'})");if (defined(my$pid=each %{$prop->{'children'}})){$self->delete_child($pid)if!kill('HUP',$pid)}},);$self->register_sig_pass;if ($ENV{'HUP_CHILDREN'}){while (defined(my$chld=waitpid(-1,WNOHANG))){last unless$chld > 0;$self->delete_child($chld)}}while (1){select undef,undef,undef,10;if (check_sigs()){last if$prop->{'_HUP'}}$self->idle_loop_hook();my$time=time();if ($time - $prop->{'last_checked_for_dead'}> $prop->{'check_for_dead'}){$prop->{'last_checked_for_dead'}=$time;for (keys %{$prop->{'children'}}){kill(0,$_)or $self->delete_child($_)}}my$total_n=0;my$total_d=0;for (values %{$prop->{'children'}}){if($_->{'status'}eq 'dequeue'){$total_d ++}else{$total_n ++}}if($prop->{'max_servers'}> $total_n){$self->run_n_children($prop->{'max_servers'}- $total_n)}if(defined$prop->{'check_for_dequeue'}){if($time - $prop->{'last_checked_for_dequeue'}> $prop->{'check_for_dequeue'}){$prop->{'last_checked_for_dequeue'}=$time;if(defined($prop->{'max_dequeue'})&& $total_d < $prop->{'max_dequeue'}){$self->run_dequeue()}}}}}sub idle_loop_hook {}sub close_children {my$self=shift;$self->SUPER::close_children(@_);check_sigs();register_sig(PIPE=>'DEFAULT',INT=>'DEFAULT',TERM=>'DEFAULT',QUIT=>'DEFAULT',HUP=>'DEFAULT',CHLD=>'DEFAULT',TTIN=>'DEFAULT',TTOU=>'DEFAULT',)}1;
NET_SERVER_PREFORKSIMPLE

$fatpacked{"Net/Server/Proto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_PROTO';
  package Net::Server::Proto;use strict;use warnings;use Socket ();my$requires_ipv6=0;sub parse_info {my ($class,$port,$host,$proto,$ipv,$server)=@_;my$info;if (ref($port)eq 'HASH'){die "Missing port in hashref passed in port argument.\n" if!$port->{'port'};$info=$port}else {$info={};$info->{'unix_type'}=$1 if$port =~ s{ (?<=[\w*\]]) [,|\s:/]+ (sock_stream|sock_dgram) \b }{}x;$ipv=$1 if$port =~ s{ (?<=[\w*\]]) [,|\s:/]+ IPv([*\d]+) }{}xi;$ipv .= $1 if$port =~ s{ (?<=[\w*\]]) [,|\s:/]+ IPv([*\d]+) }{}xi;$proto=$1 if$port =~ s{ (?<=[\w*\]]) [,|\s:/]+ (tcp|udp|ssl|ssleay|unix|unixdgram|\w+(?: ::\w+)+) $ }{}xi || $port =~ s{ / (\w+) $ }{}x;$host=$1 if$port =~ s{ ^ (.*?)      [,|\s:]+  (?= \w+ $) }{}x;$info->{'port'}=$port}$info->{'port'}||=0;$info->{'host'}||=(defined($host)&& length($host))? $host : '*';$ipv=$1 if$info->{'host'}=~ s{ (?<=[\w*\]]) [,|\s:/]+ IPv([*\d]+) }{}xi;$ipv .= $1 if$info->{'host'}=~ s{ (?<=[\w*\]]) [,|\s:/]+ IPv([*\d]+) }{}xi;if ($info->{'host'}=~ m{^ \[ ([\w/.\-:]+ | \*?) \] $ }x){$info->{'host'}=length($1)? $1 : '*'}elsif ($info->{'host'}=~ m{^    ([\w/.\-:]+ | \*?)    $ }x){$info->{'host'}=$1}else {$server->fatal("Could not determine host from \"$info->{'host'}\"")}$info->{'proto'}||=$proto || 'tcp';$ipv=$1 if$info->{'proto'}=~ s{ (?<=[\w*\]]) [,|\s:/]+ IPv([*\d]+) }{}xi;$ipv .= $1 if$info->{'proto'}=~ s{ (?<=[\w*\]]) [,|\s:/]+ IPv([*\d]+) }{}xi;if ($info->{'proto'}=~ /^(\w+ (?:::\w+)*)$/x){$info->{'proto'}=$1}else {$server->fatal("Could not determine proto from \"$proto\"")}$proto=lc$info->{'proto'};if ($info->{'proto'}=~ /^UNIX/i){return ({%$info,ipv=>'*'})}$ipv=$info->{'ipv'}|| $ipv || $ENV{'IPV'}|| '';$ipv=join '',@$ipv if ref($ipv)eq 'ARRAY';$server->fatal("Invalid ipv parameter - must contain 4, 6, or *")if$ipv && $ipv !~ /[46*]/;my@_info;if (!$ipv || $ipv =~ /[*]/){my@rows=eval {$class->get_addr_info(@$info{qw(host port proto)})};$server->fatal($@ || "Could not find valid addresses for [$info->{'host'}]:$info->{'port'} with ipv set to '*'")if!@rows;for my$row (@rows){my ($host,$port,$ipv,$warn)=@$row;push@_info,{host=>$host,port=>$port,ipv=>$ipv,proto=>$info->{'proto'},$warn ? (warn=>$warn): ()};$requires_ipv6++ if$ipv ne '4' && $proto ne 'ssl'}if (@rows > 1 && $rows[0]->[1]==0){$server->log(2,"Determining auto-assigned port (0) for host $info->{'host'} (prebind)");my$sock=$class->object($_info[-1],$server);$sock->connect($server);@$_{qw(port orig_port)}=($sock->NS_port,0)for@_info}for my$_info (@_info){$server->log(2,"Resolved [$info->{'host'}]:$info->{'port'} to [$_info->{'host'}]:$_info->{'port'}, IPv$_info->{'ipv'}")if$_info->{'host'}ne $info->{'host'}|| $_info->{'port'}ne $info->{'port'};$server->log(2,delete$_info->{'warn'})if$_info->{'warn'}}}elsif ($ipv =~ /6/ || $info->{'host'}=~ /:/){push@_info,{%$info,ipv=>'6'};$requires_ipv6++ if$proto ne 'ssl';push@_info,{%$info,ipv=>'4'}if$ipv =~ /4/ && $info->{'host'}!~ /:/}else {push@_info,{%$info,ipv=>'4'}}return@_info}sub get_addr_info {my ($class,$host,$port,$proto)=@_;$host='*' if!defined$host;$port=0 if!defined$port;$proto='tcp' if!defined$proto;return ([$host,$port,'*'])if$proto =~ /UNIX/i;$port=(getservbyname($port,$proto))[2]or die "Could not determine port number from host [$host]:$_[2]\n" if$port =~ /\D/;my@info;if ($host =~ /^\d+(?:\.\d+){3}$/){my$addr=Socket::inet_aton($host)or die "Unresolveable host [$host]:$port: invalid ip\n";push@info,[Socket::inet_ntoa($addr),$port,4]}elsif (!$ENV{'NO_IPV6'}&& eval {require Socket6;require IO::Socket::INET6}){my$proto_id=getprotobyname(lc($proto)eq 'udp' ? 'udp' : 'tcp');my$socktype=lc($proto)eq 'udp' ? Socket::SOCK_DGRAM(): Socket::SOCK_STREAM();my@res=Socket6::getaddrinfo($host eq '*' ? '' : $host,$port,Socket::AF_UNSPEC(),$socktype,$proto_id,Socket6::AI_PASSIVE());die "Unresolveable [$host]:$port: $res[0]\n" if@res < 5;while (@res >= 5){my ($afam,$socktype,$proto,$saddr,$canonname)=splice@res,0,5;my@res2=Socket6::getnameinfo($saddr,Socket6::NI_NUMERICHOST()| Socket6::NI_NUMERICSERV());die "getnameinfo failed on [$host]:$port: $res2[0]\n" if@res2 < 2;my ($ip,$port)=@res2;my$ipv=($afam==Socket6::AF_INET6())? 6 : ($afam==Socket::AF_INET())? 4 : '*';push@info,[$ip,$port,$ipv]}my%ipv6mapped=map {$_->[0]eq '::' ? ('0.0.0.0'=>$_): $_->[0]=~ /^::ffff:(\d+(?:\.\d+){3})$/ ? ($1=>$_): ()}@info;if ((scalar(keys%ipv6mapped)&& grep {$ipv6mapped{$_->[0]}}@info)&& not my$only=$class->_bindv6only){for my$i4 (@info){my$i6=$ipv6mapped{$i4->[0]}|| next;if ($host eq '*' && $i6->[0]eq '::' &&!length($only)&&!eval{IO::Socket::INET6->new->configure({LocalAddr=>'',LocalPort=>0,Listen=>1,ReuseAddr=>1,Domain=>Socket6::AF_INET6()})or die $!}){$i4->[3]="Host [*] resolved to IPv6 address [::] but IO::Socket::INET6->new fails: $@";$i6->[0]=''}else {$i6->[3]="Not including resolved host [$i4->[0]] IPv4 because it ".(length($only)? 'will' : 'should')." be handled by [$i6->[0]] IPv6";$i4->[0]=''}}@info=grep {length $_->[0]}@info}}elsif ($host =~ /:/){die "Unresolveable host [$host]:$port - could not load IO::Socket::INET6: $@"}else {my@addr;if ($host eq '*'){push@addr,Socket::INADDR_ANY()}else {(undef,undef,undef,undef,@addr)=gethostbyname($host);die "Unresolveable host [$host]:$port via IPv4 gethostbyname\n" if!@addr}push@info,[Socket::inet_ntoa($_),$port,4]for@addr}return@info}sub _bindv6only {my$class=shift;my$val=$class->_sysctl('net.ipv6.bindv6only');$val=$class->_sysctl('net.inet6.ip6.v6only')if!length($val);return$val}sub _sysctl {my ($class,$key)=@_;(my$file="/proc/sys/$key")=~ y|.|/|;if (-e $file){open my$fh,"<",$file or return '';my$val=<$fh> || return '';chomp$val;return$val}elsif (-x "/sbin/sysctl"){my$val=(split /\s+/,`/sbin/sysctl -n $key 2>/dev/null`)[0];return defined($val)? $val : ''}return ''}sub object {my ($class,$info,$server)=@_;my$proto_class=$info->{'proto'};if ($proto_class !~ /::/){$server->fatal("Invalid proto class \"$proto_class\"")if$proto_class !~ /^\w+$/;$proto_class="Net::Server::Proto::" .uc($proto_class)}(my$file="${proto_class}.pm")=~ s|::|/|g;$server->fatal("Unable to load module for proto \"$proto_class\": $@")if!eval {require$file};return$proto_class->object($info,$server)}sub requires_ipv6 {my ($class,$server)=@_;return if!$requires_ipv6;if (!$INC{'IO/Socket/INET6.pm'}){eval {require Socket6;require IO::Socket::INET6}or $server->fatal("Port configuration using IPv6 could not be started becauses of Socket6 library issues: $@")}return 1}1;
NET_SERVER_PROTO

$fatpacked{"Net/Server/Proto/SSL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_PROTO_SSL';
  package Net::Server::Proto::SSL;use strict;use warnings;BEGIN {if (!eval {require IO::Socket::SSL}){die "Module IO::Socket::SSL is required for SSL - you may alternately try SSLEAY. $@"}}our@ISA=qw(IO::Socket::SSL);our$AUTOLOAD;my@ssl_args=qw(SSL_use_cert SSL_verify_mode SSL_key_file SSL_cert_file SSL_ca_path SSL_ca_file SSL_cipher_list SSL_passwd_cb SSL_max_getline_length SSL_error_callback);sub NS_proto {'SSL'}sub NS_port {my$sock=shift;${*$sock}{'NS_port'}=shift if @_;return ${*$sock}{'NS_port'}}sub NS_host {my$sock=shift;${*$sock}{'NS_host'}=shift if @_;return ${*$sock}{'NS_host'}}sub NS_ipv {my$sock=shift;${*$sock}{'NS_ipv'}=shift if @_;return ${*$sock}{'NS_ipv'}}sub NS_listen {my$sock=shift;${*$sock}{'NS_listen'}=shift if @_;return ${*$sock}{'NS_listen'}}sub object {my ($class,$info,$server)=@_;my$ssl=$server->{'server'}->{'ssl_args'}||=do {my%temp=map {$_=>undef}@ssl_args;$server->configure({map {$_=>\$temp{$_}}@ssl_args});\%temp};my@sock=$class->SUPER::new();for my$sock (@sock){$sock->NS_host($info->{'host'});$sock->NS_port($info->{'port'});$sock->NS_ipv($info->{'ipv'});$sock->NS_listen(defined($info->{'listen'})? $info->{'listen'}: defined($server->{'server'}->{'listen'})? $server->{'server'}->{'listen'}: Socket::SOMAXCONN());${*$sock}{'NS_orig_port'}=$info->{'orig_port'}if defined$info->{'orig_port'};my%seen;for my$key (grep {!$seen{$_}++}(@ssl_args,sort grep {/^SSL_/}keys %$info)){my$val=defined($info->{$key})? $info->{$key}: defined($ssl->{$key})? $ssl->{$key}: $server->can($key)? $server->$key($info->{'host'},$info->{'port'},'SSL'): undef;next if!defined$val;$sock->$key($val)if defined$val}}return wantarray ? @sock : $sock[0]}sub log_connect {my ($sock,$server)=@_;$server->log(2,"Binding to ".$sock->NS_proto." port ".$sock->NS_port." on host ".$sock->NS_host." with IPv".($sock->NS_ipv))}sub connect {my ($sock,$server)=@_;my$host=$sock->NS_host;my$port=$sock->NS_port;my$ipv=$sock->NS_ipv;my$lstn=$sock->NS_listen;$sock->SUPER::configure({LocalPort=>$port,Proto=>'tcp',Listen=>$lstn,ReuseAddr=>1,Reuse=>1,(($host ne '*')? (LocalAddr=>$host): ()),($sock->isa('IO::Socket::INET6')? (Domain=>($ipv eq '6')? Socket6::AF_INET6(): ($ipv eq '4')? Socket::AF_INET(): Socket::AF_UNSPEC()): ()),(map {$_=>$sock->$_()}grep {/^SSL_/}keys %{*$sock}),SSL_server=>1,})or $server->fatal("Cannot connect to SSL port $port on $host [$!]");if ($port eq '0' and $port=$sock->sockport){$server->log(2,"  Bound to auto-assigned port $port");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}elsif ($port =~ /\D/ and $port=$sock->sockport){$server->log(2,"  Bound to service port ".$sock->NS_port()."($port)");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}}sub reconnect {my ($sock,$fd,$server,$port)=@_;$server->log(3,"Reassociating file descriptor $fd with ".$sock->NS_proto." on [".$sock->NS_host."]:".$sock->NS_port.", using IPv".$sock->NS_ipv);$sock->configure_SSL({(map {$_=>$sock->$_()}grep {/^SSL_/}keys %{*$sock}),SSL_server=>1,});$sock->IO::Socket::INET::fdopen($fd,'w')or $server->fatal("Error opening to file descriptor ($fd) [$!]");if ($sock->isa("IO::Socket::INET6")){my$ipv=$sock->NS_ipv;${*$sock}{'io_socket_domain'}=($ipv eq '6')? Socket6::AF_INET6(): ($ipv eq '4')? Socket::AF_INET(): Socket::AF_UNSPEC()}if ($port ne $sock->NS_port){$server->log(2,"  Re-bound to previously assigned port $port");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}}sub accept {my ($sock,$class)=@_;my ($client,$peername);my$code=$sock->isa('IO::Socket::INET6')? 'IO::Socket::INET6'->can('accept'): 'IO::Socket::INET'->can('accept');if (wantarray){($client,$peername)=$code->($sock,$class || ref($sock))}else {$client=$code->($sock,$class || ref($sock))}${*$client}{'_parent_sock'}=$sock;if (defined$client){$client->NS_proto($sock->NS_proto);$client->NS_ipv($sock->NS_ipv);$client->NS_host($sock->NS_host);$client->NS_port($sock->NS_port)}return wantarray ? ($client,$peername): $client}sub hup_string {my$sock=shift;return join "|",$sock->NS_host,$sock->NS_port,$sock->NS_proto,'ipv'.$sock->NS_ipv,(defined(${*$sock}{'NS_orig_port'})? ${*$sock}{'NS_orig_port'}: ())}sub show {my$sock=shift;my$t="Ref = \"".ref($sock)."\" (".$sock->hup_string.")\n";for my$prop (qw(SSLeay_context SSLeay_is_client)){$t .= "  $prop = \"" .$sock->$prop()."\"\n"}return$t}sub AUTOLOAD {my$sock=shift;my$prop=$AUTOLOAD =~ /::([^:]+)$/ ? $1 : die "Missing property in AUTOLOAD.";die "Unknown method or property [$prop]" if$prop !~ /^(SSL_\w+)$/;no strict 'refs';*{__PACKAGE__."::${prop}"}=sub {my$sock=shift;if (@_){${*$sock}{$prop}=shift;return delete ${*$sock}{$prop}if!defined ${*$sock}{$prop}}else {return ${*$sock}{$prop}}};return$sock->$prop(@_)}sub tie_stdout {1}sub post_accept {my$client=shift;$client->_accept_ssl if!${*$client}{'_accept_ssl'}}sub _accept_ssl {my$client=shift;${*$client}{'_accept_ssl'}=1;my$sock=delete(${*$client}{'_parent_sock'})|| die "Could not get handshake from accept\n";$sock->accept_SSL($client)|| die "Could not finalize SSL connection with client handle ($@)\n"}sub read_until {my ($client,$bytes,$end_qr)=@_;die "One of bytes or end_qr should be defined for TCP read_until\n" if!defined($bytes)&&!defined($end_qr);$client->_accept_ssl if!${*$client}{'_accept_ssl'};my$content='';my$ok=0;while (1){$client->read($content,1,length($content));if (defined($bytes)&& length($content)>= $bytes){$ok=2;last}elsif (defined($end_qr)&& $content =~ $end_qr){$ok=1;last}}return wantarray ? ($ok,$content): $content}1;
NET_SERVER_PROTO_SSL

$fatpacked{"Net/Server/Proto/SSLEAY.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_PROTO_SSLEAY';
  package Net::Server::Proto::SSLEAY;use strict;use warnings;use IO::Socket::INET;use Fcntl ();use Errno ();use Socket ();BEGIN {eval {require Net::SSLeay;1}or warn "Module Net::SSLeay is required for SSLeay.";for my$sub (qw(load_error_strings SSLeay_add_ssl_algorithms ENGINE_load_builtin_engines ENGINE_register_all_complete randomize)){Net::SSLeay->can($sub)->()}eval {[Fcntl::F_GETFL(),Fcntl::F_SETFL(),Fcntl::O_NONBLOCK()]}|| die "Could not access Fcntl constant while loading ".__PACKAGE__.": $@"}our@ISA=qw(IO::Socket::INET);our$AUTOLOAD;my@ssl_args=qw(SSL_use_cert SSL_verify_mode SSL_key_file SSL_cert_file SSL_ca_path SSL_ca_file SSL_cipher_list SSL_passwd_cb SSL_max_getline_length SSL_error_callback);sub NS_proto {'SSLEAY'}sub NS_port {my$sock=shift;${*$sock}{'NS_port'}=shift if @_;return ${*$sock}{'NS_port'}}sub NS_host {my$sock=shift;${*$sock}{'NS_host'}=shift if @_;return ${*$sock}{'NS_host'}}sub NS_ipv {my$sock=shift;${*$sock}{'NS_ipv'}=shift if @_;return ${*$sock}{'NS_ipv'}}sub NS_listen {my$sock=shift;${*$sock}{'NS_listen'}=shift if @_;return ${*$sock}{'NS_listen'}}sub object {my ($class,$info,$server)=@_;my$ssl=$server->{'server'}->{'ssl_args'}||=do {my%temp=map {$_=>undef}@ssl_args;$server->configure({map {$_=>\$temp{$_}}@ssl_args});\%temp};@ISA=qw(IO::Socket::INET6) if$ISA[0]eq 'IO::Socket::INET' && Net::Server::Proto->requires_ipv6($server);my@sock=$class->SUPER::new();for my$sock (@sock){$sock->NS_host($info->{'host'});$sock->NS_port($info->{'port'});$sock->NS_ipv($info->{'ipv'});$sock->NS_listen(defined($info->{'listen'})? $info->{'listen'}: defined($server->{'server'}->{'listen'})? $server->{'server'}->{'listen'}: Socket::SOMAXCONN());${*$sock}{'NS_orig_port'}=$info->{'orig_port'}if defined$info->{'orig_port'};for my$key (@ssl_args){my$val=defined($info->{$key})? $info->{$key}: defined($ssl->{$key})? $ssl->{$key}: $server->can($key)? $server->$key($info->{'host'},$info->{'port'},'SSLEAY'): undef;next if!defined$val;$sock->$key($val)if defined$val}}return wantarray ? @sock : $sock[0]}sub log_connect {my ($sock,$server)=@_;$server->log(2,"Binding to ".$sock->NS_proto." port ".$sock->NS_port." on host ".$sock->NS_host." with IPv".$sock->NS_ipv)}sub connect {my ($sock,$server)=@_;my$host=$sock->NS_host;my$port=$sock->NS_port;my$ipv=$sock->NS_ipv;my$lstn=$sock->NS_listen;$sock->SUPER::configure({LocalPort=>$port,Proto=>'tcp',Listen=>$lstn,ReuseAddr=>1,Reuse=>1,(($host ne '*')? (LocalAddr=>$host): ()),($sock->isa("IO::Socket::INET6")? (Domain=>($ipv eq '6')? Socket6::AF_INET6(): ($ipv eq '4')? Socket::AF_INET(): Socket::AF_UNSPEC()): ()),})|| $server->fatal("Can't connect to SSLEAY port $port on $host [$!]");if ($port eq '0' and $port=$sock->sockport){$server->log(2,"  Bound to auto-assigned port $port");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}elsif ($port =~ /\D/ and $port=$sock->sockport){$server->log(2,"  Bound to service port ".$sock->NS_port()."($port)");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}$sock->bind_SSL($server)}sub reconnect {my ($sock,$fd,$server,$port)=@_;$server->log(3,"Reassociating file descriptor $fd with ".$sock->NS_proto." on [".$sock->NS_host."]:".$sock->NS_port.", using IPv".$sock->NS_ipv);my$resp=$sock->fdopen($fd,'w')or $server->fatal("Error opening to file descriptor ($fd) [$!]");if ($sock->isa("IO::Socket::INET6")){my$ipv=$sock->NS_ipv;${*$sock}{'io_socket_domain'}=($ipv eq '6')? Socket6::AF_INET6(): ($ipv eq '4')? Socket::AF_INET(): Socket::AF_UNSPEC()}$sock->bind_SSL($server);if ($port ne $sock->NS_port){$server->log(2,"  Re-bound to previously assigned port $port");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}return$resp}sub bind_SSL {my ($sock,$server)=@_;my$ctx=Net::SSLeay::CTX_new();$sock->SSLeay_check_fatal("SSLeay bind_SSL CTX_new");Net::SSLeay::CTX_set_options($ctx,Net::SSLeay::OP_ALL());$sock->SSLeay_check_fatal("SSLeay bind_SSL CTX_set_options");Net::SSLeay::CTX_set_mode($ctx,0x11);$sock->SSLeay_check_fatal("SSLeay bind_SSL CTX_set_mode");my$file_key=$sock->SSL_key_file || die "SSLeay missing SSL_key_file on ".$sock->hup_string.".\n";my$file_cert=$sock->SSL_cert_file || die "SSLeay missing SSL_cert_file on ".$sock->hup_string>".\n";Net::SSLeay::CTX_use_RSAPrivateKey_file($ctx,$file_key,Net::SSLeay::FILETYPE_PEM());$sock->SSLeay_check_fatal("SSLeay bind_SSL CTX_use_RSAPrivateKey_file");Net::SSLeay::CTX_use_certificate_file($ctx,$file_cert,Net::SSLeay::FILETYPE_PEM());$sock->SSLeay_check_fatal("SSLeay bind_SSL CTX_use_certificate_file");$sock->SSLeay_context($ctx)}sub close {my$sock=shift;if ($sock->SSLeay_is_client){Net::SSLeay::free($sock->SSLeay)}else {Net::SSLeay::CTX_free($sock->SSLeay_context)}$sock->SSLeay_check_fatal("SSLeay close free");return$sock->SUPER::close(@_)}sub accept {my ($sock,$class)=(@_);my ($client,$peername);if (wantarray){($client,$peername)=$sock->SUPER::accept($class)}else {$client=$sock->SUPER::accept($class)}if (defined$client){$client->NS_proto($sock->NS_proto);$client->NS_ipv($sock->NS_ipv);$client->NS_host($sock->NS_host);$client->NS_port($sock->NS_port);$client->SSLeay_context($sock->SSLeay_context);$client->SSLeay_is_client(1)}return wantarray ? ($client,$peername): $client}sub post_accept {my$client=shift;$client->SSLeay}sub SSLeay {my$client=shift;if (!exists ${*$client}{'SSLeay'}){die "SSLeay refusing to accept on non-client socket" if!$client->SSLeay_is_client;$client->autoflush(1);my$f=fcntl($client,Fcntl::F_GETFL(),0)|| die "SSLeay - fcntl get: $!\n";fcntl($client,Fcntl::F_SETFL(),$f | Fcntl::O_NONBLOCK())|| die "SSLeay - fcntl set: $!\n";my$ssl=Net::SSLeay::new($client->SSLeay_context);$client->SSLeay_check_fatal("SSLeay new");Net::SSLeay::set_fd($ssl,$client->fileno);$client->SSLeay_check_fatal("SSLeay set_fd");Net::SSLeay::accept($ssl);$client->SSLeay_check_fatal("SSLeay accept");${*$client}{'SSLeay'}=$ssl}return if!defined wantarray;return ${*$client}{'SSLeay'}}sub SSLeay_check_fatal {my ($client,$msg)=@_;if (my$err=$client->SSLeay_check_error($msg,1)){my ($file,$pkg,$line)=caller;die "$msg at $file line $line\n  ".join('  ',@$err)}}sub SSLeay_check_error {my ($client,$msg,$fatal)=@_;my@err;while (my$n=Net::SSLeay::ERR_get_error()){push@err,"$n. ".Net::SSLeay::ERR_error_string($n)."\n"}if (@err){my$cb=$client->SSL_error_callback;$cb->($client,$msg,\@err,($fatal ? 'is_fatal' : ()))if$cb;return \@err}return}sub read_until {my ($client,$bytes,$end_qr,$non_greedy)=@_;my$ssl=$client->SSLeay;my$content=${*$client}{'SSLeay_buffer'};$content='' if!defined$content;my$ok=0;OUTER: while (1){if (!length($content)){}elsif (defined($bytes)&& length($content)>= $bytes){${*$client}{'SSLeay_buffer'}=substr($content,$bytes,length($content),'');$ok=2;last}elsif (defined($end_qr)&& $content =~ m/$end_qr/g){my$n=pos($content);${*$client}{'SSLeay_buffer'}=substr($content,$n,length($content),'');$ok=1;last}my$n_empty=0;while (1){my$n=16384;$n -= ($bytes - length($content))if$non_greedy && ($bytes - length($content))< $n;my$buf=Net::SSLeay::read($ssl,16384);if ($client->SSLeay_check_error('SSLeay read_until read')){last OUTER}die "SSLeay read_until: $!\n" if!defined($buf)&&!$!{EAGAIN}&&!$!{EINTR}&&!$!{ENOBUFS};last if!defined($buf);if (!length($buf)){last OUTER if!length($buf)&& $n_empty++}else {$content .= $buf;if ($non_greedy && length($content)==$bytes){$ok=3;last}}}}return wantarray ? ($ok,$content): $content}sub read {my ($client,$buf,$size,$offset)=@_;my ($ok,$read)=$client->read_until($size,undef,1);substr($_[1],$offset || 0,defined($buf)? length($buf): 0,$read);return length$read}sub sysread {my ($client,$buf,$length,$offset)=@_;$length=length$buf unless defined$length;$offset=0 unless defined$offset;my$ssl=$client->SSLeay;my$data=Net::SSLeay::read($ssl,$length);return if $!{EAGAIN}|| $!{EINTR};die "SSLeay print: $!\n" unless defined$data;$length=length($data);$$buf='' if!defined$buf;if ($offset > length($$buf)){$$buf .= "\0" x ($offset - length($buf))}substr($$buf,$offset,length($$buf),$data);return$length}sub error {my$client=shift;return ${*$client}{'_error'}}sub syswrite {my ($client,$buf,$length,$offset)=@_;delete ${*$client}{'_error'};$length=length$buf unless defined$length;$offset=0 unless defined$offset;my$ssl=$client->SSLeay;my$write=Net::SSLeay::write_partial($ssl,$offset,$length,$buf);return if $!{EAGAIN}|| $!{EINTR};if ($write < 0){${*$client}{'_error'}="SSLeay print: $!\n";return}return$write}sub getline {my$client=shift;my ($ok,$line)=$client->read_until($client->SSL_max_getline_length,$/);return$line}sub getlines {my$client=shift;my@lines;while (1){my ($ok,$line)=$client->read_until($client->SSL_max_getline_length,$/);push@lines,$line;last if$ok!=1}return@lines}sub print {my$client=shift;delete ${*$client}{'_error'};my$buf=@_==1 ? $_[0]: join('',@_);my$ssl=$client->SSLeay;while (length$buf){vec(my$vec='',$client->fileno,1)=1;select(undef,$vec,undef,undef);my$write=Net::SSLeay::write($ssl,$buf);return 0 if$client->SSLeay_check_error('SSLeay write');if ($write==-1 &&!$!{EAGAIN}&&!$!{EINTR}&&!$!{ENOBUFS}){${*$client}{'_error'}="SSLeay print: $!\n";return}substr($buf,0,$write,"")if$write > 0}return 1}sub printf {my$client=shift;$client->print(sprintf(shift,@_))}sub say {my$client=shift;$client->print(@_,"\n")}sub write {my$client=shift;my$buf=shift;$buf=substr($buf,$_[1]|| 0,$_[0])if @_;$client->print($buf)}sub seek {my$client=shift;my ($pos,$whence)=@_;if ($whence){$!="Seek from $whence of non-zero is not supported.";return 0}my$n=$client->read(my$buf,$pos);if ($n!=$pos){$|="Couldn't seek to $pos ($n)\n";return 0}return 1}sub poll_cb {my ($self,$cb)=@_;return$cb->($self)}sub hup_string {my$sock=shift;return join "|",$sock->NS_host,$sock->NS_port,$sock->NS_proto,"ipv".$sock->NS_ipv,(defined(${*$sock}{'NS_orig_port'})? ${*$sock}{'NS_orig_port'}: ())}sub show {my$sock=shift;my$t="Ref = \"".ref($sock)."\" (".$sock->hup_string.")\n";for my$prop (qw(SSLeay_context SSLeay_is_client)){$t .= "  $prop = \"" .$sock->$prop()."\"\n"}return$t}sub AUTOLOAD {my$sock=shift;my$prop=$AUTOLOAD =~ /::([^:]+)$/ ? $1 : die "Missing property in AUTOLOAD.";die "Unknown method or property [$prop]" if$prop !~ /^(SSLeay_context|SSLeay_is_client|SSL_\w+)$/;no strict 'refs';*{__PACKAGE__."::${prop}"}=sub {my$sock=shift;if (@_){${*$sock}{$prop}=shift;return delete ${*$sock}{$prop}if!defined ${*$sock}{$prop}}else {return ${*$sock}{$prop}}};return$sock->$prop(@_)}sub tie_stdout {1}1;
NET_SERVER_PROTO_SSLEAY

$fatpacked{"Net/Server/Proto/TCP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_PROTO_TCP';
  package Net::Server::Proto::TCP;use strict;use warnings;use IO::Socket::INET;use Net::Server::Proto;our@ISA=qw(IO::Socket::INET);sub NS_proto {'TCP'}sub NS_port {my$sock=shift;${*$sock}{'NS_port'}=shift if @_;return ${*$sock}{'NS_port'}}sub NS_host {my$sock=shift;${*$sock}{'NS_host'}=shift if @_;return ${*$sock}{'NS_host'}}sub NS_ipv {my$sock=shift;${*$sock}{'NS_ipv'}=shift if @_;return ${*$sock}{'NS_ipv'}}sub NS_listen {my$sock=shift;${*$sock}{'NS_listen'}=shift if @_;return ${*$sock}{'NS_listen'}}sub object {my ($class,$info,$server)=@_;@ISA=qw(IO::Socket::INET6) if$ISA[0]eq 'IO::Socket::INET' && Net::Server::Proto->requires_ipv6($server);my@sock=$class->SUPER::new();for my$sock (@sock){$sock->NS_host($info->{'host'});$sock->NS_port($info->{'port'});$sock->NS_ipv($info->{'ipv'});$sock->NS_listen(defined($info->{'listen'})? $info->{'listen'}: defined($server->{'server'}->{'listen'})? $server->{'server'}->{'listen'}: Socket::SOMAXCONN());${*$sock}{'NS_orig_port'}=$info->{'orig_port'}if defined$info->{'orig_port'}}return wantarray ? @sock : $sock[0]}sub log_connect {my ($sock,$server)=@_;$server->log(2,"Binding to ".$sock->NS_proto." port ".$sock->NS_port." on host ".$sock->NS_host." with IPv".$sock->NS_ipv)}sub connect {my ($sock,$server)=@_;my$host=$sock->NS_host;my$port=$sock->NS_port;my$ipv=$sock->NS_ipv;my$lstn=$sock->NS_listen;$sock->SUPER::configure({LocalPort=>$port,Proto=>'tcp',Listen=>$lstn,ReuseAddr=>1,Reuse=>1,(($host ne '*')? (LocalAddr=>$host): ()),($sock->isa("IO::Socket::INET6")? (Domain=>($ipv eq '6')? Socket6::AF_INET6(): ($ipv eq '4')? Socket::AF_INET(): Socket::AF_UNSPEC()): ()),})|| $server->fatal("Can't connect to TCP port $port on $host [$!]");if ($port eq '0' and $port=$sock->sockport){$server->log(2,"  Bound to auto-assigned port $port");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}elsif ($port =~ /\D/ and $port=$sock->sockport){$server->log(2,"  Bound to service port ".$sock->NS_port()."($port)");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}}sub reconnect {my ($sock,$fd,$server,$port)=@_;$server->log(3,"Reassociating file descriptor $fd with ".$sock->NS_proto." on [".$sock->NS_host."]:".$sock->NS_port.", using IPv".$sock->NS_ipv);$sock->fdopen($fd,'w')or $server->fatal("Error opening to file descriptor ($fd) [$!]");if ($sock->isa("IO::Socket::INET6")){my$ipv=$sock->NS_ipv;${*$sock}{'io_socket_domain'}=($ipv eq '6')? Socket6::AF_INET6(): ($ipv eq '4')? Socket::AF_INET(): Socket::AF_UNSPEC()}if ($port ne $sock->NS_port){$server->log(2,"  Re-bound to previously assigned port $port");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}}sub accept {my ($sock,$class)=(@_);my ($client,$peername);if (wantarray){($client,$peername)=$sock->SUPER::accept($class)}else {$client=$sock->SUPER::accept($class)}if (defined$client){$client->NS_port($sock->NS_port)}return wantarray ? ($client,$peername): $client}sub poll_cb {my ($self,$cb)=@_;return$cb->($self)}sub read_until {my ($client,$bytes,$end_qr)=@_;die "One of bytes or end_qr should be defined for TCP read_until\n" if!defined($bytes)&&!defined($end_qr);my$content='';my$ok=0;while (1){$client->read($content,1,length($content));if (defined($bytes)&& length($content)>= $bytes){$ok=2;last}elsif (defined($end_qr)&& $content =~ $end_qr){$ok=1;last}}return wantarray ? ($ok,$content): $content}sub hup_string {my$sock=shift;return join "|",$sock->NS_host,$sock->NS_port,$sock->NS_proto,'ipv'.$sock->NS_ipv,(defined(${*$sock}{'NS_orig_port'})? ${*$sock}{'NS_orig_port'}: ())}sub show {my$sock=shift;return "Ref = \"".ref($sock)."\" (".$sock->hup_string.")\n"}1;
NET_SERVER_PROTO_TCP

$fatpacked{"Net/Server/Proto/UDP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_PROTO_UDP';
  package Net::Server::Proto::UDP;use strict;use base qw(Net::Server::Proto::TCP);my@udp_args=qw(udp_recv_len udp_recv_flags udp_broadcast);sub NS_proto {'UDP'}sub NS_recv_len {my$sock=shift;${*$sock}{'NS_recv_len'}=shift if @_;return ${*$sock}{'NS_recv_len'}}sub NS_recv_flags {my$sock=shift;${*$sock}{'NS_recv_flags'}=shift if @_;return ${*$sock}{'NS_recv_flags'}}sub NS_broadcast {my$sock=shift;${*$sock}{'NS_broadcast'}=shift if @_;return ${*$sock}{'NS_broadcast'}}sub object {my ($class,$info,$server)=@_;@Net::Server::Proto::TCP::ISA=qw(IO::Socket::INET6) if$Net::Server::Proto::TCP::ISA[0]eq 'IO::Socket::INET' && Net::Server::Proto->requires_ipv6($server);my$udp=$server->{'server'}->{'udp_args'}||=do {my%temp=map {$_=>undef}@udp_args;$server->configure({map {$_=>\$temp{$_}}@udp_args});\%temp};my$len=defined($info->{'udp_recv_len'})? $info->{'udp_recv_len'}: defined($udp->{'udp_recv_len'})? $udp->{'udp_recv_len'}: 4096;$len=($len =~ /^(\d+)$/)? $1 : 4096;my$flg=defined($info->{'udp_recv_flags'})? $info->{'udp_recv_flags'}: defined($udp->{'udp_recv_flags'})? $udp->{'udp_recv_flags'}: 0;$flg=($flg =~ /^(\d+)$/)? $1 : 0;my@sock=$class->SUPER::new();for my$sock (@sock){$sock->NS_host($info->{'host'});$sock->NS_port($info->{'port'});$sock->NS_ipv($info->{'ipv'});$sock->NS_recv_len($len);$sock->NS_recv_flags($flg);$sock->NS_broadcast(exists($info->{'udp_broadcast'})? $info->{'udp_broadcast'}: $udp->{'upd_broadcast'});${*$sock}{'NS_orig_port'}=$info->{'orig_port'}if defined$info->{'orig_port'}}return wantarray ? @sock : $sock[0]}sub connect {my ($sock,$server)=@_;my$host=$sock->NS_host;my$port=$sock->NS_port;my$ipv=$sock->NS_ipv;$sock->SUPER::configure({LocalPort=>$port,Proto=>'udp',ReuseAddr=>1,Reuse=>1,(($host ne '*')? (LocalAddr=>$host): ()),($sock->isa("IO::Socket::INET6")? (Domain=>($ipv eq '6')? Socket6::AF_INET6(): ($ipv eq '4')? Socket::AF_INET(): Socket::AF_UNSPEC()): ()),($sock->NS_broadcast ? (Broadcast=>1): ()),})or $server->fatal("Cannot bind to UDP port $port on $host [$!]");if ($port eq 0 and $port=$sock->sockport){$server->log(2,"  Bound to auto-assigned port $port");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}elsif ($port =~ /\D/ and $port=$sock->sockport){$server->log(2,"  Bound to service port ".$sock->NS_port()."($port)");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}}1;
NET_SERVER_PROTO_UDP

$fatpacked{"Net/Server/Proto/UNIX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_PROTO_UNIX';
  package Net::Server::Proto::UNIX;use strict;use base qw(IO::Socket::UNIX);use Socket qw(SOCK_STREAM SOCK_DGRAM);sub NS_proto {'UNIX'}sub NS_port {my$sock=shift;${*$sock}{'NS_port'}=shift if @_;return ${*$sock}{'NS_port'}}sub NS_host {'*'}sub NS_ipv {'*'}sub NS_listen {my$sock=shift;${*$sock}{'NS_listen'}=shift if @_;return ${*$sock}{'NS_listen'}}sub NS_unix_type {'SOCK_STREAM'}sub NS_unix_path {shift->NS_port}sub object {my ($class,$info,$server)=@_;if ($class eq __PACKAGE__){$server->configure({unix_type=>\$server->{'server'}->{'unix_type'},unix_path=>\$server->{'server'}->{'unix_path'},})if!exists$server->{'server'}->{'unix_type'};my$u_type=uc(defined($info->{'unix_type'})? $info->{'unix_type'}: defined($server->{'server'}->{'unix_type'})? $server->{'server'}->{'unix_type'}: 'SOCK_STREAM');if ($u_type eq 'SOCK_DGRAM' || $u_type eq ''.SOCK_DGRAM()){require Net::Server::Proto::UNIXDGRAM;return Net::Server::Proto::UNIXDGRAM->object($info,$server)}elsif ($u_type ne 'SOCK_STREAM' && $u_type ne ''.SOCK_STREAM()){$server->fatal("Invalid type for UNIX socket ($u_type)... must be SOCK_STREAM or SOCK_DGRAM")}$info->{'port'}||=$info->{'unix_path'}=$server->{'server'}->{'unix_path'}}my$sock=$class->SUPER::new();my$port=$info->{'port'}=~ m{^ ([\w\.\-\*\/]+) $ }x ? $1 : $server->fatal("Insecure filename");$sock->NS_port($port);$sock->NS_listen(defined($info->{'listen'})? $info->{'listen'}: defined($server->{'server'}->{'listen'})? $server->{'server'}->{'listen'}: Socket::SOMAXCONN());return$sock}sub connect {my ($sock,$server)=@_;my$path=$sock->NS_port;$server->fatal("Can't connect to UNIX socket at file $path [$!]")if -e $path &&!unlink$path;$sock->SUPER::configure({Local=>$path,Type=>SOCK_STREAM,Listen=>$sock->NS_listen,})or $server->fatal("Can't connect to UNIX socket at file $path [$!]")}sub log_connect {my ($sock,$server)=@_;$server->log(2,"Binding to ".$sock->NS_proto." socket file \"".$sock->NS_port."\"")}sub reconnect {my ($sock,$fd,$server)=@_;$sock->fdopen($fd,'w')or $server->fatal("Error opening to file descriptor ($fd) [$!]")}sub hup_string {my$sock=shift;return join "|",$sock->NS_host,$sock->NS_port,$sock->NS_proto,$sock->NS_ipv}sub show {my$sock=shift;return "Ref = \"".ref($sock)."\" (".$sock->hup_string.")\n"}1;
NET_SERVER_PROTO_UNIX

$fatpacked{"Net/Server/Proto/UNIXDGRAM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_PROTO_UNIXDGRAM';
  package Net::Server::Proto::UNIXDGRAM;use strict;use base qw(Net::Server::Proto::UNIX);use Socket qw(SOCK_DGRAM);my@udp_args=qw(udp_recv_len udp_recv_flags udp_broadcast);sub NS_proto {'UNIXDGRAM'}sub NS_recv_len {my$sock=shift;${*$sock}{'NS_recv_len'}=shift if @_;return ${*$sock}{'NS_recv_len'}}sub NS_recv_flags {my$sock=shift;${*$sock}{'NS_recv_flags'}=shift if @_;return ${*$sock}{'NS_recv_flags'}}sub NS_unix_type {'SOCK_DGRAM'}sub object {my ($class,$info,$server)=@_;my$udp=$server->{'server'}->{'udp_args'}||=do {my%temp=map {$_=>undef}@udp_args;$server->configure({map {$_=>\$temp{$_}}@udp_args});\%temp};my$len=defined($info->{'udp_recv_len'})? $info->{'udp_recv_len'}: defined($udp->{'udp_recv_len'})? $udp->{'udp_recv_len'}: 4096;$len=($len =~ /^(\d+)$/)? $1 : 4096;my$flg=defined($info->{'udp_recv_flags'})? $info->{'udp_recv_flags'}: defined($udp->{'udp_recv_flags'})? $udp->{'udp_recv_flags'}: 0;$flg=($flg =~ /^(\d+)$/)? $1 : 0;my$sock=$class->SUPER::new();my$port=$info->{'port'}=~ m{^ ([\w\.\-\*\/]+) $ }x ? $1 : $server->fatal("Insecure filename");$sock->NS_port($port);$sock->NS_recv_len($len);$sock->NS_recv_flags($flg);return$sock}sub connect {my ($sock,$server)=@_;my$path=$sock->NS_port;$server->fatal("Can't connect to UNIXDGRAM socket at file $path [$!]")if -e $path &&!unlink$path;$sock->SUPER::configure({Local=>$path,Type=>SOCK_DGRAM,})or $server->fatal("Can't connect to UNIXDGRAM socket at file $path [$!]")}1;
NET_SERVER_PROTO_UNIXDGRAM

$fatpacked{"Net/Server/SIG.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_SIG';
  package Net::Server::SIG;use strict;use vars qw($VERSION @ISA @EXPORT_OK %_SIG %_SIG_SUB);use Exporter ();$VERSION='0.03';@ISA=qw(Exporter);@EXPORT_OK=qw(register_sig unregister_sig check_sigs);sub register_sig {die 'Usage: register_sig( SIGNAME => \&code_ref )' if @_ % 2;if (@_ > 2){register_sig(shift(),shift())while @_;return}my$sig=shift;my$code_ref=shift;my$ref=ref($code_ref);if (!$ref){if ($code_ref eq 'DEFAULT'){delete$_SIG{$sig};delete$_SIG_SUB{$sig};$SIG{$sig}='DEFAULT'}elsif ($code_ref eq 'IGNORE'){delete$_SIG{$sig};delete$_SIG_SUB{$sig};$SIG{$sig}='IGNORE'}else {die "Scalar argument limited to \"DEFAULT\" and \"IGNORE\"."}}elsif ($ref eq 'CODE'){$_SIG{$sig}=0;$_SIG_SUB{$sig}=$code_ref;$SIG{$sig}=sub{$Net::Server::SIG::_SIG{$sig}=1}}else {die "Unsupported sig type -- must be 'DEFAULT' or a code ref."}}sub unregister_sig {register_sig(shift(),'DEFAULT')}sub check_sigs {my@found;for my$sig (keys%_SIG){next if!$_SIG{$sig};$_SIG{$sig}=0;push@found,$sig;$_SIG_SUB{$sig}->($sig)}return@found}sub sig_is_registered {my$sig=shift;return$_SIG_SUB{$sig}}1;
NET_SERVER_SIG

$fatpacked{"Net/Server/Single.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_SINGLE';
  package Net::Server::Single;use strict;use base qw(Net::Server);sub net_server_type {__PACKAGE__}1;
NET_SERVER_SINGLE

$fatpacked{"Text/FormatTable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_FORMATTABLE';
  package Text::FormatTable;use Carp;use strict;use warnings;use vars qw($VERSION);$VERSION='1.03';sub _uncolorized_length($) {my$str=shift;$str =~ s/\e \[ [^m]* m//xmsg;return length$str}sub _min_width($) {my$str=shift;my$min;for my$s (split(/\s+/,$str)){my$l=_uncolorized_length$s;$min=$l if not defined$min or $l > $min}return$min ? $min : 1}sub _max_width($) {my$str=shift;my$len=_uncolorized_length$str;return$len ? $len : 1}sub _max($$) {my ($a,$b)=@_;return$a if defined$a and (not defined$b or $a >= $b);return$b}sub _wrap($$) {my ($width,$text)=@_;my@lines=split(/\n/,$text);my@w=();for my$l (@lines){push@w,@{_wrap_line($width,$l)}}return \@w}sub _wrap_line($$) {my ($width,$text)=@_;my$width_m1=$width-1;my@t=($text);while(1){my$t=pop@t;my$l=_uncolorized_length$t;if($l <= $width){push@t,$t;return \@t}elsif($t =~ /^(.{0,$width_m1}\S)\s+(\S.*?)$/){push@t,$1;push@t,$2}elsif($t =~ /(.{$width,}?\S)\s+(\S.*?)$/){if (_uncolorized_length $1 > $width_m1){my$left=substr($1,0,$width);my$right=substr($1,$width);push@t,$left;push@t,$right;push@t,$2}else {push@t,$1;push@t,$2}}else {my$left=substr($t,0,$width);my$right=substr($t,$width);push@t,$left;push@t,$right;return \@t}}return \@t}sub _l_box($$) {my ($width,$text)=@_;my$lines=_wrap($width,$text);map {$_ .= ' 'x($width-_uncolorized_length($_))}@$lines;return$lines}sub _r_box($$) {my ($width,$text)=@_;my$lines=_wrap($width,$text);map {$_=(' 'x($width-_uncolorized_length($_)).$_)}@$lines;return$lines}sub _distribution_f($) {my$max_width=shift;return log($max_width)}sub _calculate_widths($$) {my ($self,$width)=@_;my@widths=();for my$r (@{$self->{data}}){$r->[0]eq 'data' or $r->[0]eq 'head' or next;my$cn=0;my ($max,$min)=(0,0);for my$c (@{$r->[1]}){if ($self->{fixed_widths}[$cn]){$widths[$cn][0]=$self->{fixed_widths}[$cn];$widths[$cn][1]=$self->{fixed_widths}[$cn]}else {$widths[$cn][0]=_max($widths[$cn][0],_min_width$c);$widths[$cn][1]=_max($widths[$cn][1],_max_width$c)}$cn++}}my ($total_min,$total_max)=(0,0);for my$c (@widths){$total_min += $c->[0];$total_max += $c->[1]}my$extra_width += scalar grep {$_->[0]eq '|' or $_->[0]eq ' '}(@{$self->{format}});$total_min += $extra_width;$total_max += $extra_width;if($total_max <= $width){my$cn=0;for my$c (@widths){$self->{widths}[$cn]=$c->[1];$cn++}$self->{total_width}=$total_max}else {my@dist_width;ITERATION: while(1){my$total_f=0.0;my$fixed_width=0;my$remaining=0;for my$c (@widths){if(defined$c->[2]){$fixed_width += $c->[2]}else {$total_f += _distribution_f($c->[1]);$remaining++}}my$available_width=$width-$extra_width-$fixed_width;if($available_width < $remaining*5){$available_width=$remaining*5;$width=$extra_width+$fixed_width+$available_width}my$cn=-1;COLUMN: for my$c (@widths){$cn++;next COLUMN if defined$c->[2];my$w=_distribution_f($c->[1])* $available_width / $total_f;if($c->[0]> $w){$c->[2]=$c->[0];next ITERATION}if($c->[1]< $w){$c->[2]=$c->[1];next ITERATION}$dist_width[$cn]=int($w)}last}my$cn=0;for my$c (@widths){$self->{widths}[$cn]=defined$c->[2]? $c->[2]: $dist_width[$cn];$cn++}}}sub _render_rule($$) {my ($self,$char)=@_;my$out='';my ($col,$data_col)=(0,0);for my$c (@{$self->{format}}){if($c->[0]eq '|'){if ($char eq '-'){$out .= '+'}elsif($char eq ' '){$out .= '|'}else {$out .= $char}}elsif($c->[0]eq ' '){$out .= $char}elsif($c->[0]eq 'l' or $c->[0]eq 'L' or $c->[0]eq 'r' or $c->[0]eq 'R'){$out .= ($char)x($self->{widths}[$data_col]);$data_col++}$col++}return$out."\n"}sub _render_data($$) {my ($self,$data)=@_;my@rdata;my ($col,$data_col)=(0,0);my$lines=0;my@rows_in_column;for my$c (@{$self->{format}}){if(($c->[0]eq 'l')or ($c->[0]eq 'L')){my$lb=_l_box($self->{widths}[$data_col],$data->[$data_col]);$rdata[$data_col]=$lb;my$l=scalar @$lb ;$lines=$l if$lines < $l;$rows_in_column[$data_col]=$l;$data_col++}elsif(($c->[0]eq 'r')or ($c->[0]eq 'R')){my$rb=_r_box($self->{widths}[$data_col],$data->[$data_col]);$rdata[$data_col]=$rb;my$l=scalar @$rb ;$lines=$l if$lines < $l;$rows_in_column[$data_col]=$l ;$data_col++}$col++}my$out='';for my$l (0..($lines-1)){my ($col,$data_col)=(0,0);for my$c (@{$self->{format}}){if($c->[0]eq '|'){$out .= '|'}elsif($c->[0]eq ' '){$out .= ' '}elsif($c->[0]eq 'L' or $c->[0]eq 'R'){my$start_print=$lines - $rows_in_column[$data_col];if (defined$rdata[$data_col][$l-$start_print]and $l >= $start_print){$out .= $rdata[$data_col][$l-$start_print]}else {$out .= ' 'x($self->{widths}[$data_col])}$data_col++}elsif($c->[0]eq 'l' or $c->[0]eq 'r'){if(defined$rdata[$data_col][$l]){$out .= $rdata[$data_col][$l]}else {$out .= ' 'x($self->{widths}[$data_col])}$data_col++}$col++}$out .= "\n"}return$out}sub _parse_format($$) {my ($self,$format)=@_;my@f=split(//,$format);my@format=();my@width=();my ($col,$data_col)=(0,0);my$wid;for my$f (@f){if ($f =~ /(\d+)/){$wid .= $f;next}if($f eq 'l' or $f eq 'L' or $f eq 'r' or $f eq 'R'){$format[$col]=[$f,$data_col];$width[$data_col]=$wid;$wid=undef;$data_col++}elsif($f eq '|' or $f eq ' '){$format[$col]=[$f]}else {croak "unknown column format: $f"}$col++}$self->{format}=\@format;$self->{fixed_widths}=\@width;$self->{col}=$col;$self->{data_col}=$data_col}sub new($$) {my ($class,$format)=@_;croak "new() requires one argument: format" unless defined$format;my$self={col=>'0',row=>'0',data=>[]};bless$self,$class;$self->_parse_format($format);return$self}sub _preprocess_row_data($$) {my ($self,$data)=@_;my$cn=0;for my$c (0..($#$data)){$data->[$c]=~ s/^\s+//m;$data->[$c]=~ s/\s+$//m}}sub head($@) {my ($self,@data)=@_;scalar@data==$self->{data_col}or croak "number of columns must be $self->{data_col}";$self->_preprocess_row_data(\@data);$self->{data}[$self->{row}++]=['head',\@data]}sub row($@) {my ($self,@data)=@_;scalar@data==$self->{data_col}or croak "number of columns must be $self->{data_col}";@data=map {defined $_ ? $_ : ""}@data;$self->_preprocess_row_data(\@data);$self->{data}[$self->{row}++]=['data',\@data]}sub rule($$) {my ($self,$char)=@_;$char='-' unless defined$char;$self->{data}[$self->{row}++]=['rule',$char]}sub render($$) {my ($self,$width)=@_;$width=79 unless defined$width;$self->_calculate_widths($width);my$out='';for my$r (@{$self->{data}}){if($r->[0]eq 'rule'){$out .= $self->_render_rule($r->[1])}elsif($r->[0]eq 'head'){$out .= $self->_render_data($r->[1])}elsif($r->[0]eq 'data'){$out .= $self->_render_data($r->[1])}}return$out}1;
TEXT_FORMATTABLE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

