#!/usr/bin/perl -T
#
# Copyright (C) 2010-2019 United States Government as represented by the
# Administrator of the National Aeronautics and Space Administration
# (NASA).  All Rights Reserved.
#
# This software is distributed under the NASA Open Source Agreement
# (NOSA), version 1.3.  The NOSA has been approved by the Open Source
# Initiative.  See http://www.opensource.org/licenses/nasa1.3.php
# for the complete NOSA document.
#
# THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY WARRANTY OF ANY
# KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT
# LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL CONFORM TO
# SPECIFICATIONS, ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
# A PARTICULAR PURPOSE, OR FREEDOM FROM INFRINGEMENT, ANY WARRANTY THAT
# THE SUBJECT SOFTWARE WILL BE ERROR FREE, OR ANY WARRANTY THAT
# DOCUMENTATION, IF PROVIDED, WILL CONFORM TO THE SUBJECT SOFTWARE. THIS
# AGREEMENT DOES NOT, IN ANY MANNER, CONSTITUTE AN ENDORSEMENT BY
# GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT OF ANY RESULTS, RESULTING
# DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER APPLICATIONS RESULTING
# FROM USE OF THE SUBJECT SOFTWARE.  FURTHER, GOVERNMENT AGENCY DISCLAIMS
# ALL WARRANTIES AND LIABILITIES REGARDING THIRD-PARTY SOFTWARE, IF
# PRESENT IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT "AS IS".
#
# RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS AGAINST THE UNITED STATES
# GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY PRIOR
# RECIPIENT.  IF RECIPIENT'S USE OF THE SUBJECT SOFTWARE RESULTS IN ANY
# LIABILITIES, DEMANDS, DAMAGES, EXPENSES OR LOSSES ARISING FROM SUCH USE,
# INCLUDING ANY DAMAGES FROM PRODUCTS BASED ON, OR RESULTING FROM,
# RECIPIENT'S USE OF THE SUBJECT SOFTWARE, RECIPIENT SHALL INDEMNIFY AND
# HOLD HARMLESS THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
# SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT, TO THE EXTENT PERMITTED
# BY LAW.  RECIPIENT'S SOLE REMEDY FOR ANY SUCH MATTER SHALL BE THE
# IMMEDIATE, UNILATERAL TERMINATION OF THIS AGREEMENT.
#

use strict;
require Crypt::CBC;
use Getopt::Long qw(:config bundling no_ignore_case require_order);
use IO::Socket;
use MIME::Base64;
use POSIX qw(setgid setuid);
use Storable qw(nfreeze);
use Sys::Hostname;

our $VERSION = 0.25;

# untaint PATH
$ENV{PATH} = "/bin:/usr/bin:/usr/local/bin";
# untaint insecure environment variables
delete $ENV{$_} foreach (qw(BASH_ENV CDPATH ENV IFS));

my %conf = (
    conf_file => "/etc/ballastrc",
    data_cipher => "XXTEA_PP",
    data_host_any => 0,
    data_port => 4411,
    data_timeout => 2,
    key_file => "/etc/ballast.key",
    random_wait => 0,
    user_load => 1,
);

# parse parameters
die "Invalid options\n" if (!GetOptions(\%conf,
    "conf_file|c=s", "no-wait", "stdin", "stdout"));

# parse configuration
open(FILE, $conf{conf_file}) or die "Unable to load config file: $!\n";
my $mline;
while (my $line = <FILE>) {
    # strip whitespace and comments
    $line =~ s/^\s+|\s+$|\s*#.*//g;
    next if (!$line);
    # support line continuation operator
    $mline .= $line;
    next if ($mline =~ s/\s*\\$/ /);
    if ($mline =~ /^(\S+)\s+(.*)/) {
        $conf{$1} = $2;
    }
    $mline = undef;
}
close FILE;
die "Data alias not defined\n" if (!$conf{data_alias});
die "Data host not defined\n" if (!$conf{data_host});

if (-e $conf{key_file}) {
    open(FILE, $conf{key_file}) or die "Unable to load key file: $!\n";
    my $key = <FILE>;
    close FILE;

    # untaint key
    $key = $1 if ($key =~ /(.*)/);

    my %cbc = (
        -key => $key,
        -cipher => $conf{data_cipher},
    );
    $cbc{-keysize} = 16 if ($conf{data_cipher} eq 'XXTEA_PP');
    $conf{-cbc} = Crypt::CBC->new(%cbc);
}

goto SEND if ($conf{stdin});

# sleep random amount of time
if (!$conf{'no-wait'} && $conf{random_wait} > 0) {
    sleep int(rand($conf{random_wait}));
}

my %load;
# collect per user load (before dropping privilege so can read /proc/pid/io)
if ($conf{user_load}) {
    foreach my $file (glob("/proc/[0-9]*/stat")) {
        open(FILE, $file) or next;
        my $line = <FILE>;
        close FILE;
        my @cols = split(/\s+/, $line);
        my $pid = $cols[0];
        my @stat = stat "/proc/$pid";
        my $cmd = $cols[1];
        $cmd =~ s/\s+|[{}()]//g;

        # ignore root processes that are not sshd or dropbear
        next if ($stat[4] == 0 && $cmd !~ /^(?:sshd|dropbear)$/);

        my $proc = "cmd:$cmd";
        $proc .= " cpu:" . ($cols[13] + $cols[14]);
        $proc .= " gid:$stat[5]";
        $proc .= " mem:$cols[22]";
        $proc .= " ram:$cols[23]";
        $proc .= " pid:$pid";
        $proc .= " ppid:$cols[3]";
        $proc .= " time:" .
            ($load{time} - $load{boot_time} - int($cols[21] / 100));
        $proc .= " uid:$stat[4]";

        # collect per user i/o load if available
        # (agent must run as root to access this info)
        if ($> == 0 && open(FILE, "/proc/$pid/io")) {
            my ($bytes, $ops);
            while (my $line = <FILE>) {
                if ($line =~ /^rchar:\s*(\d+)/) {
                    $proc .= " io_read_bytes:$1";
                    $bytes += $1;
                } elsif ($line =~ /^wchar:\s*(\d+)/) {
                    $proc .= " io_write_bytes:$1";
                    $bytes += $1;
                } elsif ($line =~ /^syscr:\s*(\d+)/) {
                    $proc .= " io_reads:$1";
                    $ops += $1;
                } elsif ($line =~ /^syscw:\s*(\d+)/) {
                    $proc .= " io_writes:$1";
                    $ops += $1;
                }
            }
            $proc .= " io_ops:$ops";
            $proc .= " io_bytes:$bytes";
        }
        $load{"pid_$pid"} = $proc;
    }
}

# execute user-defined hook as root if specified
if (-x $conf{root_hook} && open(FILE, "$conf{root_hook}|")) {
    while (my $line = <FILE>) {
        $line =~ s/^\s*(?:#.*)?|\s+$//g;
        if ($line =~ /^(\S+)\s+(.*)/) {
            $load{$1} = $2;
        }
    }
    close FILE;
}

# change group and/or user if specified
if ($conf{run_group}) {
    my $gid = getgrnam($conf{run_group});
    setgid($gid) if (defined $gid);
    die "Unable to change run group\n"
        if (!defined $gid || $( != $gid || $) != $gid);
}
if ($conf{run_user}) {
    my $uid = getpwnam($conf{run_user});
    setuid($uid) if (defined $uid);
    die "Unable to change run user\n"
        if (!defined $uid || $< != $uid || $> != $uid);
}

$load{alias} = $conf{data_alias};
$load{host} = (gethostbyname(hostname))[0];

if ($conf{use_ip_address}) {
    # reference host by ip address instead of host name
    require Net::Address::IP::Local;
    $load{host} = eval {Net::Address::IP::Local->public};
    die "Unable to determine IP address\n" if ($@);
}

$load{time} = time;

# collect i/o load
if (open(FILE, "/proc/diskstats")) {
    while (my $line = <FILE>) {
        $line =~ s/^\s+|\s+$//g;
        my @cols = split(/\s+/, $line);
        splice(@cols, 0, 3);
        next if (scalar(@cols) < 11);
        $load{d_io_reads} += $cols[0];
        $load{d_io_read_sectors} += $cols[2];
        $load{d_io_read_time} += $cols[3];
        $load{d_io_writes} += $cols[4];
        $load{d_io_write_sectors} += $cols[6];
        $load{d_io_write_time} += $cols[7];
    }
    close FILE;
    $load{d_io_ops} = $load{d_io_reads} + $load{d_io_writes};
    $load{d_io_sectors} = $load{d_io_read_sectors} + $load{d_io_write_sectors};
    $load{d_io_time} = $load{d_io_read_time} + $load{d_io_write_time};
}

# collect average load and processes
if (open(FILE, "/proc/loadavg")) {
    while (my $line = <FILE>) {
        $line =~ s/^\s+|\s+$//g;
        my @cols = split(/\s+/, $line);
        next if (scalar(@cols) != 5);
        $load{load_1} = $cols[0];
        $load{load_5} = $cols[1];
        $load{load_15} = $cols[2];
        $load{procs} = $cols[3];
        $load{procs} =~ s/.*\///;
    }
    close FILE;
}

# collect memory load
if (open(FILE, "/proc/meminfo")) {
    while (my $line = <FILE>) {
        $line =~ s/^\s+|\s+$//g;
        $load{ram_free} = $1 if ($line =~ /MemFree:\s*(\d+)/);
        $load{ram_total} = $1 if ($line =~ /MemTotal:\s*(\d+)/);
        $load{swap_free} = $1 if ($line =~ /SwapFree:\s*(\d+)/);
        $load{swap_total} = $1 if ($line =~ /SwapTotal:\s*(\d+)/);
    }
    $load{ram} = $load{ram_total} - $load{ram_free};
    $load{swap} = $load{swap_total} - $load{swap_free};
    close FILE;
}

# collect network load
if (open(FILE, "/proc/net/dev")) {
    while (my $line = <FILE>) {
        $line =~ s/^\s+|\s+$//g;
        my @cols = split(/:\s*|\s+/, $line);
        next if (scalar(@cols) != 17 || $cols[1] !~ /^\d+$/);
        $load{d_net_read_bytes} += $cols[1];
        $load{d_net_reads} += $cols[2];
        $load{d_net_write_bytes} += $cols[9];
        $load{d_net_writes} += $cols[10];
    }
    close FILE;
    $load{d_net_ops} = $load{d_net_reads} + $load{d_net_writes};
    $load{d_net_bytes} = $load{d_net_read_bytes} + $load{d_net_write_bytes};
}

# collect cpu and other misc load
if (open(FILE, "/proc/stat")) {
    while (my $line = <FILE>) {
        $line =~ s/^\s+|\s+$//g;
        $load{boot_time} = $1 if ($line =~ /^btime\s+(\d+)/);
        $load{d_cpu} += $1 + $2 + $3 if ($line =~ /^cpu\s+(\d+)\s+(\d+)\s+(\d+)/);
        $load{d_intrs} = $1 if ($line =~ /^intr\s+(\d+)/);
        $load{d_proc_switches} = $1 if ($line =~ /^ctxt\s+(\d+)/);
        $load{d_proc_forks} = $1 if ($line =~ /^processes\s+(\d+)/);
        $load{uptime} = $load{time} - $load{boot_time};
        $load{cpus}++ if ($line =~ /^cpu\d+/);
    }
    close FILE;
}

# collect virtual memory load
if (open(FILE, "/proc/vmstat")) {
    while (my $line = <FILE>) {
        $line =~ s/^\s+|\s+$//g;
        $load{d_page_in} += $1 if ($line =~ /^pgpgin\s+(\d+)/);
        $load{d_page_out} += $1 if ($line =~ /^pgpgout\s+(\d+)/);
        $load{d_swap_in} += $1 if ($line =~ /^pswpin\s+(\d+)/);
        $load{d_swap_out} += $1 if ($line =~ /^pswpout\s+(\d+)/);
    }
    close FILE;
}

# execute user-defined hook if specified
if (-x $conf{load_hook} && open(FILE, "$conf{load_hook}|")) {
    while (my $line = <FILE>) {
        $line =~ s/^\s*(?:#.*)?|\s+$//g;
        if ($line =~ /^(\S+)\s+(.*)/) {
            $load{$1} = $2;
        }
    }
    close FILE;
}

SEND:

my $data;
if ($conf{stdin}) {
    $data .= $_ while (<STDIN>);
} else {
    # convert load to single data string
    $data = "#ballast#" . nfreeze(\%load);
    if (defined $conf{-cbc}) {
        # encrypt data if specified
        $data = $conf{-cbc}->encrypt_hex($data);
    } else {
        $data = encode_base64($data, "");
    }
}

if ($conf{stdout}) {
    print $data;
    exit;
}

# send data to each server specified
foreach my $host (split(/\s+/, $conf{data_host})) {
    eval {
        local $SIG{ALRM} = sub {die "alarm\n"};
        alarm $conf{data_timeout};
        my $sock = IO::Socket::INET->new(
            Proto    => 'tcp',
            PeerAddr => $host,
            PeerPort => $conf{data_port},
        );
        if ($sock) {
            print $sock "#$data\n";
            close $sock;
            # stop sending data when transmit succeeds to any equivalent host
            last if ($conf{data_host_any});
        } else {
            print STDERR "Unable to contact server $host\n";
        }
    };
    print STDERR "Timed out communicating with server $host\n"
        if ($@ eq "alarm\n");
}
alarm 0;

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Crypt/CBC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CRYPT_CBC';
  package Crypt::CBC;use Digest::MD5 'md5';use Carp;use strict;use bytes;use vars qw($VERSION);$VERSION='2.33';use constant RANDOM_DEVICE=>'/dev/urandom';sub new {my$class=shift;my$options={};if (ref $_[0]eq 'HASH'){$options=shift}elsif ($_[0]=~ /^-[a-zA-Z_]{1,20}$/){my%tmp=@_;while (my($key,$value)=each%tmp){$key =~ s/^-//;$options->{lc$key}=$value}}else {$options->{key}=shift;$options->{cipher}=shift}my$cipher_object_provided=$options->{cipher}&& ref$options->{cipher};my$pass=$options->{key};if ($cipher_object_provided){carp "Both a key and a pre-initialized Crypt::* object were passed. The key will be ignored" if defined$pass;$pass ||=''}elsif (!defined$pass){croak "Please provide an encryption/decryption passphrase or key using -key"}my%valid_modes=map {$_=>1}qw(none salt randomiv);my$header_mode=$options->{header};$header_mode ||='none' if exists$options->{prepend_iv}&&!$options->{prepend_iv};$header_mode ||='none' if exists$options->{add_header}&&!$options->{add_header};$header_mode ||='salt';croak "Invalid -header mode '$header_mode'" unless$valid_modes{$header_mode};croak "The -salt argument is incompatible with a -header mode of $header_mode" if exists$options->{salt}&& $header_mode ne 'salt';my$cipher=$options->{cipher};$cipher='Crypt::DES' unless$cipher;my$cipherclass=ref$cipher || $cipher;unless (ref$cipher){$cipher=$cipher=~/^Crypt::/ ? $cipher : "Crypt::$cipher";$cipher->can('encrypt')or eval "require $cipher; 1" or croak "Couldn't load $cipher: $@";$cipher =~ s/^Crypt::// unless$cipher->can('keysize')}my$ks=$options->{keysize};my$bs=$options->{blocksize};$ks ||=eval {$cipher->keysize};$bs ||=eval {$cipher->blocksize};$ks ||=$cipherclass =~ /blowfish/i ? 56 : 8;$bs ||=$ks;my$pcbc=$options->{'pcbc'};croak "The options -literal_key and -regenerate_key are incompatible with each other" if exists$options->{literal_key}&& exists$options->{regenerate_key};my$key;$key=$pass if$options->{literal_key};$key=$pass if exists$options->{regenerate_key}&&!$options->{regenerate_key};my$salt=$options->{salt};my$random_salt=1 unless defined$salt && $salt ne '1';croak "Argument to -salt must be exactly 8 bytes long" if defined$salt && length$salt!=8 && $salt ne '1';my$iv=$options->{iv};my$random_iv=1 unless defined$iv;croak "Initialization vector must be exactly $bs bytes long when using the $cipherclass cipher" if defined$iv and length($iv)!=$bs;my$literal_key=$options->{literal_key}|| (exists$options->{regenerate_key}&&!$options->{regenerate_key});my$legacy_hack=$options->{insecure_legacy_decrypt};my$padding=$options->{padding}|| 'standard';if ($padding && ref($padding)eq 'CODE'){for my$i (1..$bs-1){my$rbs=length($padding->(" "x$i,$bs,'e'));croak "padding method callback does not behave properly: expected $bs bytes back, got $rbs bytes back." unless ($rbs==$bs)}}else {$padding=$padding eq 'none' ? \&_no_padding :$padding eq 'null' ? \&_null_padding :$padding eq 'space' ? \&_space_padding :$padding eq 'oneandzeroes' ? \&_oneandzeroes_padding :$padding eq 'rijndael_compat'? \&_rijndael_compat :$padding eq 'standard' ? \&_standard_padding :croak "'$padding' padding not supported.  See perldoc Crypt::CBC for instructions on creating your own."}if ($header_mode eq 'salt'){croak "Cannot use salt-based key generation if literal key is specified" if$options->{literal_key};croak "Cannot use salt-based IV generation if literal IV is specified" if exists$options->{iv}}elsif ($header_mode eq 'randomiv'){croak "Cannot encrypt using a non-8 byte blocksize cipher when using randomiv header mode" unless$bs==8 || $legacy_hack}elsif ($header_mode eq 'none'){croak "You must provide an initialization vector using -iv when using -header=>'none'" unless exists$options->{iv}}if (defined$key && length($key)!=$ks){croak "If specified by -literal_key, then the key length must be equal to the chosen cipher's key length of $ks bytes"}if (defined$iv && length($iv)!=$bs){croak "If specified by -iv, then the initialization vector length must be equal to the chosen cipher's blocksize of $bs bytes"}return bless {'cipher'=>$cipher,'passphrase'=>$pass,'key'=>$key,'iv'=>$iv,'salt'=>$salt,'padding'=>$padding,'blocksize'=>$bs,'keysize'=>$ks,'header_mode'=>$header_mode,'legacy_hack'=>$legacy_hack,'literal_key'=>$literal_key,'pcbc'=>$pcbc,'make_random_salt'=>$random_salt,'make_random_iv'=>$random_iv,},$class}sub encrypt (\$$) {my ($self,$data)=@_;$self->start('encrypting');my$result=$self->crypt($data);$result .= $self->finish;$result}sub decrypt (\$$){my ($self,$data)=@_;$self->start('decrypting');my$result=$self->crypt($data);$result .= $self->finish;$result}sub encrypt_hex (\$$) {my ($self,$data)=@_;return join('',unpack 'H*',$self->encrypt($data))}sub decrypt_hex (\$$) {my ($self,$data)=@_;return$self->decrypt(pack'H*',$data)}sub start (\$$) {my$self=shift;my$operation=shift;croak "Specify <e>ncryption or <d>ecryption" unless$operation=~/^[ed]/i;$self->{'buffer'}='';$self->{'decrypt'}=$operation=~/^d/i}sub crypt (\$$){my$self=shift;my$data=shift;my$result;croak "crypt() called without a preceding start()" unless exists$self->{'buffer'};my$d=$self->{'decrypt'};unless ($self->{civ}){$result=$self->_generate_iv_and_cipher_from_datastream(\$data)if$d;$result=$self->_generate_iv_and_cipher_from_options()unless$d}my$iv=$self->{'civ'};$self->{'buffer'}.= $data;my$bs=$self->{'blocksize'};croak "When using no padding, plaintext size must be a multiple of $bs" if$self->{'padding'}eq \&_no_padding and length($data)% $bs;croak "When using rijndael_compat padding, plaintext size must be a multiple of $bs" if$self->{'padding'}eq \&_rijndael_compat and length($data)% $bs;return$result unless (length($self->{'buffer'})>= $bs);my@blocks=unpack("a$bs "x(int(length($self->{'buffer'})/$bs))."a*",$self->{'buffer'});$self->{'buffer'}='';if ($d){$self->{'buffer'}=length($blocks[-1])< $bs ? join '',splice(@blocks,-2): pop(@blocks)}else {$self->{'buffer'}=pop@blocks if length($blocks[-1])< $bs}for my$block (@blocks){if ($d){$result .= $iv=$iv ^ $self->{'crypt'}->decrypt($block);$iv=$block unless$self->{pcbc}}else {$result .= $iv=$self->{'crypt'}->encrypt($iv ^ $block)}$iv=$iv ^ $block if$self->{pcbc}}$self->{'civ'}=$iv;return$result}sub finish (\$) {my$self=shift;my$bs=$self->{'blocksize'};my$block=defined$self->{'buffer'}? $self->{'buffer'}: '';$self->{civ}||='';my$result;if ($self->{'decrypt'}){$block=length$block ? pack("a$bs",$block): '';if (length($block)){$result=$self->{'civ'}^ $self->{'crypt'}->decrypt($block);$result=$self->{'padding'}->($result,$bs,'d')}else {$result=''}}else {$block=$self->{'padding'}->($block,$bs,'e')|| '';$result=length$block ? $self->{'crypt'}->encrypt($self->{'civ'}^ $block): ''}delete$self->{'civ'};delete$self->{'buffer'};return$result}sub _generate_iv_and_cipher_from_datastream {my$self=shift;my$input_stream=shift;my$bs=$self->blocksize;my$header_mode=$self->header_mode;if ($header_mode eq 'none'){croak "You must specify a $bs byte initialization vector by passing the -iv option to new() when using -header_mode=>'none'" unless exists$self->{iv};$self->{civ}=$self->{iv};$self->{key}||=$self->_key_from_key($self->{passphrase})}elsif ($header_mode eq 'salt'){my ($salt)=$$input_stream =~ /^Salted__(.{8})/s;croak "Ciphertext does not begin with a valid header for 'salt' header mode" unless defined$salt;$self->{salt}=$salt;substr($$input_stream,0,16)='';my ($key,$iv)=$self->_salted_key_and_iv($self->{passphrase},$salt);$self->{iv}=$self->{civ}=$iv;$self->{key}=$key}elsif ($header_mode eq 'randomiv'){my ($iv)=$$input_stream =~ /^RandomIV(.{8})/s;croak "Ciphertext does not begin with a valid header for 'randomiv' header mode" unless defined$iv;croak "randomiv header mode cannot be used securely when decrypting with a >8 byte block cipher.\nUse the -insecure_legacy_decrypt flag if you are sure you want to do this" unless$self->blocksize==8 || $self->legacy_hack;$self->{iv}=$self->{civ}=$iv;$self->{key}=$self->_key_from_key($self->{passphrase});undef$self->{salt};substr($$input_stream,0,16)=''}else {croak "Invalid header mode '$header_mode'"}croak "Cipher stream did not contain IV or salt, and you did not specify these values in new()" unless$self->{key}&& $self->{civ};$self->{crypt}=ref$self->{cipher}? $self->{cipher}: $self->{cipher}->new($self->{key})or croak "Could not create $self->{cipher} object: $@";return ''}sub _generate_iv_and_cipher_from_options {my$self=shift;my$blocksize=$self->blocksize;my$result='';my$header_mode=$self->header_mode;if ($header_mode eq 'none'){croak "You must specify a $blocksize byte initialization vector by passing the -iv option to new() when using -header_mode=>'none'" unless exists$self->{iv};$self->{civ}=$self->{iv};$self->{key}||=$self->_key_from_key($self->{passphrase})}elsif ($header_mode eq 'salt'){$self->{salt}=$self->_get_random_bytes(8)if$self->{make_random_salt};defined (my$salt=$self->{salt})or croak "No header_mode of 'salt' specified, but no salt value provided";length($salt)==8 or croak "Salt must be exactly 8 bytes long";my ($key,$iv)=$self->_salted_key_and_iv($self->{passphrase},$salt);$self->{key}=$key;$self->{civ}=$self->{iv}=$iv;$result="Salted__${salt}"}elsif ($header_mode eq 'randomiv'){croak "randomiv header mode cannot be used when encrypting with a >8 byte block cipher. There is no option to allow this" unless$blocksize==8;$self->{key}||=$self->_key_from_key($self->{passphrase});$self->{iv}=$self->_get_random_bytes(8)if$self->{make_random_iv};length($self->{iv})==8 or croak "IV must be exactly 8 bytes long when used with header mode of 'randomiv'";$self->{civ}=$self->{iv};$result="RandomIV$self->{iv}"}croak "key and/or iv are missing" unless defined$self->{key}&& defined$self->{civ};$self->_taintcheck($self->{key});$self->{crypt}=ref$self->{cipher}? $self->{cipher}: $self->{cipher}->new($self->{key})or croak "Could not create $self->{cipher} object: $@";return$result}sub _taintcheck {my$self=shift;my$key=shift;return unless ${^TAINT};my$has_scalar_util=eval "require Scalar::Util; 1";my$tainted;if ($has_scalar_util){$tainted=Scalar::Util::tainted($key)}else {local($@,$SIG{__DIE__},$SIG{__WARN__});local $^W=0;eval {kill 0 * $key};$tainted=$@ =~ /^Insecure/}croak "Taint checks are turned on and your key is tainted. Please untaint the key and try again" if$tainted}sub _key_from_key {my$self=shift;my$pass=shift;my$ks=$self->{keysize};return$pass if$self->{literal_key};my$material=md5($pass);while (length($material)< $ks){$material .= md5($material)}return substr($material,0,$ks)}sub _salted_key_and_iv {my$self=shift;my ($pass,$salt)=@_;croak "Salt must be 8 bytes long" unless length$salt==8;my$key_len=$self->{keysize};my$iv_len=$self->{blocksize};my$desired_len=$key_len+$iv_len;my$data='';my$d='';while (length$data < $desired_len){$d=md5($d .$pass .$salt);$data .= $d}return (substr($data,0,$key_len),substr($data,$key_len,$iv_len))}sub random_bytes {my$self=shift;my$bytes=shift or croak "usage: random_bytes(\$byte_length)";$self->_get_random_bytes($bytes)}sub _get_random_bytes {my$self=shift;my$length=shift;my$result;if (-r RANDOM_DEVICE && open(F,RANDOM_DEVICE)){read(F,$result,$length);close F}else {$result=pack("C*",map {rand(256)}1..$length)}$result =~ /^(.+)$/s;length($1)==$length or croak "Invalid length while gathering $length random bytes";return $1}sub _standard_padding ($$$) {my ($b,$bs,$decrypt)=@_;$b=length$b ? $b : '';if ($decrypt eq 'd'){my$pad_length=unpack("C",substr($b,-1));return$b unless$pad_length >= 0 && $pad_length <= $bs;my@pad_chars=unpack("C*",substr($b,-$pad_length));return$b if grep {$pad_length!=$_}@pad_chars;return substr($b,0,$bs-$pad_length)}my$pad=$bs - length($b)% $bs;return$b .pack("C*",($pad)x$pad)}sub _space_padding ($$$) {my ($b,$bs,$decrypt)=@_;return unless length$b;$b=length$b ? $b : '';if ($decrypt eq 'd'){$b=~ s/ *\z//s;return$b}return$b .pack("C*",(32)x ($bs - length($b)% $bs))}sub _no_padding ($$$) {my ($b,$bs,$decrypt)=@_;return$b}sub _null_padding ($$$) {my ($b,$bs,$decrypt)=@_;return unless length$b;$b=length$b ? $b : '';if ($decrypt eq 'd'){$b=~ s/\0*\z//s;return$b}return$b .pack("C*",(0)x ($bs - length($b)% $bs))}sub _oneandzeroes_padding ($$$) {my ($b,$bs,$decrypt)=@_;$b=length$b ? $b : '';if ($decrypt eq 'd'){$b=~ s/\x80\0*\z//s;return$b}return$b .pack("C*",128,(0)x ($bs - length($b)% $bs - 1))}sub _rijndael_compat ($$$) {my ($b,$bs,$decrypt)=@_;return unless length$b;if ($decrypt eq 'd'){$b=~ s/\x80\0*\z//s;return$b}return$b .pack("C*",128,(0)x ($bs - length($b)% $bs - 1))}sub get_initialization_vector (\$) {my$self=shift;$self->iv()}sub set_initialization_vector (\$$) {my$self=shift;my$iv=shift;my$bs=$self->blocksize;croak "Initialization vector must be $bs bytes in length" unless length($iv)==$bs;$self->iv($iv)}sub salt {my$self=shift;my$d=$self->{salt};$self->{salt}=shift if @_;$d}sub iv {my$self=shift;my$d=$self->{iv};$self->{iv}=shift if @_;$d}sub key {my$self=shift;my$d=$self->{key};$self->{key}=shift if @_;$d}sub passphrase {my$self=shift;my$d=$self->{passphrase};if (@_){undef$self->{key};undef$self->{iv};$self->{passphrase}=shift}$d}sub cipher {shift->{cipher}}sub padding {shift->{padding}}sub keysize {shift->{keysize}}sub blocksize {shift->{blocksize}}sub pcbc {shift->{pcbc}}sub header_mode {shift->{header_mode}}sub legacy_hack {shift->{legacy_hack}}1;
CRYPT_CBC

$fatpacked{"Crypt/Twofish_PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CRYPT_TWOFISH_PP';
  package Crypt::Twofish_PP;use strict;use integer;use vars qw ($VERSION);$VERSION='0.17';my@q0=(169,103,179,232,4,253,163,118,154,146,128,120,228,221,209,56,13,198,53,152,24,247,236,108,67,117,55,38,250,19,148,72,242,208,139,48,132,84,223,35,25,91,61,89,243,174,162,130,99,1,131,46,217,81,155,124,166,235,165,190,22,12,227,97,192,140,58,245,115,44,37,11,187,78,137,107,83,106,180,241,225,230,189,69,226,244,182,102,204,149,3,86,212,28,30,215,251,195,142,181,233,207,191,186,234,119,57,175,51,201,98,113,129,121,9,173,36,205,249,216,229,197,185,77,68,8,134,231,161,29,170,237,6,112,178,210,65,123,160,17,49,194,39,144,32,246,96,255,150,92,177,171,158,156,82,27,95,147,10,239,145,133,73,238,45,79,143,59,71,135,109,70,214,62,105,100,42,206,203,47,252,151,5,122,172,127,213,26,75,14,167,90,40,20,63,41,136,60,76,2,184,218,176,23,85,31,138,125,87,199,141,116,183,196,159,114,126,21,34,18,88,7,153,52,110,80,222,104,101,188,219,248,200,168,43,64,220,254,50,164,202,16,33,240,211,93,15,0,111,157,54,66,74,94,193,224);my@q1=(117,243,198,244,219,123,251,200,74,211,230,107,69,125,232,75,214,50,216,253,55,113,241,225,48,15,248,27,135,250,6,63,94,186,174,91,138,0,188,157,109,193,177,14,128,93,210,213,160,132,7,20,181,144,44,163,178,115,76,84,146,116,54,81,56,176,189,90,252,96,98,150,108,66,247,16,124,40,39,140,19,149,156,199,36,70,59,112,202,227,133,203,17,208,147,184,166,131,32,255,159,119,195,204,3,111,8,191,64,231,43,226,121,12,170,130,65,58,234,185,228,154,164,151,126,218,122,23,102,148,161,29,61,240,222,179,11,114,167,28,239,209,83,62,143,51,38,95,236,118,42,73,129,136,238,33,196,26,235,217,197,57,153,205,173,49,139,1,24,35,221,31,78,45,249,72,79,242,101,142,120,92,88,25,141,229,152,87,103,127,5,100,175,99,182,254,245,183,60,165,206,233,104,68,224,77,67,105,41,46,172,21,89,168,10,158,110,71,223,52,53,106,207,220,34,201,192,155,137,212,237,171,18,162,13,82,187,2,47,169,215,97,30,180,80,4,246,194,22,37,134,86,85,9,190,145);my@m0=(3166450293,3974898163,538985414,3014904308,3671720923,33721211,3806473211,2661219016,3385453642,3570665939,404253670,505323371,2560101957,2998024317,2795950824,640071499,1010587606,2475919922,2189618904,1381144829,2071712823,3149608817,1532729329,1195869153,606354480,1364320783,3132802808,1246425883,3216984199,218984698,2964370182,1970658879,3537042782,2105352378,1717973422,976921435,1499012234,0,3452801980,437969053,2930650221,2139073473,724289457,3200170254,3772817536,2324303965,993743570,1684323029,3638069408,3890718084,1600120839,454758676,741130933,4244419728,825304876,2155898275,1936927410,202146163,2037997388,1802191188,1263207058,1397975412,2492763958,2206408529,707409464,3301219504,572704957,3587569754,3183330300,1212708960,4294954594,1280051094,1094809452,3351766594,3958056183,471602192,1566401404,909517352,1734852647,3924406156,1145370899,336915093,4126522268,3486456007,1061104932,3233866566,1920129851,1414818928,690572490,4042274275,134807173,3334870987,4092808977,2358043856,2762234259,3402274488,1751661478,3099086211,943204384,3857002239,2913818271,185304183,3368558019,2577006540,1482222851,421108335,235801096,2509602495,1886408768,4160172263,1852755755,522153698,3048553849,151588620,1633760426,1465325186,2678000449,2644344890,286352618,623234489,2947538404,1162152090,3755969956,2745392279,3941258622,892688602,3991785594,1128528919,4177054566,4227576212,926405537,4210704413,3267520573,3031747824,842161630,2627498419,1448535819,3823360626,2273796263,353704732,4193860335,1667481553,875866451,2593817918,2981184143,2088554803,2290653990,1027450463,2711738348,3840204662,2172752938,2442199369,252705665,4008618632,370565614,3621221153,2543318468,2779097114,4278075371,1835906521,2021174981,3318050105,488498585,1987486925,1044307117,3419105073,3065399179,4025441025,303177240,1616954659,1785376989,1296954911,3469666638,3739122733,1431674361,2122209864,555856463,50559730,2694850149,1583225230,1515873912,1701137244,1650609752,4261233945,101119117,1077970661,4075994776,859024471,387420263,84250239,3907542533,1330609508,2307484335,269522275,1953771446,168457726,1549570805,2610656439,757936956,808507045,774785486,1229556201,1179021928,2004309316,2829637856,2526413901,673758531,2846435689,3654908201,2256965934,3520169900,4109650453,2374833497,3604382376,3115957258,1111625118,4143366510,791656519,3722249951,589510964,3435946549,4059153514,3250655951,2240146396,2408554018,1903272393,2425417920,2863289243,16904585,2341200340,1313770733,2391699371,2880152082,1869561506,3873854477,3688624722,2459073467,3082270210,1768540719,960092585,3553823959,2812748641,2728570142,3284375988,1819034704,117900548,67403766,656885442,2896996118,3503322661,1347425158,3705468758,2223250005,3789639945,2054825406,320073617);my@m1=(2849585465,1737496343,3010567324,3906119334,67438343,4254618194,2741338240,1994384612,2584233285,2449623883,2158026976,2019973722,3839733679,3719326314,3518980963,943073834,223667942,3326287904,895667404,2562650866,404623890,4146392043,3973554593,1819754817,1136470056,1966259388,936672123,647727240,4201647373,335103044,2494692347,1213890174,4068082435,3504639116,2336732854,809247780,2225465319,1413573483,3741769181,600137824,424017405,1537423930,1030275778,1494584717,4079086828,2922473062,2722000751,2182502231,1670713360,22802415,2202908856,781289094,3652545901,1361019779,2605951658,2086886749,2788911208,3946839806,2782277680,3190127226,380087468,202311945,3811963120,1629726631,3236991120,2360338921,981507485,4120009820,1937837068,740766001,628543696,199710294,3145437842,1323945678,2314273025,1805590046,1403597876,1791291889,3029976003,4053228379,3783477063,3865778200,3184009762,1158584472,3798867743,4106859443,3056563316,1724643576,3439303065,2515145748,65886296,1459084508,3571551115,471536917,514695842,3607942099,4213957346,3273509064,2384027230,3049401388,3918088521,3474112961,3212744085,3122691453,3932426513,2005142283,963495365,2942994825,869366908,3382800753,1657733119,1899477947,2180714255,2034087349,156361185,2916892222,606945087,3450107510,4187837781,3639509634,3850780736,3316545656,3117229349,1292146326,1146451831,134876686,2249412688,3878746103,2714974007,490797818,2855559521,3985395278,112439472,1886147668,2989126515,3528604475,1091280799,2072707586,2693322968,290452467,828885963,3259377447,666920807,2427780348,539506744,4135519236,1618495560,4281263589,2517060684,1548445029,2982619947,2876214926,2651669058,2629563893,1391647707,468929098,1604730173,2472125604,180140473,4013619705,2448364307,2248017928,1224839569,3999340054,763158238,1337073953,2403512753,1004237426,1203253039,2269691839,1831644846,1189331136,3596041276,1048943258,1764338089,1685933903,714375553,3460902446,3407333062,801794409,4240686525,2539430819,90106088,2060512749,2894582225,2140013829,3585762404,447260069,1270294054,247054014,2808121223,1526257109,673330742,336665371,1071543669,695851481,2292903662,1009986861,1281325433,45529015,3096890058,3663213877,2963064004,402408259,1427801220,536235341,2317113689,2100867762,1470903091,3340292047,2381579782,1953059667,3077872539,3304429463,2673257901,1926947811,2127948522,357233908,580816783,312650667,1481532002,132669279,2581929245,876159779,1858205430,1346661484,3730649650,1752319558,1697030304,3163803085,3674462938,4173773498,3371867806,2827146966,735014510,1079013488,3706422661,4269083146,847942547,2760761311,3393988905,269753372,561240023,4039947444,3540636884,1561365130,266490193,0,1872369945,2648709658,915379348,1122420679,1257032137,1593692882,3249241983,3772295336);my@m2=(3161832498,3975408673,549855299,3019158473,3671841283,41616011,3808158251,2663948026,3377121772,3570652169,417732715,510336671,2554697742,2994582072,2800264914,642459319,1020673111,2469565322,2195227374,1392333464,2067233748,3144792887,1542544279,1205946243,607134780,1359958498,3136862918,1243302643,3213344584,234491248,2953228467,1967093214,3529429757,2109373728,1722705457,979057315,1502239004,0,3451702675,446503648,2926423596,2143387563,733031367,3188637369,3766542496,2321386000,1003633490,1691706554,3634419848,3884246949,1594318824,454302481,750070978,4237360308,824979751,2158198885,1941074730,208866433,2035054943,1800694593,1267878658,1400132457,2486604943,2203157279,708323894,3299919004,582820552,3579500024,3187457475,1214269560,4284678094,1284918279,1097613687,3343042534,3958893348,470817812,1568431459,908604962,1730635712,3918326191,1142113529,345314538,4120704443,3485978392,1059340077,3225862371,1916498651,1416647788,701114700,4041470005,142936318,3335243287,4078039887,2362477796,2761139289,3401108118,1755736123,3095640141,941635624,3858752814,2912922966,192351108,3368273949,2580322815,1476614381,426711450,235408906,2512360830,1883271248,4159174448,1848340175,534912878,3044652349,151783695,1638555956,1468159766,2671877899,2637864320,300552548,632890829,2951000029,1167738120,3752124301,2744623964,3934186197,903492952,3984256464,1125598204,4167497931,4220844977,933312467,4196268608,3258827368,3035673804,853422685,2629016689,1443583719,3815957466,2275903328,354161947,4193253690,1674666943,877868201,2587794053,2978984258,2083749073,2284226715,1029651878,2716639703,3832997087,2167046548,2437517569,260116475,4001951402,384702049,3609319283,2546243573,2769986984,4276878911,1842965941,2026207406,3308897645,496573925,1993176740,1051541212,3409038183,3062609479,4009881435,303567390,1612931269,1792895664,1293897206,3461271273,3727548028,1442403741,2118680154,558834098,66192250,2691014694,1586388505,1517836902,1700554059,1649959502,4246338885,109905652,1088766086,4070109886,861352876,392632208,92210574,3892701278,1331974013,2309982570,274927765,1958114351,184420981,1559583890,2612501364,758918451,816132310,785264201,1240025481,1181238898,2000975701,2833295576,2521667076,675489981,2842274089,3643398521,2251196049,3517763975,4095079498,2371456277,3601389186,3104487868,1117667853,4134467265,793194424,3722435846,590619449,3426077794,4050317764,3251618066,2245821931,2401406878,1909027233,2428539120,2862328403,25756145,2345962465,1324174988,2393607791,2870127522,1872916286,3859670612,3679640562,2461766267,3070408630,1764714954,967391705,3554136844,2808194851,2719916717,3283403673,1817209924,117704453,83231871,667035462,2887167143,3492139126,1350979603,3696680183,2220196890,3775521105,2059303461,328274927);my@m3=(3644434905,2417452944,1906094961,3534153938,84345861,2555575704,1702929253,3756291807,138779144,38507010,2699067552,1717205094,3719292125,2959793584,3210990015,908736566,1424362836,1126221379,1657550178,3203569854,504502302,619444004,3617713367,2000776311,3173532605,851211570,3564845012,2609391259,1879964272,4181988345,2986054833,1518225498,2047079034,3834433764,1203145543,1009004604,2783413413,1097552961,115203846,3311412165,1174214981,2738510755,1757560168,361584917,569176865,828812849,1047503422,374833686,2500879253,1542390107,1303937869,2441490065,3043875253,528699679,1403689811,1667071075,996714043,1073670975,3593512406,628801061,2813073063,252251151,904979253,598171939,4036018416,2951318703,2157787776,2455565714,2165076865,657533991,1993352566,3881176039,2073213819,3922611945,4043409905,2669570975,2838778793,3304155844,2579739801,2539385239,2202526083,1796793963,3357720008,244860174,1847583342,3384014025,796177967,3422054091,4288269567,3927217642,3981968365,4158412535,3784037601,454368283,2913083053,215209740,736295723,499696413,425627161,3257710018,2303322505,314691346,2123743102,545110560,1678895716,2215344004,1841641837,1787408234,3514577873,2708588961,3472843470,935031095,4212097531,1035303229,1373702481,3695095260,759112749,2759249316,2639657373,4001552622,2252400006,2927150510,3441801677,76958980,1433879637,168691722,324044307,821552944,3543638483,1090133312,878815796,2353982860,3014657715,1817473132,712225322,1379652178,194986251,2332195723,2295898248,1341329743,1741369703,1177010758,3227985856,3036450996,674766888,2131031679,2018009208,786825006,122459655,1264933963,3341529543,1871620975,222469645,3153435835,4074459890,4081720307,2789040038,1503957849,3166243516,989458234,4011037167,4261971454,26298625,1628892769,2094935420,2988527538,1118932802,3681696731,3090106296,1220511560,749628716,3821029091,1463604823,2241478277,698968361,2102355069,2491493012,1227804233,398904087,3395891146,3284008131,1554224988,1592264030,3505224400,2278665351,2382725006,3127170490,2829392552,3072740279,3116240569,1619502944,4174732024,573974562,286987281,3732226014,2044275065,2867759274,858602547,1601784927,3065447094,2529867926,1479924312,2630135964,4232255484,444880154,4132249590,475630108,951221560,2889045932,416270104,4094070260,1767076969,1956362100,4120364277,1454219094,3672339162,3588914901,1257510218,2660180638,2729120418,1315067982,3898542056,3843922405,958608441,3254152897,1147949124,1563614813,1917216882,648045862,2479733907,64674563,3334142150,4204710138,2195105922,3480103887,1349533776,3951418603,1963654773,2324902538,2380244109,1277807180,337383444,1943478643,3434410188,164942601,277503248,3796963298,0,2585358234,3759840736,2408855183,3871818470,3972614892,4258422525,2877276587,3634946264);sub __mds_rem;sub __usage;sub __padding_error;use vars qw ($KEYSIZE);$KEYSIZE=32;sub new {__usage (__PACKAGE__ ."->new (key)")unless @_==2;my ($class,$key)=@_;my@key=unpack "C*",$key;my$keylength=@key;__padding_error ($keylength)unless$keylength==16 || $keylength==24 || $keylength==32;$keylength /= 8;my$self={__keylength=>$keylength };my@le_longs=unpack "V*",$key;my@K;my (@S0,@S1,@S2,@S3)=@_;my ($A,$B,$C);my ($i,$j);if ($keylength==2){my ($s7,$s6,$s5,$s4)=__mds_rem ($le_longs[0],$le_longs[1]);my ($s3,$s2,$s1,$s0)=__mds_rem ($le_longs[2],$le_longs[3]);for ($i=0,$j=1;$i < 40;$i += 2,$j += 2){$A=$m0[$q0[$q0[$i]^ $key[8]]^ $key[0]]^ $m1[$q0[$q1[$i]^ $key[9]]^ $key[1]]^ $m2[$q1[$q0[$i]^ $key[10]]^ $key[2]]^ $m3[$q1[$q1[$i]^ $key[11]]^ $key[3]];$B=$m0[$q0[$q0[$j]^ $key[12]]^ $key[4]]^ $m1[$q0[$q1[$j]^ $key[13]]^ $key[5]]^ $m2[$q1[$q0[$j]^ $key[14]]^ $key[6]]^ $m3[$q1[$q1[$j]^ $key[15]]^ $key[7]];$B=($B << 8)| ($B >> 24 & 0xff);push@K,$A += $B;push@K,(($A += $B)<< 9 | $A >> 23 & 0x1ff)}for (0 .. 255){$S0[$_]=$m0[$q0[$q0[$_]^ $s4]^ $s0];$S1[$_]=$m1[$q0[$q1[$_]^ $s5]^ $s1];$S2[$_]=$m2[$q1[$q0[$_]^ $s6]^ $s2];$S3[$_]=$m3[$q1[$q1[$_]^ $s7]^ $s3]}}elsif ($keylength==3){my ($sb,$sa,$s9,$s8)=__mds_rem ($le_longs[0],$le_longs[1]);my ($s7,$s6,$s5,$s4)=__mds_rem ($le_longs[2],$le_longs[3]);my ($s3,$s2,$s1,$s0)=__mds_rem ($le_longs[4],$le_longs[5]);for ($i=0,$j=1;$i < 40;$i += 2,$j += 2){$A=$m0[$q0[$q0[$q1[$i]^ $key[16]]^ $key[8]]^ $key[0]]^ $m1[$q0[$q1[$q1[$i]^ $key[17]]^ $key[9]]^ $key[1]]^ $m2[$q1[$q0[$q0[$i]^ $key[18]]^ $key[10]]^ $key[2]]^ $m3[$q1[$q1[$q0[$i]^ $key[19]]^ $key[11]]^ $key[3]];$B=$m0[$q0[$q0[$q1[$j]^ $key[20]]^ $key[12]]^ $key[4]]^ $m1[$q0[$q1[$q1[$j]^ $key[21]]^ $key[13]]^ $key[5]]^ $m2[$q1[$q0[$q0[$j]^ $key[22]]^ $key[14]]^ $key[6]]^ $m3[$q1[$q1[$q0[$j]^ $key[23]]^ $key[15]]^ $key[7]];$B=($B << 8)| ($B >> 24 & 0xff);push@K,$A += $B;push@K,(($A += $B)<< 9 | $A >> 23 & 0x1ff)}for (0 .. 255){$S0[$_]=$m0[$q0[$q0[$q1[$_]^ $s8]^ $s4]^ $s0];$S1[$_]=$m1[$q0[$q1[$q1[$_]^ $s9]^ $s5]^ $s1];$S2[$_]=$m2[$q1[$q0[$q0[$_]^ $sa]^ $s6]^ $s2];$S3[$_]=$m3[$q1[$q1[$q0[$_]^ $sb]^ $s7]^ $s3]}}elsif ($keylength==4){my ($sf,$se,$sd,$sc)=__mds_rem ($le_longs[0],$le_longs[1]);my ($sb,$sa,$s9,$s8)=__mds_rem ($le_longs[2],$le_longs[3]);my ($s7,$s6,$s5,$s4)=__mds_rem ($le_longs[4],$le_longs[5]);my ($s3,$s2,$s1,$s0)=__mds_rem ($le_longs[6],$le_longs[7]);for ($i=0,$j=1;$i < 40;$i += 2,$j += 2){$A=$m0[$q0[$q0[$q1[$q1[$i]^ $key[24]]^ $key[16]]^ $key[8]]^ $key[0]]^ $m1[$q0[$q1[$q1[$q0[$i]^ $key[25]]^ $key[17]]^ $key[9]]^ $key[1]]^ $m2[$q1[$q0[$q0[$q0[$i]^ $key[26]]^ $key[18]]^ $key[10]]^ $key[2]]^ $m3[$q1[$q1[$q0[$q1[$i]^ $key[27]]^ $key[19]]^ $key[11]]^ $key[3]];$B=$m0[$q0[$q0[$q1[$q1[$j]^ $key[28]]^ $key[20]]^ $key[12]]^ $key[4]]^ $m1[$q0[$q1[$q1[$q0[$j]^ $key[29]]^ $key[21]]^ $key[13]]^ $key[5]]^ $m2[$q1[$q0[$q0[$q0[$j]^ $key[30]]^ $key[22]]^ $key[14]]^ $key[6]]^ $m3[$q1[$q1[$q0[$q1[$j]^ $key[31]]^ $key[23]]^ $key[15]]^ $key[7]];$B=($B << 8)| ($B >> 24 & 0xff);push@K,$A += $B;push@K,(($A += $B)<< 9 | $A >> 23 & 0x1ff)}for (0 .. 255){$S0[$_]=$m0[$q0[$q0[$q1[$q1[$_]^$sc]^$s8]^$s4]^$s0];$S1[$_]=$m1[$q0[$q1[$q1[$q0[$_]^$sd]^$s9]^$s5]^$s1];$S2[$_]=$m2[$q1[$q0[$q0[$q0[$_]^$se]^$sa]^$s6]^$s2];$S3[$_]=$m3[$q1[$q1[$q0[$q1[$_]^$sf]^$sb]^$s7]^$s3]}}$self->{__K}=\@K;$self->{__S}=[\@S0,\@S1,\@S2,\@S3 ];bless$self,$class}sub keysize {my$self=shift;if (ref$self){return$self->{__keylength}* 8}else {return$KEYSIZE}}sub blocksize {16}sub new_encrypt {my ($self,$plain)=@_;&{$self->{__encrypt}}($self,$plain)}sub encrypt {my ($self,$cipher)=@_;my@words=unpack "V4",$cipher;my$K=$self->{__K};my$R0=$K->[0]^ $words[0];my$R1=$K->[1]^ $words[1];my$R2=$K->[2]^ $words[2];my$R3=$K->[3]^ $words[3];my ($t0,$t1);my ($S0,$S1,$S2,$S3)=@{$self->{__S}};$t0=$S0->[$R0 & 0xff]^ $S1->[($R0 >> 8)& 0xff]^ $S2->[($R0 >> 16)& 0xff]^ $S3->[($R0 >> 24)& 0xff];$t1=$S0->[($R1 >> 24)& 0xff]^ $S1->[$R1 & 0xff]^ $S2->[($R1 >> 8)& 0xff]^ $S3->[($R1 >> 16)& 0xff];$R2 ^=($t0 + $t1 + $K->[8]);$R2=($R2 >> 1 & 0x7fffffff)| ($R2 << 31);$R3=(($R3 >> 31)& 1)| ($R3 << 1);$R3 ^=($t0 + ($t1 << 1)+ $K->[9]);$t0=$S0->[$R2 & 0xff]^ $S1->[($R2 >> 8)& 0xff]^ $S2->[($R2 >> 16)& 0xff]^ $S3->[($R2 >> 24)& 0xff];$t1=$S0->[($R3 >> 24)& 0xff]^ $S1->[$R3 & 0xff]^ $S2->[($R3 >> 8)& 0xff]^ $S3->[($R3 >> 16)& 0xff];$R0 ^=($t0 + $t1 + $K->[10]);$R0=($R0 >> 1 & 0x7fffffff)| ($R0 << 31);$R1=(($R1 >> 31)& 1)| ($R1 << 1);$R1 ^=($t0 + ($t1 << 1)+ $K->[11]);$t0=$S0->[$R0 & 0xff]^ $S1->[($R0 >> 8)& 0xff]^ $S2->[($R0 >> 16)& 0xff]^ $S3->[($R0 >> 24)& 0xff];$t1=$S0->[($R1 >> 24)& 0xff]^ $S1->[$R1 & 0xff]^ $S2->[($R1 >> 8)& 0xff]^ $S3->[($R1 >> 16)& 0xff];$R2 ^=($t0 + $t1 + $K->[12]);$R2=($R2 >> 1 & 0x7fffffff)| ($R2 << 31);$R3=(($R3 >> 31)& 1)| ($R3 << 1);$R3 ^=($t0 + ($t1 << 1)+ $K->[13]);$t0=$S0->[$R2 & 0xff]^ $S1->[($R2 >> 8)& 0xff]^ $S2->[($R2 >> 16)& 0xff]^ $S3->[($R2 >> 24)& 0xff];$t1=$S0->[($R3 >> 24)& 0xff]^ $S1->[$R3 & 0xff]^ $S2->[($R3 >> 8)& 0xff]^ $S3->[($R3 >> 16)& 0xff];$R0 ^=($t0 + $t1 + $K->[14]);$R0=($R0 >> 1 & 0x7fffffff)| ($R0 << 31);$R1=(($R1 >> 31)& 1)| ($R1 << 1);$R1 ^=($t0 + ($t1 << 1)+ $K->[15]);$t0=$S0->[$R0 & 0xff]^ $S1->[($R0 >> 8)& 0xff]^ $S2->[($R0 >> 16)& 0xff]^ $S3->[($R0 >> 24)& 0xff];$t1=$S0->[($R1 >> 24)& 0xff]^ $S1->[$R1 & 0xff]^ $S2->[($R1 >> 8)& 0xff]^ $S3->[($R1 >> 16)& 0xff];$R2 ^=($t0 + $t1 + $K->[16]);$R2=($R2 >> 1 & 0x7fffffff)| ($R2 << 31);$R3=(($R3 >> 31)& 1)| ($R3 << 1);$R3 ^=($t0 + ($t1 << 1)+ $K->[17]);$t0=$S0->[$R2 & 0xff]^ $S1->[($R2 >> 8)& 0xff]^ $S2->[($R2 >> 16)& 0xff]^ $S3->[($R2 >> 24)& 0xff];$t1=$S0->[($R3 >> 24)& 0xff]^ $S1->[$R3 & 0xff]^ $S2->[($R3 >> 8)& 0xff]^ $S3->[($R3 >> 16)& 0xff];$R0 ^=($t0 + $t1 + $K->[18]);$R0=($R0 >> 1 & 0x7fffffff)| ($R0 << 31);$R1=(($R1 >> 31)& 1)| ($R1 << 1);$R1 ^=($t0 + ($t1 << 1)+ $K->[19]);$t0=$S0->[$R0 & 0xff]^ $S1->[($R0 >> 8)& 0xff]^ $S2->[($R0 >> 16)& 0xff]^ $S3->[($R0 >> 24)& 0xff];$t1=$S0->[($R1 >> 24)& 0xff]^ $S1->[$R1 & 0xff]^ $S2->[($R1 >> 8)& 0xff]^ $S3->[($R1 >> 16)& 0xff];$R2 ^=($t0 + $t1 + $K->[20]);$R2=($R2 >> 1 & 0x7fffffff)| ($R2 << 31);$R3=(($R3 >> 31)& 1)| ($R3 << 1);$R3 ^=($t0 + ($t1 << 1)+ $K->[21]);$t0=$S0->[$R2 & 0xff]^ $S1->[($R2 >> 8)& 0xff]^ $S2->[($R2 >> 16)& 0xff]^ $S3->[($R2 >> 24)& 0xff];$t1=$S0->[($R3 >> 24)& 0xff]^ $S1->[$R3 & 0xff]^ $S2->[($R3 >> 8)& 0xff]^ $S3->[($R3 >> 16)& 0xff];$R0 ^=($t0 + $t1 + $K->[22]);$R0=($R0 >> 1 & 0x7fffffff)| ($R0 << 31);$R1=(($R1 >> 31)& 1)| ($R1 << 1);$R1 ^=($t0 + ($t1 << 1)+ $K->[23]);$t0=$S0->[$R0 & 0xff]^ $S1->[($R0 >> 8)& 0xff]^ $S2->[($R0 >> 16)& 0xff]^ $S3->[($R0 >> 24)& 0xff];$t1=$S0->[($R1 >> 24)& 0xff]^ $S1->[$R1 & 0xff]^ $S2->[($R1 >> 8)& 0xff]^ $S3->[($R1 >> 16)& 0xff];$R2 ^=($t0 + $t1 + $K->[24]);$R2=($R2 >> 1 & 0x7fffffff)| ($R2 << 31);$R3=(($R3 >> 31)& 1)| ($R3 << 1);$R3 ^=($t0 + ($t1 << 1)+ $K->[25]);$t0=$S0->[$R2 & 0xff]^ $S1->[($R2 >> 8)& 0xff]^ $S2->[($R2 >> 16)& 0xff]^ $S3->[($R2 >> 24)& 0xff];$t1=$S0->[($R3 >> 24)& 0xff]^ $S1->[$R3 & 0xff]^ $S2->[($R3 >> 8)& 0xff]^ $S3->[($R3 >> 16)& 0xff];$R0 ^=($t0 + $t1 + $K->[26]);$R0=($R0 >> 1 & 0x7fffffff)| ($R0 << 31);$R1=(($R1 >> 31)& 1)| ($R1 << 1);$R1 ^=($t0 + ($t1 << 1)+ $K->[27]);$t0=$S0->[$R0 & 0xff]^ $S1->[($R0 >> 8)& 0xff]^ $S2->[($R0 >> 16)& 0xff]^ $S3->[($R0 >> 24)& 0xff];$t1=$S0->[($R1 >> 24)& 0xff]^ $S1->[$R1 & 0xff]^ $S2->[($R1 >> 8)& 0xff]^ $S3->[($R1 >> 16)& 0xff];$R2 ^=($t0 + $t1 + $K->[28]);$R2=($R2 >> 1 & 0x7fffffff)| ($R2 << 31);$R3=(($R3 >> 31)& 1)| ($R3 << 1);$R3 ^=($t0 + ($t1 << 1)+ $K->[29]);$t0=$S0->[$R2 & 0xff]^ $S1->[($R2 >> 8)& 0xff]^ $S2->[($R2 >> 16)& 0xff]^ $S3->[($R2 >> 24)& 0xff];$t1=$S0->[($R3 >> 24)& 0xff]^ $S1->[$R3 & 0xff]^ $S2->[($R3 >> 8)& 0xff]^ $S3->[($R3 >> 16)& 0xff];$R0 ^=($t0 + $t1 + $K->[30]);$R0=($R0 >> 1 & 0x7fffffff)| ($R0 << 31);$R1=(($R1 >> 31)& 1)| ($R1 << 1);$R1 ^=($t0 + ($t1 << 1)+ $K->[31]);$t0=$S0->[$R0 & 0xff]^ $S1->[($R0 >> 8)& 0xff]^ $S2->[($R0 >> 16)& 0xff]^ $S3->[($R0 >> 24)& 0xff];$t1=$S0->[($R1 >> 24)& 0xff]^ $S1->[$R1 & 0xff]^ $S2->[($R1 >> 8)& 0xff]^ $S3->[($R1 >> 16)& 0xff];$R2 ^=($t0 + $t1 + $K->[32]);$R2=($R2 >> 1 & 0x7fffffff)| ($R2 << 31);$R3=(($R3 >> 31)& 1)| ($R3 << 1);$R3 ^=($t0 + ($t1 << 1)+ $K->[33]);$t0=$S0->[$R2 & 0xff]^ $S1->[($R2 >> 8)& 0xff]^ $S2->[($R2 >> 16)& 0xff]^ $S3->[($R2 >> 24)& 0xff];$t1=$S0->[($R3 >> 24)& 0xff]^ $S1->[$R3 & 0xff]^ $S2->[($R3 >> 8)& 0xff]^ $S3->[($R3 >> 16)& 0xff];$R0 ^=($t0 + $t1 + $K->[34]);$R0=($R0 >> 1 & 0x7fffffff)| ($R0 << 31);$R1=(($R1 >> 31)& 1)| ($R1 << 1);$R1 ^=($t0 + ($t1 << 1)+ $K->[35]);$t0=$S0->[$R0 & 0xff]^ $S1->[($R0 >> 8)& 0xff]^ $S2->[($R0 >> 16)& 0xff]^ $S3->[($R0 >> 24)& 0xff];$t1=$S0->[($R1 >> 24)& 0xff]^ $S1->[$R1 & 0xff]^ $S2->[($R1 >> 8)& 0xff]^ $S3->[($R1 >> 16)& 0xff];$R2 ^=($t0 + $t1 + $K->[36]);$R2=($R2 >> 1 & 0x7fffffff)| ($R2 << 31);$R3=(($R3 >> 31)& 1)| ($R3 << 1);$R3 ^=($t0 + ($t1 << 1)+ $K->[37]);$t0=$S0->[$R2 & 0xff]^ $S1->[($R2 >> 8)& 0xff]^ $S2->[($R2 >> 16)& 0xff]^ $S3->[($R2 >> 24)& 0xff];$t1=$S0->[($R3 >> 24)& 0xff]^ $S1->[$R3 & 0xff]^ $S2->[($R3 >> 8)& 0xff]^ $S3->[($R3 >> 16)& 0xff];$R0 ^=($t0 + $t1 + $K->[38]);$R0=($R0 >> 1 & 0x7fffffff)| ($R0 << 31);$R1=(($R1 >> 31)& 1)| ($R1 << 1);$R1 ^=($t0 + ($t1 << 1)+ $K->[39]);return pack "V4",($K->[4]^ $R2,$K->[5]^ $R3,$K->[6]^ $R0,$K->[7]^ $R1)}sub decrypt {my ($self,$plain)=@_;my@words=unpack "V4",$plain;my$K=$self->{__K};my$S=$self->{__S};my$R0=$K->[4]^ $words[0];my$R1=$K->[5]^ $words[1];my$R2=$K->[6]^ $words[2];my$R3=$K->[7]^ $words[3];my ($t0,$t1);my ($S0,$S1,$S2,$S3)=@{$self->{__S}};$t0=$S0->[$R0 & 0xff]^ $S1->[$R0 >> 8 & 0xff]^ $S2->[$R0 >> 16 & 0xff]^ $S3->[$R0 >> 24 & 0xff];$t1=$S0->[$R1 >> 24 & 0xff]^ $S1->[$R1 & 0xff]^ $S2->[$R1 >> 8 & 0xff]^ $S3->[$R1 >> 16 & 0xff];$R2=$R2 >> 31 & 0x1 | $R2 << 1;$R2 ^=$t0 + $t1 + $K->[38];$R3 ^=$t0 + ($t1 << 1)+ $K->[39];$R3=$R3 >> 1 & 0x7fffffff | $R3 << 31;$t0=$S0->[$R2 & 0xff]^ $S1->[$R2 >> 8 & 0xff]^ $S2->[$R2 >> 16 & 0xff]^ $S3->[$R2 >> 24 & 0xff];$t1=$S0->[$R3 >> 24 & 0xff]^ $S1->[$R3 & 0xff]^ $S2->[$R3 >> 8 & 0xff]^ $S3->[$R3 >> 16 & 0xff];$R0=$R0 >> 31 & 0x1 | $R0 << 1;$R0 ^=$t0 + $t1 + $K->[36];$R1 ^=$t0 + ($t1 << 1)+ $K->[37];$R1=$R1 >> 1 & 0x7fffffff | $R1 << 31;$t0=$S0->[$R0 & 0xff]^ $S1->[$R0 >> 8 & 0xff]^ $S2->[$R0 >> 16 & 0xff]^ $S3->[$R0 >> 24 & 0xff];$t1=$S0->[$R1 >> 24 & 0xff]^ $S1->[$R1 & 0xff]^ $S2->[$R1 >> 8 & 0xff]^ $S3->[$R1 >> 16 & 0xff];$R2=$R2 >> 31 & 0x1 | $R2 << 1;$R2 ^=$t0 + $t1 + $K->[34];$R3 ^=$t0 + ($t1 << 1)+ $K->[35];$R3=$R3 >> 1 & 0x7fffffff | $R3 << 31;$t0=$S0->[$R2 & 0xff]^ $S1->[$R2 >> 8 & 0xff]^ $S2->[$R2 >> 16 & 0xff]^ $S3->[$R2 >> 24 & 0xff];$t1=$S0->[$R3 >> 24 & 0xff]^ $S1->[$R3 & 0xff]^ $S2->[$R3 >> 8 & 0xff]^ $S3->[$R3 >> 16 & 0xff];$R0=$R0 >> 31 & 0x1 | $R0 << 1;$R0 ^=$t0 + $t1 + $K->[32];$R1 ^=$t0 + ($t1 << 1)+ $K->[33];$R1=$R1 >> 1 & 0x7fffffff | $R1 << 31;$t0=$S0->[$R0 & 0xff]^ $S1->[$R0 >> 8 & 0xff]^ $S2->[$R0 >> 16 & 0xff]^ $S3->[$R0 >> 24 & 0xff];$t1=$S0->[$R1 >> 24 & 0xff]^ $S1->[$R1 & 0xff]^ $S2->[$R1 >> 8 & 0xff]^ $S3->[$R1 >> 16 & 0xff];$R2=$R2 >> 31 & 0x1 | $R2 << 1;$R2 ^=$t0 + $t1 + $K->[30];$R3 ^=$t0 + ($t1 << 1)+ $K->[31];$R3=$R3 >> 1 & 0x7fffffff | $R3 << 31;$t0=$S0->[$R2 & 0xff]^ $S1->[$R2 >> 8 & 0xff]^ $S2->[$R2 >> 16 & 0xff]^ $S3->[$R2 >> 24 & 0xff];$t1=$S0->[$R3 >> 24 & 0xff]^ $S1->[$R3 & 0xff]^ $S2->[$R3 >> 8 & 0xff]^ $S3->[$R3 >> 16 & 0xff];$R0=$R0 >> 31 & 0x1 | $R0 << 1;$R0 ^=$t0 + $t1 + $K->[28];$R1 ^=$t0 + ($t1 << 1)+ $K->[29];$R1=$R1 >> 1 & 0x7fffffff | $R1 << 31;$t0=$S0->[$R0 & 0xff]^ $S1->[$R0 >> 8 & 0xff]^ $S2->[$R0 >> 16 & 0xff]^ $S3->[$R0 >> 24 & 0xff];$t1=$S0->[$R1 >> 24 & 0xff]^ $S1->[$R1 & 0xff]^ $S2->[$R1 >> 8 & 0xff]^ $S3->[$R1 >> 16 & 0xff];$R2=$R2 >> 31 & 0x1 | $R2 << 1;$R2 ^=$t0 + $t1 + $K->[26];$R3 ^=$t0 + ($t1 << 1)+ $K->[27];$R3=$R3 >> 1 & 0x7fffffff | $R3 << 31;$t0=$S0->[$R2 & 0xff]^ $S1->[$R2 >> 8 & 0xff]^ $S2->[$R2 >> 16 & 0xff]^ $S3->[$R2 >> 24 & 0xff];$t1=$S0->[$R3 >> 24 & 0xff]^ $S1->[$R3 & 0xff]^ $S2->[$R3 >> 8 & 0xff]^ $S3->[$R3 >> 16 & 0xff];$R0=$R0 >> 31 & 0x1 | $R0 << 1;$R0 ^=$t0 + $t1 + $K->[24];$R1 ^=$t0 + ($t1 << 1)+ $K->[25];$R1=$R1 >> 1 & 0x7fffffff | $R1 << 31;$t0=$S0->[$R0 & 0xff]^ $S1->[$R0 >> 8 & 0xff]^ $S2->[$R0 >> 16 & 0xff]^ $S3->[$R0 >> 24 & 0xff];$t1=$S0->[$R1 >> 24 & 0xff]^ $S1->[$R1 & 0xff]^ $S2->[$R1 >> 8 & 0xff]^ $S3->[$R1 >> 16 & 0xff];$R2=$R2 >> 31 & 0x1 | $R2 << 1;$R2 ^=$t0 + $t1 + $K->[22];$R3 ^=$t0 + ($t1 << 1)+ $K->[23];$R3=$R3 >> 1 & 0x7fffffff | $R3 << 31;$t0=$S0->[$R2 & 0xff]^ $S1->[$R2 >> 8 & 0xff]^ $S2->[$R2 >> 16 & 0xff]^ $S3->[$R2 >> 24 & 0xff];$t1=$S0->[$R3 >> 24 & 0xff]^ $S1->[$R3 & 0xff]^ $S2->[$R3 >> 8 & 0xff]^ $S3->[$R3 >> 16 & 0xff];$R0=$R0 >> 31 & 0x1 | $R0 << 1;$R0 ^=$t0 + $t1 + $K->[20];$R1 ^=$t0 + ($t1 << 1)+ $K->[21];$R1=$R1 >> 1 & 0x7fffffff | $R1 << 31;$t0=$S0->[$R0 & 0xff]^ $S1->[$R0 >> 8 & 0xff]^ $S2->[$R0 >> 16 & 0xff]^ $S3->[$R0 >> 24 & 0xff];$t1=$S0->[$R1 >> 24 & 0xff]^ $S1->[$R1 & 0xff]^ $S2->[$R1 >> 8 & 0xff]^ $S3->[$R1 >> 16 & 0xff];$R2=$R2 >> 31 & 0x1 | $R2 << 1;$R2 ^=$t0 + $t1 + $K->[18];$R3 ^=$t0 + ($t1 << 1)+ $K->[19];$R3=$R3 >> 1 & 0x7fffffff | $R3 << 31;$t0=$S0->[$R2 & 0xff]^ $S1->[$R2 >> 8 & 0xff]^ $S2->[$R2 >> 16 & 0xff]^ $S3->[$R2 >> 24 & 0xff];$t1=$S0->[$R3 >> 24 & 0xff]^ $S1->[$R3 & 0xff]^ $S2->[$R3 >> 8 & 0xff]^ $S3->[$R3 >> 16 & 0xff];$R0=$R0 >> 31 & 0x1 | $R0 << 1;$R0 ^=$t0 + $t1 + $K->[16];$R1 ^=$t0 + ($t1 << 1)+ $K->[17];$R1=$R1 >> 1 & 0x7fffffff | $R1 << 31;$t0=$S0->[$R0 & 0xff]^ $S1->[$R0 >> 8 & 0xff]^ $S2->[$R0 >> 16 & 0xff]^ $S3->[$R0 >> 24 & 0xff];$t1=$S0->[$R1 >> 24 & 0xff]^ $S1->[$R1 & 0xff]^ $S2->[$R1 >> 8 & 0xff]^ $S3->[$R1 >> 16 & 0xff];$R2=$R2 >> 31 & 0x1 | $R2 << 1;$R2 ^=$t0 + $t1 + $K->[14];$R3 ^=$t0 + ($t1 << 1)+ $K->[15];$R3=$R3 >> 1 & 0x7fffffff | $R3 << 31;$t0=$S0->[$R2 & 0xff]^ $S1->[$R2 >> 8 & 0xff]^ $S2->[$R2 >> 16 & 0xff]^ $S3->[$R2 >> 24 & 0xff];$t1=$S0->[$R3 >> 24 & 0xff]^ $S1->[$R3 & 0xff]^ $S2->[$R3 >> 8 & 0xff]^ $S3->[$R3 >> 16 & 0xff];$R0=$R0 >> 31 & 0x1 | $R0 << 1;$R0 ^=$t0 + $t1 + $K->[12];$R1 ^=$t0 + ($t1 << 1)+ $K->[13];$R1=$R1 >> 1 & 0x7fffffff | $R1 << 31;$t0=$S0->[$R0 & 0xff]^ $S1->[$R0 >> 8 & 0xff]^ $S2->[$R0 >> 16 & 0xff]^ $S3->[$R0 >> 24 & 0xff];$t1=$S0->[$R1 >> 24 & 0xff]^ $S1->[$R1 & 0xff]^ $S2->[$R1 >> 8 & 0xff]^ $S3->[$R1 >> 16 & 0xff];$R2=$R2 >> 31 & 0x1 | $R2 << 1;$R2 ^=$t0 + $t1 + $K->[10];$R3 ^=$t0 + ($t1 << 1)+ $K->[11];$R3=$R3 >> 1 & 0x7fffffff | $R3 << 31;$t0=$S0->[$R2 & 0xff]^ $S1->[$R2 >> 8 & 0xff]^ $S2->[$R2 >> 16 & 0xff]^ $S3->[$R2 >> 24 & 0xff];$t1=$S0->[$R3 >> 24 & 0xff]^ $S1->[$R3 & 0xff]^ $S2->[$R3 >> 8 & 0xff]^ $S3->[$R3 >> 16 & 0xff];$R0=$R0 >> 31 & 0x1 | $R0 << 1;$R0 ^=$t0 + $t1 + $K->[8];$R1 ^=$t0 + ($t1 << 1)+ $K->[9];$R1=$R1 >> 1 & 0x7fffffff | $R1 << 31;return pack "V4",($K->[0]^ $R2,$K->[1]^ $R3,$K->[2]^ $R0,$K->[3]^ $R1)}sub __usage {my$msg=shift;my ($package,$filename,$line,$subr)=caller (1);require Carp;$Carp::CarpLevel=2;Carp::croak ("Usage:"," $msg")}sub __padding_error {my$keylength=shift;require Carp;$Carp::CarpLevel=2;Carp::croak (x ("wrong key length {keylength}: " ."key must be 16, 24 or 32 bytes long",$keylength))}sub __mds_rem {my ($A,$B)=@_;my ($t,$u);for (0 .. 7){$t=0xff & ($B >> 24);$B=($B << 8)| (0xff & ($A >> 24));$A <<=8;$u=$t << 1;$u ^=0x14d if$t & 0x80;$B ^=$t ^ ($u << 16);$u ^=0x7fffffff & ($t >> 1);$u ^=0xa6 if$t & 0x01;$B ^=($u << 24)| ($u << 8)}return map 0xff & $_,$B >> 24,$B >> 16,$B >> 8,$B}1;
CRYPT_TWOFISH_PP

$fatpacked{"Crypt/Twofish_PP/Key16.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CRYPT_TWOFISH_PP_KEY16';
  package Crypt::Twofish_PP::Key16;use strict;use Crypt::Twofish_PP;use base qw (Crypt::Twofish_PP);use vars qw ($KEYSIZE);$KEYSIZE=16;sub keysize {my$self=shift;if (ref$self){return$self->{__keylength}* 8}else {return$KEYSIZE}}1;
CRYPT_TWOFISH_PP_KEY16

$fatpacked{"Crypt/Twofish_PP/Key24.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CRYPT_TWOFISH_PP_KEY24';
  package Crypt::Twofish_PP::Key24;use strict;use Crypt::Twofish_PP;use base qw (Crypt::Twofish_PP);use vars qw ($KEYSIZE);$KEYSIZE=24;sub keysize {my$self=shift;if (ref$self){return$self->{__keylength}* 8}else {return$KEYSIZE}}1;
CRYPT_TWOFISH_PP_KEY24

$fatpacked{"Crypt/Twofish_PP/Key32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CRYPT_TWOFISH_PP_KEY32';
  package Crypt::Twofish_PP::Key32;use strict;use Crypt::Twofish_PP;use base qw (Crypt::Twofish_PP);use vars qw ($KEYSIZE);$KEYSIZE=32;sub keysize {my$self=shift;if (ref$self){return$self->{__keylength}* 8}else {return$KEYSIZE}}1;
CRYPT_TWOFISH_PP_KEY32

$fatpacked{"Crypt/XXTEA_PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CRYPT_XXTEA_PP';
  package Crypt::XXTEA_PP;use strict;use warnings;use utf8;use integer;use Carp;our$VERSION='0.0102';use Config;BEGIN {if (not defined$Config{use64bitint}){require bigint;bigint->import}}my$DELTA=0x9e3779b9;my$FACTOR=4;my$KEY_SIZE=16;my$ELEMENTS_IN_KEY=$KEY_SIZE / $FACTOR;my$MIN_BLOCK_SIZE=8;my$MIN_ELEMENTS_IN_BLOCK=$MIN_BLOCK_SIZE / $FACTOR;use constant keysize=>$KEY_SIZE;use constant blocksize=>$MIN_BLOCK_SIZE;sub isint {local $_=shift;return 0 unless defined;return 1 if /\A\s*[+-]?(?:0|[1-9][0-9]*)\s*\z/s;0}sub all (&@) {my$f=shift;$f->()or return 0 foreach @_;return 1}sub new {my$class=shift;my$key=shift;my$xxtea_key;croak('key is required')if not defined$key;if (my$ref_of_key=ref($key)){croak(sprintf('key must be a %d-byte-long STRING or a reference of ARRAY',$KEY_SIZE))if not $ref_of_key eq 'ARRAY';croak(sprintf('key must has %d elements if key is a reference of ARRAY',$ELEMENTS_IN_KEY))if scalar(@{$key})!=$ELEMENTS_IN_KEY;croak('each element of key must be a 32bit Integer if key is a reference of ARRAY')if not all {isint($_)!=0}@{$key};$xxtea_key=$key}else {croak(sprintf('key must be a %d-byte-long STRING or a reference of ARRAY',$KEY_SIZE))if length$key!=$KEY_SIZE;$xxtea_key=key_setup($key)}my$self={key=>$xxtea_key,};bless$self,ref($class)|| $class}sub encrypt {my$self=shift;my$plain_text=shift;croak(sprintf('plain_text size must be at least %d bytes',$MIN_BLOCK_SIZE))if length($plain_text)< $MIN_BLOCK_SIZE;croak(sprintf('plain_text size must be a multiple of %d bytes',$FACTOR))if length($plain_text)% $FACTOR!=0;my@block=unpack 'N*',$plain_text;my$cipher_text_ref=$self->encrypt_block(\@block);return pack('N*',@{$cipher_text_ref})}sub decrypt {my$self=shift;my$cipher_text=shift;croak(sprintf('cipher_text size must be at least %d bytes',$MIN_BLOCK_SIZE))if length($cipher_text)< $MIN_BLOCK_SIZE;croak(sprintf('cipher_text size must be a multiple of %d bytes',$FACTOR))if length($cipher_text)% $FACTOR!=0;my@block=unpack 'N*',$cipher_text;my$plain_text_ref=$self->decrypt_block(\@block);return pack('N*',@{$plain_text_ref})}sub encrypt_block {my$self=shift;my$block_ref=shift;my$key_ref=$self->{key};croak(sprintf('block must has at least %d elements',$MIN_ELEMENTS_IN_BLOCK))if scalar(@{$block_ref})< $MIN_ELEMENTS_IN_BLOCK;croak(sprintf('key must has %d elements',$ELEMENTS_IN_KEY))if scalar(@{$key_ref})!=$ELEMENTS_IN_KEY;my@block=map {$_ & 0xffff_ffff}@{$block_ref};my@key=map {$_ & 0xffff_ffff}@{$key_ref};my$delta=$DELTA & 0xffff_ffff;my$rounds=6 + 52 / (scalar@block);my$sum=0 & 0xffff_ffff;my$z=$block[-1];my ($e,$p,$y);for (0 .. $rounds-1){$sum=($sum + $delta)& 0xffff_ffff;$e=($sum >> 2)& 3;for (0 .. $#block-1){$p=$_;$y=$block[$p + 1 ];$z=$block[$p ]=($block[$p ]+ _MX($y,$z,$sum,$p,$e,\@key))& 0xffff_ffff}$p += 1;$y=$block[0];$z=$block[-1]=($block[-1]+ _MX($y,$z,$sum,$p,$e,\@key))& 0xffff_ffff}return \@block}sub decrypt_block {my$self=shift;my$block_ref=shift;my$key_ref=$self->{key};croak(sprintf('block must has at least %d elements',$MIN_ELEMENTS_IN_BLOCK))if scalar(@{$block_ref})< $MIN_ELEMENTS_IN_BLOCK;croak(sprintf('key must has %d elements',$ELEMENTS_IN_KEY))if scalar(@{$key_ref})!=$ELEMENTS_IN_KEY;my@block=map {$_ & 0xffff_ffff}@{$block_ref};my@key=map {$_ & 0xffff_ffff}@{$key_ref};my$delta=$DELTA & 0xffff_ffff;my$rounds=6 + 52 / (scalar@block);my$sum=($rounds * $delta)& 0xffff_ffff;my$y=$block[0];my ($e,$p,$z);for (0 .. $rounds-1){$e=($sum >> 2)& 3;for (reverse 1 .. $#block){$p=$_;$z=$block[$p - 1 ];$y=$block[$p ]=($block[$p ]- _MX($y,$z,$sum,$p,$e,\@key))& 0xffff_ffff}$p -= 1;$z=$block[-1];$y=$block[0]=($block[0]- _MX($y,$z,$sum,$p,$e,\@key))& 0xffff_ffff;$sum=($sum - $delta)& 0xffff_ffff}return \@block}sub _MX {my ($y,$z,$sum,$p,$e,$key)=@_;return ((((((($z >> 5)& 0xffff_ffff)^ (($y << 2)& 0xffff_ffff))& 0xffff_ffff)+ (((($y >> 3)& 0xffff_ffff)^ (($z << 4)& 0xffff_ffff))& 0xffff_ffff))& 0xffff_ffff)^ (((($sum ^ $y)& 0xffff_ffff)+ (($key->[($p & 3)^ $e ]^ $z)& 0xffff_ffff))& 0xffff_ffff))& 0xffff_ffff}sub key_setup {my$key_str=shift;croak(sprintf('key must be %s bytes long',$KEY_SIZE))if length($key_str)!=$KEY_SIZE;my@xxtea_key=unpack 'N*',$key_str;return \@xxtea_key}1;
CRYPT_XXTEA_PP

$fatpacked{"Net/Address/IP/Local.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_ADDRESS_IP_LOCAL';
  package Net::Address::IP::Local;use version;our$VERSION=qv('0.1.2');use warnings;use strict;use Error ':try';use constant TRUE=>(0==0);use constant FALSE=>not TRUE;use constant remote_address_ipv4_default=>'198.41.0.4';use constant remote_address_ipv6_default=>'2001:503:ba3e::2:30';use constant remote_port_default=>53;sub public {my ($class)=@_;return$class->connected_to($class->remote_address_ipv4_default)if not $class->ipv6_support;my$ip_address;try {$ip_address=$class->connected_to($class->remote_address_ipv6_default)}catch Net::Address::IP::Local::Error with {my$error=shift;try {$ip_address=$class->connected_to($class->remote_address_ipv4_default)}catch Net::Address::IP::Local::Error with {$error->throw}};return$ip_address}sub public_ipv4 {my ($class)=@_;$class->ipv4_support or throw Net::Address::IP::Local::Error("IPv4 not supported");return$class->connected_to($class->remote_address_ipv4_default)}sub public_ipv6 {my ($class)=@_;$class->ipv6_support or throw Net::Address::IP::Local::Error("IPv6 not supported");return$class->connected_to($class->remote_address_ipv6_default)}sub connected_to {my ($class,$remote_address)=@_;my$socket_class;if ($class->ipv6_support){$socket_class='IO::Socket::INET6'}elsif ($class->ipv4_support){$socket_class='IO::Socket::INET'}else {throw Net::Address::IP::Local::Error("Neither IPv4 nor IPv6 supported")}my$socket=$socket_class->new(Proto=>'udp',PeerAddr=>$remote_address,PeerPort=>$class->remote_port_default);defined($socket)or throw Net::Address::IP::Local::Error("Unable to create UDP socket: $!");return$socket->sockhost}my$ipv4_support;sub ipv4_support {if (not defined($ipv4_support)){eval {require IO::Socket::INET};$ipv4_support=not $@}return$ipv4_support}my$ipv6_support;sub ipv6_support {if (not defined($ipv6_support)){eval {require IO::Socket::INET6};$ipv6_support=not $@}return$ipv6_support}package Net::Address::IP::Local::Error;use base qw(Error::Simple);package Net::Address::IP::Local;TRUE;
NET_ADDRESS_IP_LOCAL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

